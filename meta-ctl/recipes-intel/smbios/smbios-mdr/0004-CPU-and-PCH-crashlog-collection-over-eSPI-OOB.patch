From e4bb6fc395ba0af50997759af2b4e0e056660be0 Mon Sep 17 00:00:00 2001
From: Vikash Chandola <vikash.chandola@intel.com>
Date: Wed, 1 Jun 2022 19:57:02 +0000
Subject: [PATCH] CPU and PCH crashlog collection over eSPI OOB

enables CPU and PCH crashlog collection over eSPI OOB channel.

Signed-off-by: Vikash Chandola <vikash.chandola@intel.com>
Upstream-Status: Pending
---
 CMakeLists.txt   |   4 +-
 src/crashlog.cpp | 447 ++++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 445 insertions(+), 6 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index f067b6e..dc73f3d 100755
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -36,8 +36,6 @@ add_definitions (-DBOOST_ERROR_CODE_HEADER_ONLY)
 add_definitions (-DBOOST_SYSTEM_NO_DEPRECATED)
 add_definitions (-DBOOST_ALL_NO_LIB)
 add_definitions (-DBOOST_NO_RTTI)
-add_definitions (-DBOOST_NO_TYPEID)
-add_definitions (-DBOOST_ASIO_DISABLE_THREADS)
 
 set (SRC_FILES src/mdrv2.cpp src/mdrv2_main.cpp src/cpu.cpp src/dimm.cpp
      src/system.cpp src/pcieslot.cpp)
@@ -74,6 +72,8 @@ if (CPU_INFO)
     target_link_libraries (cpuinfoapp phosphor_logging)
     target_link_libraries (cpuinfoapp i2c)
     target_link_libraries (cpuinfoapp peci)
+    target_link_libraries (cpuinfoapp espi)
+    target_link_libraries (cpuinfoapp boost_coroutine)
 
     if (NOT YOCTO)
         add_dependencies (cpuinfoapp libpeci)
diff --git a/src/crashlog.cpp b/src/crashlog.cpp
index eaff296..c533179 100644
--- a/src/crashlog.cpp
+++ b/src/crashlog.cpp
@@ -21,6 +21,7 @@
 
 #include "cpuinfo.hpp"
 #include "crashlog_manifest.hpp"
+#include "espi_oob_channel.hpp"
 
 #include <peci.h>
 
@@ -32,6 +33,8 @@
 #include <iostream>
 #include <string>
 
+#define CRASH_LOG_OVER_ESPI
+
 namespace cpu_info::crashlog
 {
 static constexpr bool debug = true;
@@ -44,6 +47,199 @@ static std::shared_ptr<sdbusplus::asio::dbus_interface> crashlogEpochIface;
 static const std::filesystem::path crashlogDir = "/tmp/crashlog";
 static const std::string crashlogFilePrefix = "crashlog";
 
+static constexpr uint8_t smbusDestAddr = 0x10; // PCH PMC smbus address
+static constexpr uint8_t smbusSourceAddr = 0x0F;
+
+static constexpr uint8_t cpuCrashlogCollectionCommandCode = 0x01;
+static constexpr uint8_t cpuCrashlogRdPkgConfigIndex = 0x4A;
+static constexpr uint8_t cpuCrashlogRdPkgConfigRdLen = 0x09;
+
+static constexpr uint8_t pchCrashlogCollectionCommandCode = 0x20;
+
+static Status
+    espiTransact(boost::asio::yield_context yield, boost::asio::io_context& ioc,
+                 espi::EspioobChannel_h oobHandle, const uint8_t& destAddr,
+                 const uint8_t& commandCode,
+                 const std::vector<uint8_t>& reqPacket,
+                 std::vector<uint8_t>& respPacket,
+                 boost::system::error_code& ec, int retryCount = 3,
+                 std::chrono::duration<int, std::milli> transactDuration =
+                     std::chrono::milliseconds(500))
+{
+    bool transactionFailed = true;
+    boost::system::error_code transactErrorCode;
+    boost::asio::steady_timer waiter(ioc, transactDuration * 4);
+    oobHandle->asyncTransact(
+        destAddr, commandCode, reqPacket, respPacket,
+        [&](const boost::system::error_code& errorCode) {
+            if (errorCode)
+            {
+                transactErrorCode = errorCode;
+                transactionFailed = true;
+            }
+            else
+            {
+                transactionFailed = false;
+            }
+            waiter.cancel();
+        },
+        transactDuration);
+    waiter.async_wait(yield[ec]);
+    if (transactionFailed)
+    {
+        ec = transactErrorCode;
+        if (retryCount == 0)
+        {
+            return Status::error;
+        }
+        else
+        {
+            return espiTransact(yield, ioc, oobHandle, destAddr, commandCode,
+                                reqPacket, respPacket, ec, retryCount - 1);
+        }
+    }
+    return Status::success;
+}
+
+// peci over espi(poe) helper methods
+namespace poe
+{
+
+constexpr uint8_t successResponse = 0x40;
+constexpr uint8_t successCompletion = 0x40;
+constexpr uint8_t RdPkgConfigCommandCode = 0xA1;
+
+struct Request
+{
+    uint8_t sourceAddr;
+    uint8_t peciTargetAddr;
+    uint8_t readLen;
+    uint8_t commandCode;
+
+    Request(uint8_t sourceAddr, uint8_t peciTargetAddr, uint8_t readLen,
+            uint8_t commandCode) :
+        sourceAddr(sourceAddr),
+        peciTargetAddr(peciTargetAddr), readLen(readLen),
+        commandCode(commandCode)
+    {}
+
+    virtual std::vector<uint8_t> createPacket() const noexcept
+    {
+        std::vector<uint8_t> packet;
+        packet.push_back(sourceAddr << 1 | 0x01);
+        packet.push_back(peciTargetAddr);
+        packet.push_back(0x01);
+        packet.push_back(readLen);
+        packet.push_back(commandCode);
+        return packet;
+    }
+
+  protected:
+    static void setWriteLen(std::vector<uint8_t>& packet, uint8_t writeLen)
+    {
+        packet[2] = writeLen;
+    }
+};
+
+struct RdPkgConfig : public Request
+{
+    uint8_t hostId;
+    bool retry;
+    uint8_t index;
+    uint8_t lsb;
+    uint8_t msb;
+
+    RdPkgConfig(uint8_t sourceAddr, uint8_t peciTargetAddr, uint8_t readLen,
+                uint8_t hostId, bool retry, uint8_t index, uint8_t parameterLsb,
+                uint8_t parameterMsb) :
+        Request(sourceAddr, peciTargetAddr, readLen, RdPkgConfigCommandCode),
+        hostId(hostId), index(index), lsb(parameterLsb), msb(parameterMsb)
+    {}
+
+    std::vector<uint8_t> createPacket() const noexcept override
+    {
+        std::vector<uint8_t> packet = Request::createPacket();
+
+        Request::setWriteLen(packet, 0x05);
+        if (retry)
+        {
+            packet.push_back((hostId << 1) | 0x01);
+        }
+        else
+        {
+            packet.push_back(hostId << 1);
+        }
+        packet.push_back(index);
+        packet.push_back(lsb);
+        packet.push_back(msb);
+        return packet;
+    }
+};
+
+struct Response
+{
+    uint8_t sourceAddr;
+    uint8_t peciResponseCode;
+    uint8_t peciCompletionCode;
+    std::vector<uint8_t> data;
+};
+
+Status parsePacket(const std::vector<uint8_t>& packet, Response& resp)
+{
+    // There must be at least three bytes in valid poe packet
+    if (packet.size() < 3)
+    {
+        return Status::error;
+    }
+    resp.sourceAddr = packet[0] >> 1;
+    resp.peciResponseCode = packet[1];
+    resp.peciCompletionCode = packet[2];
+    resp.data = std::vector(packet.cbegin() + 3, packet.cend());
+    return Status::success;
+}
+
+static Status transact(boost::asio::yield_context yield,
+                       boost::asio::io_context& ioc,
+                       espi::EspioobChannel_h oobHandle,
+                       const uint8_t& destAddr, const uint8_t& commandCode,
+                       const Request& req, Response& resp,
+                       boost::system::error_code& ec, int retryCount = 3,
+                       std::chrono::duration<int, std::milli> transactDuration =
+                           std::chrono::milliseconds(500))
+{
+    constexpr size_t defaultResponseSize = 64;
+    std::vector<uint8_t> respPacket(defaultResponseSize);
+    Status retStatus = espiTransact(yield, ioc, oobHandle, destAddr,
+                                    commandCode, req.createPacket(), respPacket,
+                                    ec, retryCount, transactDuration);
+    if (retStatus != Status::success)
+    {
+        return retStatus;
+    }
+
+    retStatus = parsePacket(respPacket, resp);
+    if (retStatus != Status::success)
+    {
+        return retStatus;
+    }
+
+    if (resp.sourceAddr != destAddr ||
+                          resp.peciResponseCode != successResponse ||
+                          resp.peciCompletionCode != successCompletion)
+    {
+        std::cerr << "Error: Response source address :"
+                  << static_cast<int>(resp.sourceAddr)
+                  << " expected source address :" << static_cast<int>(destAddr)
+                  << ", peci response code :" << resp.peciResponseCode
+                  << ", peci completion code :" << resp.peciCompletionCode
+                  << "\n";
+        return Status::error;
+    }
+
+    return Status::success;
+}
+} // namespace poe
+
 bool isPECIAvailable(const uint8_t peciAddr)
 {
     return (peci_Ping(peciAddr) == PECI_CC_SUCCESS);
@@ -325,8 +521,11 @@ static std::string getFilename(const std::string& prefix, const uint8_t socket,
                        std::to_string(timestamp) + ".bin");
 }
 
-static Status saveFile(const std::string& filename, std::vector<uint64_t>& data)
+template <typename T>
+static Status saveFile(const std::string& filename, std::vector<T>& data)
 {
+    static_assert(std::is_integral_v<T>,
+                  "Require vector of integral data type");
     std::error_code ec;
     std::filesystem::create_directories(crashlogDir, ec);
 
@@ -339,14 +538,15 @@ static Status saveFile(const std::string& filename, std::vector<uint64_t>& data)
         return Status::error;
     }
 
-    file.write(reinterpret_cast<char*>(&data[0]),
+    file.write(reinterpret_cast<char*>(data.data()),
                data.size() * sizeof(data[0]));
 
     return Status::success;
 }
 
+template <typename T>
 static Status saveCrashlogFile(const uint8_t socket, const uint32_t uniqueID,
-                               std::vector<uint64_t>& crashlog,
+                               std::vector<T>& crashlog,
                                nlohmann::json& manifest)
 {
     std::string crashlogFilename =
@@ -504,7 +704,6 @@ static Status getCrashlogData(const uint8_t peciAddr, nlohmann::json& manifest)
             return Status::error;
         }
 
-        // Use the lower nibble of the PECI address as the socket number
         uint8_t socket = peciAddr & 0xF;
         if (saveCrashlogFile(socket, uniqueID, crashlog, manifest) !=
             Status::success)
@@ -515,6 +714,184 @@ static Status getCrashlogData(const uint8_t peciAddr, nlohmann::json& manifest)
     return Status::success;
 }
 
+static Status collectCPUCrashlog(boost::asio::yield_context yield,
+                                 boost::asio::io_context& ioc,
+                                 espi::EspioobChannel_h oobHandle,
+                                 std::vector<uint8_t>& cpuCrashlog)
+{
+    poe::RdPkgConfig req(smbusSourceAddr,             // source address
+                         MIN_CLIENT_ADDR,             // peci target address
+                         cpuCrashlogRdPkgConfigRdLen, // read length
+                         0x00,                        // host id
+                         false,                       // retry
+                         cpuCrashlogRdPkgConfigIndex, // peci RdPkgConfig Index
+                         0x00,                        // parameter lsb
+                         0x00                         // parameter msb
+    );
+    std::vector<uint8_t> crashlogData;
+    poe::Response resp;
+    boost::system::error_code transactError;
+    if (poe::transact(yield, ioc, oobHandle, smbusDestAddr,
+                      cpuCrashlogCollectionCommandCode, req, resp,
+                      transactError) != Status::success)
+    {
+        std::cerr << "Failed to get valid response for CPU Crashlog, Error: "
+                  << transactError << "\n";
+        return Status::error;
+    }
+
+    if (resp.data.size() != cpuCrashlogRdPkgConfigRdLen - 1)
+    {
+        std::cerr << "Invalid response length\n";
+        return Status::error;
+    }
+    // clSize is CPU crashlog size in dwords
+    // single transaction returns 8 bytes of data
+    // root@intel-obmc:~/chandola/tmp#
+    // espi_cmd -O --smbus-slave-id 0x10 --smbus-command-code 0x01
+    // --raw-transact
+    //   "0x1f 0x30 0x05 0x09 0xA1 0x00 0x4A 0x00 0x00"
+    //>>0x1f 0x30 0x05 0x09 0xa1 0x00 0x4a 0x00 0x00
+    //<<0x21 0x40 0x40 0x13 0xc3 0x05 0x03 0xd2 0x03 0x00 0x00
+    const uint32_t clSize = (*(reinterpret_cast<uint32_t*>(&resp.data[4])));
+
+    if (clSize == 0)
+    {
+        std::cerr << "CPU crashlog is not present\n";
+        return Status::error;
+    }
+    if constexpr (debug)
+    {
+        std::cout << "Expecting " << clSize << " bytes of CPU Crashlog\n";
+    }
+    std::copy(resp.data.cbegin(), resp.data.cend(),
+              std::back_inserter(crashlogData));
+
+    uint32_t clIndexUpperLimit = clSize / 2;
+    if (clSize % 2)
+    {
+        clIndexUpperLimit += 1;
+    }
+    for (uint32_t clIndex = 1; clIndex < clIndexUpperLimit; ++clIndex)
+    {
+        req.lsb = static_cast<uint8_t>(clIndex & 0xFF);
+        req.msb = static_cast<uint8_t>((clIndex >> 0x08) & 0xFF);
+        if (poe::transact(yield, ioc, oobHandle, smbusDestAddr,
+                          cpuCrashlogCollectionCommandCode, req, resp,
+                          transactError) != Status::success)
+        {
+            std::cerr << "Failed to get CPU crashlog for index :" << clIndex
+                      << "\n";
+            return Status::error;
+        }
+        std::copy(resp.data.cbegin(), resp.data.cend(),
+                  std::back_inserter(crashlogData));
+        if constexpr (debug2)
+        {
+            std::cout << "index :" << clIndex << " >";
+            std::for_each(resp.data.cbegin(), resp.data.cend(), [](uint8_t p) {
+                std::cout << "0x" << std::hex << std::setfill('0')
+                          << std::setw(2) << static_cast<int>(p) << " ";
+            });
+            std::cout << std::dec << "\n";
+        }
+    }
+    if (crashlogData.size() != clSize * 4)
+    {
+        std::cerr << "CPU crashlog size is not valid. Collected :"
+                  << crashlogData.size() << ", exptected :" << (clSize * 4)
+                  << "\n";
+        return Status::error;
+    }
+    cpuCrashlog = std::move(crashlogData);
+    return Status::success;
+}
+
+static Status collectPCHCrashlog(boost::asio::yield_context yield,
+                                 boost::asio::io_context& ioc,
+                                 espi::EspioobChannel_h oobHandle,
+                                 std::vector<uint8_t>& pchCrashlog)
+{
+    constexpr size_t PCHCrashlogResponseSize = 0x41;
+    const std::vector<uint8_t> reqPacket = {smbusSourceAddr};
+    std::vector<uint8_t> respPacket(PCHCrashlogResponseSize);
+    bool isLastPacket = true;
+    boost::system::error_code ec;
+    std::vector<uint8_t> crashlogData;
+
+    if (espiTransact(yield, ioc, oobHandle, smbusDestAddr,
+                     pchCrashlogCollectionCommandCode, reqPacket, respPacket,
+                     ec) != Status::success)
+    {
+        std::cerr << "Failed to fetch PCH crashlog\n";
+        return Status::error;
+    }
+    if (respPacket.size() != PCHCrashlogResponseSize)
+    {
+        std::cerr << "PCH crashlog is not present\n";
+        return Status::error;
+    }
+    if (respPacket[0] >> 1 != smbusDestAddr)
+    {
+        std::cerr << "Destination address mismatch in response packet\n";
+        return Status::error;
+    }
+
+    const uint32_t clSize = (*(reinterpret_cast<uint32_t*>(&respPacket[5])));
+    std::copy(respPacket.cbegin() + 1, respPacket.cend(),
+              std::back_inserter(crashlogData));
+    if (clSize == 0)
+    {
+        std::cerr << "PCH crashlog is not present\n";
+        return Status::error;
+    }
+    int clIndex = 1;
+    do
+    {
+        if (espiTransact(yield, ioc, oobHandle, smbusDestAddr,
+                         pchCrashlogCollectionCommandCode, reqPacket,
+                         respPacket, ec) != Status::success)
+        {
+            // One failure is enough to mess up the whole PCH crashlog
+            std::cerr << "Failed to fetch PCH crashlog\n";
+            return Status::error;
+        }
+        if (respPacket[0] >> 1 != smbusDestAddr)
+        {
+            std::cerr << "Destination address mismatch in response packet\n";
+            return Status::error;
+        }
+        isLastPacket = (respPacket.size() != PCHCrashlogResponseSize);
+        std::copy(respPacket.cbegin() + 1, respPacket.cend(),
+                  std::back_inserter(crashlogData));
+        if constexpr (debug2)
+        {
+            std::cout << "index :" << clIndex++ << " >";
+            std::for_each(
+                respPacket.cbegin() + 1, respPacket.cend(), [](uint8_t p) {
+                    std::cout << "0x" << std::hex << std::setfill('0')
+                              << std::setw(2) << static_cast<int>(p) << " ";
+                });
+            std::cout << std::dec << "\n";
+        }
+    } while (!isLastPacket);
+    // PCH crashlog received is larger than size advertised in header. Trim
+    // remaining portion.
+    if (crashlogData.size() < clSize * 4)
+    {
+        std::cerr << "PCH crashlog size smaller than expected. Collected :"
+                  << crashlogData.size()
+                  << " bytes, exptected :" << (clSize * 4) << " bytes\n";
+        return Status::error;
+    }
+    else if (crashlogData.size() > clSize * 4)
+    {
+        crashlogData.resize(clSize * 4);
+    }
+    pchCrashlog = std::move(crashlogData);
+    return Status::success;
+}
+
 static Status getTelemetryData(const uint8_t peciAddr, nlohmann::json& manifest)
 {
     uint16_t numTelemetryAggregators = 0;
@@ -619,6 +996,57 @@ static Status collectCrashlog(const uint8_t peciAddr, nlohmann::json& manifest)
     return retStatus;
 }
 
+Status
+    collectCrashLogOverESPI(boost::asio::yield_context yield,
+                            boost::asio::io_context& ioc,
+                            std::shared_ptr<sdbusplus::asio::connection> conn)
+{
+    nlohmann::json manifest;
+    auto oobHandle = espi::EspioobChannel::getHandle(ioc);
+    Status status;
+    if (!oobHandle)
+    {
+        std::cerr << "Failed to Get eSPI OOB handle";
+        return Status::error;
+    }
+    std::vector<uint8_t> cpuCrashlog;
+    std::vector<uint8_t> pchCrashlog;
+    if ((status = collectCPUCrashlog(yield, ioc, oobHandle, cpuCrashlog)) !=
+        Status::success)
+    {
+        std::cerr << "Failed to collect CPU crashlog";
+        return status;
+    }
+
+    if ((status = collectPCHCrashlog(yield, ioc, oobHandle, pchCrashlog)) !=
+        Status::success)
+    {
+        std::cerr << "Failed to collect PCH crashlog";
+        return status;
+    }
+
+    uint8_t stepping = 0;
+    CPUModel cpuModel{};
+    uint8_t cc = 0;
+    uint8_t peciAddr = MIN_CLIENT_ADDR;
+    EPECIStatus peciStatus = peci_GetCPUID(peciAddr, &cpuModel, &stepping, &cc);
+
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Get CPUID", peciAddr, peciStatus, cc);
+        return Status::error;
+    }
+
+    manifest::manifestCPUInfo(peciAddr, cpuModel, stepping, manifest);
+    manifest::manifestSysInfo(conn, peciAddr, manifest);
+    saveCrashlogFile(0, peciAddr, cpuCrashlog, manifest);
+    saveCrashlogFile(0, smbusDestAddr, pchCrashlog, manifest);
+    manifest::writeManifest(crashlogDir, "manifest.json", manifest);
+
+    dbusAddCrashlog();
+    return status;
+}
+
 void init(boost::asio::io_context& ioc,
           std::shared_ptr<sdbusplus::asio::connection> conn)
 {
@@ -642,6 +1070,16 @@ void init(boost::asio::io_context& ioc,
             throw LogInProgressException();
         }
         inProgress = true;
+#ifdef CRASH_LOG_OVER_ESPI
+        boost::asio::spawn([&](boost::asio::yield_context yield) {
+            dbusRemoveCrashlog();
+            if (collectCrashLogOverESPI(yield, ioc, conn) != Status::success)
+            {
+                std::cerr << "Failed to collect crashlog";
+            }
+            inProgress = false;
+        });
+#elif
         boost::asio::post(ioc, [conn]() {
             dbusRemoveCrashlog();
             nlohmann::json manifest;
@@ -677,6 +1115,7 @@ void init(boost::asio::io_context& ioc,
             }
             inProgress = false;
         });
+#endif
         return std::string("Crashlog collection started");
     });
     dumpIface->initialize();
-- 
2.25.1

