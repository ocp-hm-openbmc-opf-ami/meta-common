From 7e9965d53ff861a7ceaab920d65c49f73ffb74d9 Mon Sep 17 00:00:00 2001
From: "Jason M. Bills" <jason.m.bills@linux.intel.com>
Date: Mon, 10 Jul 2023 11:13:56 +0000
Subject: [PATCH] Add Crashlog collection support

This adds support to collect Crashlog using PECI.

It adds the xyz.openbmc_project.Dump.Create interface to
allow requests to create a Crashlog.

Once created, the Crashlog will be saved to /tmp and added
to a path under '/xyz/openbmc_project/dump/crashlog' with the
Size provided by xyz.openbmc_project.Dump.Entry and timestamp
provided by xyz.openbmc_project.Time.EpochTime.

Since there are multiple CPUs with multiple Crashlog Agents,
the format requested by the CPU team is to collect each
Crashlog as an individual binary file, then zip them together
along with a JSON manifest file to describe the platform and
binary file contents.

Tested:
Combined with the Redfish changes, ran CollectDiagnosticData
and confirmed that it triggers the BMC to collect the Crashlog
data.  The new Crashlog data is then exposed in the
LogEntryCollection and the LogEntry can be downloaded correctly
using the AdditionalDataURI.

Signed-off-by: Jason M. Bills <jason.m.bills@linux.intel.com>
Signed-off-by: vijayabharathi shetty <vijayabharathix.shetty@intel.com>
Upstream-Status: Pending
---
 CMakeLists.txt                |   2 +-
 include/crashlog.hpp          |  57 +++
 include/crashlog_manifest.hpp | 619 ++++++++++++++++++++++++++++++
 src/cpuinfo_main.cpp          |   2 +
 src/crashlog.cpp              | 683 ++++++++++++++++++++++++++++++++++
 5 files changed, 1362 insertions(+), 1 deletion(-)
 create mode 100644 include/crashlog.hpp
 create mode 100644 include/crashlog_manifest.hpp
 create mode 100644 src/crashlog.cpp

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8cffa03..bdfa851 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -79,7 +79,7 @@ option (YOCTO "Enable Building in Yocto" OFF)
 if (CPU_INFO)
     add_executable (cpuinfoapp src/cpuinfo_main.cpp src/speed_select.cpp
         src/sst_mailbox.cpp
-        src/cpuinfo_utils.cpp)
+        src/cpuinfo_utils.cpp src/crashlog.cpp)
     target_link_libraries (cpuinfoapp ${SYSTEMD_LIBRARIES})
     target_link_libraries (cpuinfoapp ${DBUSINTERFACE_LIBRARIES})
     target_link_libraries (cpuinfoapp ${SDBUSPLUSPLUS_LIBRARIES})
diff --git a/include/crashlog.hpp b/include/crashlog.hpp
new file mode 100644
index 0000000..4319e7e
--- /dev/null
+++ b/include/crashlog.hpp
@@ -0,0 +1,57 @@
+/******************************************************************************
+ *
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright 2021 Intel Corporation.
+ *
+ * This software and the related documents are Intel copyrighted materials,
+ * and your use of them is governed by the express license under which they
+ * were provided to you ("License"). Unless the License provides otherwise,
+ * you may not use, modify, copy, publish, distribute, disclose or transmit
+ * this software or the related documents without Intel's prior written
+ * permission.
+ *
+ * This software and the related documents are provided as is, with no express
+ * or implied warranties, other than those that are expressly stated in the
+ * License.
+ *
+ ******************************************************************************/
+
+#pragma once
+
+#include <peci.h>
+
+#include <boost/asio/io_context.hpp>
+#include <sdbusplus/asio/connection.hpp>
+
+#include <iostream>
+
+namespace cpu_info::crashlog
+{
+
+enum class Status
+{
+    success,
+    error,
+    notSupported,
+};
+
+inline void printPECIError(const std::string& action, const uint8_t peciAddr,
+                           const EPECIStatus peciStatus, const size_t cc)
+{
+    std::cerr << action << " failed on 0x" << std::hex
+              << static_cast<int>(peciAddr)
+              << ". Error: " << static_cast<int>(peciStatus) << ": cc: 0x" << cc
+              << "\n";
+}
+
+/**
+ * Initialize the D-Bus interface for requesting Crashlog collection
+ *
+ * @param[in,out]   ioc     ASIO IO context/service
+ * @param[in,out]   conn    D-Bus ASIO connection.
+ */
+void init(boost::asio::io_context& ioc,
+          std::shared_ptr<sdbusplus::asio::connection> conn);
+
+} // namespace cpu_info::crashlog
diff --git a/include/crashlog_manifest.hpp b/include/crashlog_manifest.hpp
new file mode 100644
index 0000000..79386cd
--- /dev/null
+++ b/include/crashlog_manifest.hpp
@@ -0,0 +1,619 @@
+/******************************************************************************
+ *
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright 2021 Intel Corporation.
+ *
+ * This software and the related documents are Intel copyrighted materials,
+ * and your use of them is governed by the express license under which they
+ * were provided to you ("License"). Unless the License provides otherwise,
+ * you may not use, modify, copy, publish, distribute, disclose or transmit
+ * this software or the related documents without Intel's prior written
+ * permission.
+ *
+ * This software and the related documents are provided as is, with no express
+ * or implied warranties, other than those that are expressly stated in the
+ * License.
+ *
+ ******************************************************************************/
+
+#pragma once
+
+#include "crashlog.hpp"
+
+#include <peci.h>
+
+#include <boost/container/flat_map.hpp>
+#include <nlohmann/json.hpp>
+#include <sdbusplus/asio/connection.hpp>
+
+#include <filesystem>
+#include <fstream>
+#include <iostream>
+
+namespace cpu_info::crashlog::manifest
+{
+namespace dbus
+{
+Status getVersionSubTree(
+    std::shared_ptr<sdbusplus::asio::connection> conn,
+    boost::container::flat_map<
+        std::string,
+        boost::container::flat_map<std::string, std::vector<std::string>>>&
+        versionSubTree)
+{
+    sdbusplus::message::message getVersions =
+        conn->new_method_call("xyz.openbmc_project.ObjectMapper",
+                              "/xyz/openbmc_project/object_mapper",
+                              "xyz.openbmc_project.ObjectMapper", "GetSubTree");
+    getVersions.append(
+        "/xyz/openbmc_project/software", static_cast<int32_t>(0),
+        std::array<const char*, 1>{"xyz.openbmc_project.Software.Version"});
+
+    try
+    {
+        sdbusplus::message::message getVersionsResp = conn->call(getVersions);
+        getVersionsResp.read(versionSubTree);
+    }
+    catch (sdbusplus::exception_t&)
+    {
+        std::cerr << "error getting firmware version subtree\n";
+        return Status::error;
+    }
+    return Status::success;
+}
+
+Status getVersion(std::shared_ptr<sdbusplus::asio::connection> conn,
+                  const std::string& service, const std::string& path,
+                  std::string& version)
+{
+    std::variant<std::string> property;
+
+    sdbusplus::message::message getVersion =
+        conn->new_method_call(service.c_str(), path.c_str(),
+                              "org.freedesktop.DBus.Properties", "Get");
+    getVersion.append("xyz.openbmc_project.Software.Version", "Version");
+
+    try
+    {
+        sdbusplus::message::message getVersionsResp = conn->call(getVersion);
+        getVersionsResp.read(property);
+    }
+    catch (sdbusplus::exception_t&)
+    {
+        std::cerr << "error getting firmware version property from  " << path
+                  << "\n";
+        return Status::error;
+    }
+
+    const std::string* propertyPtr = std::get_if<std::string>(&property);
+    if (propertyPtr == nullptr)
+    {
+        std::cerr << "error reading firmware version from " << path << "\n";
+        return Status::error;
+    }
+
+    version = *propertyPtr;
+
+    return Status::success;
+}
+} // namespace dbus
+
+Status getFirmwareVersions(std::shared_ptr<sdbusplus::asio::connection> conn,
+                           std::string& bmc, std::string& bios, std::string& me)
+{
+    boost::container::flat_map<
+        std::string,
+        boost::container::flat_map<std::string, std::vector<std::string>>>
+        versionSubTree;
+
+    Status status = dbus::getVersionSubTree(conn, versionSubTree);
+    if (status != Status::success)
+    {
+        return status;
+    }
+
+    for (const auto& [path, serviceMap] : versionSubTree)
+    {
+        if (path.ends_with("bios_active"))
+        {
+            const auto& [service, interfaces] = *serviceMap.begin();
+            status = dbus::getVersion(conn, service, path, bios);
+            if (status != Status::success)
+            {
+                return status;
+            }
+        }
+        if (path.ends_with("bmc_active"))
+        {
+            const auto& [service, interfaces] = *serviceMap.begin();
+            status = dbus::getVersion(conn, service, path, bmc);
+            if (status != Status::success)
+            {
+                return status;
+            }
+        }
+        if (path.ends_with("me"))
+        {
+            const auto& [service, interfaces] = *serviceMap.begin();
+            status = dbus::getVersion(conn, service, path, me);
+            if (status != Status::success)
+            {
+                return status;
+            }
+        }
+    }
+    return Status::success;
+}
+
+std::string newTimestamp(void)
+{
+    std::ostringstream timeStream;
+    std::time_t time =
+        std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
+    timeStream << std::put_time(std::gmtime(&time), "%FT%TZ");
+    return timeStream.str();
+}
+
+std::string getUuid()
+{
+    std::string ret;
+    sd_id128_t appId = SD_ID128_MAKE(e0, e1, 73, 76, 64, 61, 47, da, a5, 0c, d0,
+                                     cc, 64, 12, 45, 78);
+    sd_id128_t machineId = SD_ID128_NULL;
+
+    if (sd_id128_get_machine_app_specific(appId, &machineId) == 0)
+    {
+        std::array<char, SD_ID128_STRING_MAX> str;
+        ret = sd_id128_to_string(machineId, str.data());
+        ret.insert(8, 1, '-');
+        ret.insert(13, 1, '-');
+        ret.insert(18, 1, '-');
+        ret.insert(23, 1, '-');
+    }
+
+    return ret;
+}
+
+std::string toHexString(const uint64_t num)
+{
+    std::stringstream hexStr;
+    hexStr << std::hex << "0x" << num;
+    return hexStr.str();
+}
+
+Status sprReadCoreMask(const uint8_t peciAddr, uint64_t& coreMask)
+{
+    Status status = Status::success;
+    uint32_t coreMask0 = 0;
+    uint32_t coreMask1 = 0;
+    uint8_t cc = 0;
+
+    // Read RESOLVED_CORES (B(31) D30 F6 offsets 80h and 84h)
+    EPECIStatus peciStatus = peci_RdEndPointConfigPciLocal(
+        peciAddr, 0, 31, 30, 6, 0x80, sizeof(coreMask0), (uint8_t*)&coreMask0,
+        &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read core mask 0", peciAddr, peciStatus, cc);
+        status = Status::error;
+    }
+    peciStatus = peci_RdEndPointConfigPciLocal(peciAddr, 0, 31, 30, 6, 0x84,
+                                               sizeof(coreMask1),
+                                               (uint8_t*)&coreMask1, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read core mask 1", peciAddr, peciStatus, cc);
+        status = Status::error;
+    }
+    coreMask = coreMask1;
+    coreMask <<= 32;
+    coreMask |= coreMask0;
+    return status;
+}
+
+Status sprReadCHACount(const uint8_t peciAddr, size_t& chaCount)
+{
+    Status status = Status::success;
+    uint32_t chaMask0 = 0;
+    uint32_t chaMask1 = 0;
+    uint8_t cc = 0;
+
+    // Read LLC_SLICE_EN (B(31) D30 F3 offsets 9Ch and A0h)
+    EPECIStatus peciStatus = peci_RdEndPointConfigPciLocal(
+        peciAddr, 0, 31, 30, 3, 0x9c, sizeof(chaMask0), (uint8_t*)&chaMask0,
+        &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read CHA mask 0", peciAddr, peciStatus, cc);
+        status = Status::error;
+    }
+    peciStatus = peci_RdEndPointConfigPciLocal(peciAddr, 0, 31, 30, 3, 0xa0,
+                                               sizeof(chaMask1),
+                                               (uint8_t*)&chaMask1, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read CHA mask 1", peciAddr, peciStatus, cc);
+        status = Status::error;
+    }
+
+    chaCount = __builtin_popcount(chaMask0) + __builtin_popcount(chaMask1);
+    return status;
+}
+
+Status sprReadUCodeVersion(const uint8_t peciAddr, uint32_t& uCodeVersion)
+{
+    Status status = Status::success;
+    uint8_t cc = 0;
+
+    // Read PCS Index 0 Parameter 4
+    EPECIStatus peciStatus = peci_RdPkgConfig(
+        peciAddr, 0, 4, sizeof(uCodeVersion), (uint8_t*)&uCodeVersion, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read uCode Version", peciAddr, peciStatus, cc);
+        status = Status::error;
+    }
+    return status;
+}
+
+Status sprReadMCAErrSrcLog(const uint8_t peciAddr, uint32_t& mcaErrSrcLog)
+{
+    Status status = Status::success;
+    uint8_t cc = 0;
+
+    // Read PCS Index 0 Parameter 5
+    EPECIStatus peciStatus = peci_RdPkgConfig(
+        peciAddr, 0, 5, sizeof(mcaErrSrcLog), (uint8_t*)&mcaErrSrcLog, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read MCA_ERR_SRC_LOG", peciAddr, peciStatus, cc);
+        status = Status::error;
+    }
+    return status;
+}
+
+Status sprReadPPIN(const uint8_t peciAddr, uint64_t& ppin)
+{
+    Status status = Status::success;
+    uint32_t ppin0 = 0;
+    uint32_t ppin1 = 0;
+    uint8_t cc = 0;
+
+    // Read PCS Index 19 Parameters 1 and 2
+    EPECIStatus peciStatus =
+        peci_RdPkgConfig(peciAddr, 19, 1, sizeof(ppin0), (uint8_t*)&ppin0, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read PPIN 0", peciAddr, peciStatus, cc);
+        status = Status::error;
+    }
+    peciStatus =
+        peci_RdPkgConfig(peciAddr, 19, 2, sizeof(ppin1), (uint8_t*)&ppin1, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read PPIN 1", peciAddr, peciStatus, cc);
+        status = Status::error;
+    }
+    ppin = ppin1;
+    ppin <<= 32;
+    ppin |= ppin0;
+    return status;
+}
+
+Status sprReadIERRLoggingReg(const uint8_t peciAddr, uint32_t& ierrLoggingReg)
+{
+    Status status = Status::success;
+    uint8_t cc = 0;
+
+    // Read IERRLOGGINGREG (B(30) D0 F0 offset A4h)
+    EPECIStatus peciStatus = peci_RdEndPointConfigPciLocal(
+        peciAddr, 0, 30, 0, 0, 0xa4, sizeof(ierrLoggingReg),
+        (uint8_t*)&ierrLoggingReg, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read IERRLOGGINGREG", peciAddr, peciStatus, cc);
+        status = Status::error;
+    }
+    return status;
+}
+
+Status sprReadMCERRLoggingReg(const uint8_t peciAddr, uint32_t& mcerrLoggingReg)
+{
+    Status status = Status::success;
+    uint8_t cc = 0;
+
+    // Read MCERRLOGGINGREG (B(30) D0 F0 offset A8h)
+    EPECIStatus peciStatus = peci_RdEndPointConfigPciLocal(
+        peciAddr, 0, 30, 0, 0, 0xa8, sizeof(mcerrLoggingReg),
+        (uint8_t*)&mcerrLoggingReg, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read MCERRLOGGINGREG", peciAddr, peciStatus, cc);
+        status = Status::error;
+    }
+    return status;
+}
+
+Status sprReadFirstIERRTSC(const uint8_t peciAddr, uint64_t& firstIERRTSC)
+{
+    Status status = Status::success;
+    uint32_t firstIERRTSC0 = 0;
+    uint32_t firstIERRTSC1 = 0;
+    uint8_t cc = 0;
+
+    // Read PCU_FIRST_IERR_TSC (B(31) D30 F4 offsets F0h and F4h)
+    EPECIStatus peciStatus = peci_RdEndPointConfigPciLocal(
+        peciAddr, 0, 31, 30, 4, 0xf0, sizeof(firstIERRTSC0),
+        (uint8_t*)&firstIERRTSC0, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read PCU_FIRST_IERR_TSC_LO_CFG", peciAddr, peciStatus,
+                       cc);
+        status = Status::error;
+    }
+    peciStatus = peci_RdEndPointConfigPciLocal(peciAddr, 0, 31, 30, 4, 0xf4,
+                                               sizeof(firstIERRTSC1),
+                                               (uint8_t*)&firstIERRTSC1, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read PCU_FIRST_IERR_TSC_HI_CFG", peciAddr, peciStatus,
+                       cc);
+        status = Status::error;
+    }
+    firstIERRTSC = firstIERRTSC1;
+    firstIERRTSC <<= 32;
+    firstIERRTSC |= firstIERRTSC0;
+    return status;
+}
+
+Status sprReadFirstMCERRTSC(const uint8_t peciAddr, uint64_t& firstMCERRTSC)
+{
+    Status status = Status::success;
+    uint32_t firstMCERRTSC0 = 0;
+    uint32_t firstMCERRTSC1 = 0;
+    uint8_t cc = 0;
+
+    // Read PCU_FIRST_MCERR_TSC (B(31) D30 F4 offsets F8h and FCh)
+    EPECIStatus peciStatus = peci_RdEndPointConfigPciLocal(
+        peciAddr, 0, 31, 30, 4, 0xf8, sizeof(firstMCERRTSC0),
+        (uint8_t*)&firstMCERRTSC0, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read PCU_FIRST_MCERR_TSC_LO_CFG", peciAddr, peciStatus,
+                       cc);
+        status = Status::error;
+    }
+    peciStatus = peci_RdEndPointConfigPciLocal(peciAddr, 0, 31, 30, 4, 0xfc,
+                                               sizeof(firstMCERRTSC1),
+                                               (uint8_t*)&firstMCERRTSC1, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Read PCU_FIRST_MCERR_TSC_HI_CFG", peciAddr, peciStatus,
+                       cc);
+        status = Status::error;
+    }
+    firstMCERRTSC = firstMCERRTSC1;
+    firstMCERRTSC <<= 32;
+    firstMCERRTSC |= firstMCERRTSC0;
+    return status;
+}
+
+Status getCoreMask(const uint8_t peciAddr, const CPUModel cpuModel,
+                   uint64_t& coreMask)
+{
+    switch (cpuModel)
+    {
+        case spr:
+            return sprReadCoreMask(peciAddr, coreMask);
+            break;
+        default:
+            std::cerr << "Failed to get core mask. Unsupported CPU Model: "
+                      << static_cast<int>(cpuModel) << "\n";
+            return Status::error;
+    }
+}
+
+Status getCHACount(const uint8_t peciAddr, const CPUModel cpuModel,
+                   size_t& chaCount)
+{
+    switch (cpuModel)
+    {
+        case spr:
+            return sprReadCHACount(peciAddr, chaCount);
+            break;
+        default:
+            std::cerr << "Failed to get CHA count. Unsupported CPU Model: "
+                      << static_cast<int>(cpuModel) << "\n";
+            return Status::error;
+    }
+}
+
+Status getUCodeVersion(const uint8_t peciAddr, const CPUModel cpuModel,
+                       uint32_t& uCodeVersion)
+{
+    switch (cpuModel)
+    {
+        case rpl:
+        case adl:
+        case spr:
+            return sprReadUCodeVersion(peciAddr, uCodeVersion);
+            break;
+        default:
+            std::cerr << "Failed to get uCode Version. Unsupported CPU Model: "
+                      << static_cast<int>(cpuModel) << "\n";
+            return Status::error;
+    }
+}
+
+Status getPPIN(const uint8_t peciAddr, const CPUModel cpuModel, uint64_t& ppin)
+{
+    switch (cpuModel)
+    {
+        case spr:
+            return sprReadPPIN(peciAddr, ppin);
+            break;
+        default:
+            std::cerr << "Failed to get PPIN. Unsupported CPU Model: "
+                      << static_cast<int>(cpuModel) << "\n";
+            return Status::error;
+    }
+}
+
+Status getMCAErrSrcLog(const uint8_t peciAddr, const CPUModel cpuModel,
+                       uint32_t& mcaErrSrcLog)
+{
+    switch (cpuModel)
+    {
+        case spr:
+            return sprReadMCAErrSrcLog(peciAddr, mcaErrSrcLog);
+            break;
+        default:
+            std::cerr
+                << "Failed to get MCA_ERR_SRC_LOG. Unsupported CPU Model: "
+                << static_cast<int>(cpuModel) << "\n";
+            return Status::error;
+    }
+}
+
+Status getIERRLoggingReg(const uint8_t peciAddr, const CPUModel cpuModel,
+                         uint32_t& ierrLoggingReg)
+{
+    switch (cpuModel)
+    {
+        case spr:
+            return sprReadIERRLoggingReg(peciAddr, ierrLoggingReg);
+            break;
+        default:
+            std::cerr << "Failed to get IERRLOGGINGREG. Unsupported CPU Model: "
+                      << static_cast<int>(cpuModel) << "\n";
+            return Status::error;
+    }
+}
+
+Status getMCERRLoggingReg(const uint8_t peciAddr, const CPUModel cpuModel,
+                          uint32_t& mcerrLoggingReg)
+{
+    switch (cpuModel)
+    {
+        case spr:
+            return sprReadMCERRLoggingReg(peciAddr, mcerrLoggingReg);
+            break;
+        default:
+            std::cerr
+                << "Failed to get MCERRLOGGINGREG. Unsupported CPU Model: "
+                << static_cast<int>(cpuModel) << "\n";
+            return Status::error;
+    }
+}
+
+Status getFirstIERRTSC(const uint8_t peciAddr, const CPUModel cpuModel,
+                       uint64_t& firstIERRTSC)
+{
+    switch (cpuModel)
+    {
+        case spr:
+            return sprReadFirstIERRTSC(peciAddr, firstIERRTSC);
+            break;
+        default:
+            std::cerr
+                << "Failed to get PCU_FIRST_IERR_TSC. Unsupported CPU Model: "
+                << static_cast<int>(cpuModel) << "\n";
+            return Status::error;
+    }
+}
+
+Status getFirstMCERRTSC(const uint8_t peciAddr, const CPUModel cpuModel,
+                        uint64_t& firstMCERRTSC)
+{
+    switch (cpuModel)
+    {
+        case spr:
+            return sprReadFirstMCERRTSC(peciAddr, firstMCERRTSC);
+            break;
+        default:
+            std::cerr
+                << "Failed to get PCU_FIRST_MCERR_TSC. Unsupported CPU Model: "
+                << static_cast<int>(cpuModel) << "\n";
+            return Status::error;
+    }
+}
+
+Status manifestSysInfo(std::shared_ptr<sdbusplus::asio::connection> conn,
+                       const uint8_t peciAddr, nlohmann::json& manifest)
+{
+    std::string bmcVersion;
+    std::string biosVersion;
+    std::string meVersion;
+    Status status =
+        getFirmwareVersions(conn, bmcVersion, biosVersion, meVersion);
+    if (status != Status::success)
+    {
+        std::cerr << "Error getting firmware versions: "
+                  << static_cast<int>(status) << "\n";
+    }
+
+    manifest["crash_data"]["METADATA"] = {
+        {"timestamp", newTimestamp()}, {"bmc_fw_ver", bmcVersion},
+        {"bios_id", biosVersion},      {"me_fw_ver", meVersion},
+        {"platform_name", getUuid()},
+    };
+
+    return status;
+}
+
+Status manifestCPUInfo(const uint8_t peciAddr, const CPUModel cpuModel,
+                       const uint8_t stepping, nlohmann::json& manifest)
+{
+    uint32_t uCodeVersion;
+    getUCodeVersion(peciAddr, cpuModel, uCodeVersion);
+
+    // Use the lower nibble of peciAddr for the CPU number
+    std::string cpuName = "cpu" + std::to_string(peciAddr & 0xF);
+
+    switch (cpuModel)
+    {
+	case rpl:
+	case adl:
+            manifest["crash_data"]["METADATA"][cpuName] = {
+                {"peci_id", toHexString(peciAddr)},
+                {"cpuid", toHexString(cpuModel | stepping)},
+                {"ucode_patch_ver", toHexString(uCodeVersion)},
+            };
+            break;
+
+        default:
+            std::cerr
+                << "Failed to get CPU info. Unsupported CPU Model: 0x"
+                << std::hex << std::uppercase << static_cast<int>(cpuModel) << "\n";
+            return Status::error;
+    }
+    return Status::success;
+}
+
+Status manifestFileInfo(const uint8_t socket, const uint32_t uniqueID,
+                        const std::string& filename, nlohmann::json& manifest)
+{
+    std::string cpuName = "cpu" + std::to_string(socket);
+    std::string agentName = "agent_id_" + toHexString(uniqueID);
+
+    manifest["crash_data"]["PROCESSORS"][cpuName]["crashlog"][agentName]["#ptr"]
+        .push_back(filename);
+
+    return Status::success;
+}
+
+Status writeManifest(const std::filesystem::path& dir,
+                     const std::string& filename, nlohmann::json& manifest)
+{
+    std::filesystem::path manifestFile = dir / filename;
+    std::ofstream file(manifestFile);
+    if (!file.is_open())
+    {
+        return Status::error;
+    }
+
+    file << manifest.dump(4);
+    return Status::success;
+}
+} // namespace cpu_info::crashlog::manifest
diff --git a/src/cpuinfo_main.cpp b/src/cpuinfo_main.cpp
index b800e99..b52e65c 100644
--- a/src/cpuinfo_main.cpp
+++ b/src/cpuinfo_main.cpp
@@ -16,6 +16,7 @@
 
 #include "cpuinfo.hpp"
 #include "cpuinfo_utils.hpp"
+#include "crashlog.hpp"
 #include "speed_select.hpp"
 
 #include <errno.h>
@@ -659,6 +660,7 @@ int main(int argc, char* argv[])
     cpu_info::hostStateSetup(conn);
 
     cpu_info::sst::init();
+    cpu_info::crashlog::init(io, conn);
 
     // shared_ptr conn is global for the service
     // const reference of conn is passed to async calls
diff --git a/src/crashlog.cpp b/src/crashlog.cpp
new file mode 100644
index 0000000..1269341
--- /dev/null
+++ b/src/crashlog.cpp
@@ -0,0 +1,683 @@
+/******************************************************************************
+ *
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright 2021 Intel Corporation.
+ *
+ * This software and the related documents are Intel copyrighted materials,
+ * and your use of them is governed by the express license under which they
+ * were provided to you ("License"). Unless the License provides otherwise,
+ * you may not use, modify, copy, publish, distribute, disclose or transmit
+ * this software or the related documents without Intel's prior written
+ * permission.
+ *
+ * This software and the related documents are provided as is, with no express
+ * or implied warranties, other than those that are expressly stated in the
+ * License.
+ *
+ ******************************************************************************/
+
+#include "crashlog.hpp"
+
+#include "cpuinfo.hpp"
+#include "crashlog_manifest.hpp"
+
+#include <peci.h>
+
+#include <boost/process/child.hpp>
+#include <nlohmann/json.hpp>
+
+#include <filesystem>
+#include <fstream>
+#include <iostream>
+#include <string>
+
+namespace cpu_info::crashlog
+{
+static constexpr bool debug = true;
+static constexpr bool debug2 = false;
+static bool inProgress;
+static std::shared_ptr<sdbusplus::asio::object_server> server;
+static std::shared_ptr<sdbusplus::asio::dbus_interface> dumpIface;
+static std::shared_ptr<sdbusplus::asio::dbus_interface> crashlogEntryIface;
+static std::shared_ptr<sdbusplus::asio::dbus_interface> crashlogEpochIface;
+static const std::filesystem::path crashlogDir = "/tmp/crashlog";
+static const std::string crashlogFilePrefix = "crashlog";
+
+bool isPECIAvailable(const uint8_t peciAddr)
+{
+    return (peci_Ping(peciAddr) == PECI_CC_SUCCESS);
+}
+
+bool isPECIAvailable()
+{
+    for (uint8_t peciAddr = MIN_CLIENT_ADDR; peciAddr <= MAX_CLIENT_ADDR;
+         peciAddr++)
+    {
+        if (isPECIAvailable(peciAddr))
+        {
+            return true;
+        }
+    }
+    return false;
+}
+
+/** Exception for when a log is attempted while power is off. */
+struct PowerOffException final : public sdbusplus::exception_t
+{
+    const char* name() const noexcept override
+    {
+        return "org.freedesktop.DBus.Error.NotSupported";
+    };
+    const char* description() const noexcept override
+    {
+        return "Power off, cannot access peci";
+    };
+    const char* what() const noexcept override
+    {
+        return "org.freedesktop.DBus.Error.NotSupported: "
+               "Power off, cannot access peci";
+    };
+    int get_errno() const noexcept override
+    {
+        return EOPNOTSUPP;
+    }
+};
+/** Exception for when a log is attempted while another is in progress. */
+struct LogInProgressException final : public sdbusplus::exception_t
+{
+    const char* name() const noexcept override
+    {
+        return "org.freedesktop.DBus.Error.ObjectPathInUse";
+    };
+    const char* description() const noexcept override
+    {
+        return "Log in progress";
+    };
+    const char* what() const noexcept override
+    {
+        return "org.freedesktop.DBus.Error.ObjectPathInUse: "
+               "Log in progress";
+    };
+    int get_errno() const noexcept override
+    {
+        return EBUSY;
+    }
+};
+
+static Status getTelemetrySupported(const uint8_t peciAddr,
+                                    uint8_t& isSupported)
+{
+    // Telemetry Discovery SubOpcode 0
+    uint8_t cc = 0;
+    EPECIStatus peciStatus = peci_Telemetry_Discovery(
+        peciAddr, 0, 0, 0, 0, 1, reinterpret_cast<uint8_t*>(&isSupported), &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Telemetry Discovery: Supported", peciAddr, peciStatus,
+                       cc);
+        return Status::error;
+    }
+    return Status::success;
+}
+
+static Status getNumCrashlogAgents(const uint8_t peciAddr,
+                                   uint16_t& numCrashlogAgents)
+{
+    // Telemetry Discovery SubOpcode 1 Param0 4
+    uint8_t cc = 0;
+    EPECIStatus peciStatus = peci_Telemetry_Discovery(
+        peciAddr, 1, 4, 0, 0, 2, reinterpret_cast<uint8_t*>(&numCrashlogAgents),
+        &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Telemetry Discovery: Num Crashlog Agents", peciAddr,
+                       peciStatus, cc);
+        return Status::error;
+    }
+    return Status::success;
+}
+
+static Status getCrashlogAgentDetails(const uint8_t peciAddr,
+                                      const uint16_t agentNum,
+                                      uint64_t& crashlogAgentDetails)
+{
+    // Telemetry Discovery SubOpcode 2 Param0 4 Param1 AgentNum
+    uint8_t cc = 0;
+    EPECIStatus peciStatus = peci_Telemetry_Discovery(
+        peciAddr, 2, 4, agentNum, 0, 8,
+        reinterpret_cast<uint8_t*>(&crashlogAgentDetails), &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        std::string msg("Telemetry Discovery: Crashlog Agent " +
+                        std::to_string(agentNum) + " Details");
+        printPECIError(msg, peciAddr, peciStatus, cc);
+        return Status::error;
+    }
+    return Status::success;
+}
+
+static Status getCrashlogSample(const uint8_t peciAddr, const uint16_t agentNum,
+                                const uint16_t sampleNum,
+                                uint64_t& crashlogSample)
+{
+    // Telemetry GetCrashlogSample
+    uint8_t cc = 0;
+    EPECIStatus peciStatus = peci_Telemetry_GetCrashlogSample(
+        peciAddr, agentNum, sampleNum, 8,
+        reinterpret_cast<uint8_t*>(&crashlogSample), &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        std::string msg("Telemetry: Crashlog Agent " +
+                        std::to_string(agentNum) + " GetCrashlogSample " +
+                        std::to_string(sampleNum));
+        printPECIError(msg, peciAddr, peciStatus, cc);
+        return Status::error;
+    }
+    return Status::success;
+}
+
+static Status getAgentCrashlog(const uint8_t peciAddr, const uint16_t agentNum,
+                               const uint16_t crashSpace,
+                               std::vector<uint64_t>& crashlog)
+{
+    // crashSpace is the size in DWORDs and each GetCrashlogSample returns 2
+    // DWORDs, so we only need half that number of samples
+    size_t crashSamples = crashSpace / 2;
+    for (size_t i = 0; i < crashSamples; i++)
+    {
+        uint64_t crashlogSample = 0;
+        if (getCrashlogSample(peciAddr, agentNum, i, crashlogSample) !=
+            Status::success)
+        {
+            return Status::error;
+        }
+        if constexpr (debug2)
+        {
+            std::cerr << std::hex << "CPU 0x" << static_cast<int>(peciAddr)
+                      << " agent: 0x" << static_cast<int>(agentNum)
+                      << " sample: 0x" << static_cast<int>(i) << " data: 0x"
+                      << crashlogSample << "\n";
+        }
+        crashlog.push_back(crashlogSample);
+    }
+    return Status::success;
+}
+
+static Status getNumTelemetryAggregators(const uint8_t peciAddr,
+                                         uint16_t& numTelemetryAggregators)
+{
+    // Telemetry Discovery SubOpcode 1 Param0 1
+    uint8_t cc = 0;
+    EPECIStatus peciStatus = peci_Telemetry_Discovery(
+        peciAddr, 1, 1, 0, 0, 2,
+        reinterpret_cast<uint8_t*>(&numTelemetryAggregators), &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Telemetry Discovery: Num Telemetry Aggregators",
+                       peciAddr, peciStatus, cc);
+        return Status::error;
+    }
+    return Status::success;
+}
+
+static Status
+    getTelemetryAggregatorDetails(const uint8_t peciAddr,
+                                  const uint16_t aggregatorNum,
+                                  uint64_t& telemetryAggregatorDetails)
+{
+    // Telemetry Discovery SubOpcode 2 Param0 1 Param1 AggregatorNum
+    uint8_t cc = 0;
+    EPECIStatus peciStatus = peci_Telemetry_Discovery(
+        peciAddr, 2, 1, aggregatorNum, 0, 8,
+        reinterpret_cast<uint8_t*>(&telemetryAggregatorDetails), &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        std::string msg("Telemetry Discovery: Telemetry Aggregator " +
+                        std::to_string(aggregatorNum) + " Details");
+        printPECIError(msg, peciAddr, peciStatus, cc);
+        return Status::error;
+    }
+    return Status::success;
+}
+
+static Status getTelemSample(const uint8_t peciAddr,
+                             const uint16_t aggregatorNum,
+                             const uint16_t sampleNum, uint64_t& telemSample)
+{
+    // Telemetry GetTelemSample
+    uint8_t cc = 0;
+    EPECIStatus peciStatus = peci_Telemetry_GetTelemSample(
+        peciAddr, aggregatorNum, sampleNum, 8,
+        reinterpret_cast<uint8_t*>(&telemSample), &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        std::string msg("Telemetry: Telemetry Aggregator " +
+                        std::to_string(aggregatorNum) + " GetTelemSample " +
+                        std::to_string(sampleNum));
+        printPECIError(msg, peciAddr, peciStatus, cc);
+        return Status::error;
+    }
+    return Status::success;
+}
+
+static Status getAggregatorTelemetry(const uint8_t peciAddr,
+                                     const uint16_t aggregatorNum,
+                                     const uint16_t telemSpace,
+                                     std::vector<uint64_t>& telemetry)
+{
+    // telemSpace is the size in DWORDs and each GetTelemSample returns 2
+    // DWORDs, so we only need half that number of samples
+    size_t telemSamples = telemSpace / 2;
+    for (size_t i = 0; i < telemSamples; i++)
+    {
+        uint64_t telemSample = 0;
+        if (getTelemSample(peciAddr, aggregatorNum, i, telemSample) !=
+            Status::success)
+        {
+            return Status::error;
+        }
+        if constexpr (debug2)
+        {
+            std::cerr << std::hex << "CPU 0x" << static_cast<int>(peciAddr)
+                      << " agent: 0x" << static_cast<int>(aggregatorNum)
+                      << " sample: 0x" << static_cast<int>(i) << " data: 0x"
+                      << telemSample << "\n";
+        }
+        telemetry.push_back(telemSample);
+    }
+    return Status::success;
+}
+
+static Status zipCrashlogFiles(const std::string& crashlogZipName,
+                               size_t& crashlogZipSize)
+{
+    std::filesystem::path zipFile = crashlogDir / crashlogZipName;
+    zipFile.replace_extension(".zip");
+    boost::process::child zip("/usr/bin/zip", "-rmjq", zipFile.string(),
+                              crashlogDir.string());
+    zip.wait();
+    if (zip.exit_code())
+    {
+        std::cerr << "Error while zipping crashlog files: " << zip.exit_code()
+                  << "\n";
+        return Status::error;
+    }
+    std::error_code ec;
+    crashlogZipSize = file_size(zipFile, ec);
+    return Status::success;
+}
+
+static std::string getFilename(const std::string& prefix, const uint8_t socket,
+                               const uint32_t uniqueID)
+{
+    uint64_t timestamp =
+        std::chrono::duration_cast<std::chrono::microseconds>(
+            std::chrono::system_clock::now().time_since_epoch())
+            .count();
+    std::stringstream uniqueIDStr;
+    uniqueIDStr << std::setfill('0') << std::setw(sizeof(uniqueID) * 2)
+                << std::hex << uniqueID;
+    return std::string(prefix + "_socket" + std::to_string(socket) +
+                       "_agent0x" + uniqueIDStr.str() + "_" +
+                       std::to_string(timestamp) + ".bin");
+}
+
+static Status saveFile(const std::string& filename, std::vector<uint64_t>& data)
+{
+    std::error_code ec;
+    std::filesystem::create_directories(crashlogDir, ec);
+
+    std::filesystem::path filePath = crashlogDir / filename;
+    std::ofstream file(filePath, std::ios::binary);
+
+    if (!file.is_open())
+    {
+        std::cerr << "Failed to open " << filename << "\n";
+        return Status::error;
+    }
+
+    file.write(reinterpret_cast<char*>(&data[0]),
+               data.size() * sizeof(data[0]));
+
+    return Status::success;
+}
+
+static Status saveCrashlogFile(const uint8_t socket, const uint32_t uniqueID,
+                               std::vector<uint64_t>& crashlog,
+                               nlohmann::json& manifest)
+{
+    std::string crashlogFilename =
+        getFilename(crashlogFilePrefix, socket, uniqueID);
+
+    Status status = saveFile(crashlogFilename, crashlog);
+    if (status != Status::success)
+    {
+        return status;
+    }
+
+    manifest::manifestFileInfo(socket, uniqueID, crashlogFilename, manifest);
+
+    return Status::success;
+}
+
+static Status saveTelemetryFile(const uint8_t socket, const uint32_t uniqueID,
+                                std::vector<uint64_t>& telemetry,
+                                nlohmann::json& manifest)
+{
+    std::string telemetryFilename = getFilename("telemetry", socket, uniqueID);
+
+    Status status = saveFile(telemetryFilename, telemetry);
+    if (status != Status::success)
+    {
+        return status;
+    }
+
+    manifest::manifestFileInfo(socket, uniqueID, telemetryFilename, manifest);
+
+    return Status::success;
+}
+
+static Status removeCrashlogFiles()
+{
+    std::error_code ec;
+    if (!std::filesystem::exists(crashlogDir))
+    {
+        // No files to remove
+        return Status::success;
+    }
+
+    Status status = Status::success;
+    for (auto& file : std::filesystem::directory_iterator(crashlogDir))
+    {
+        // always iterate through all files in the directory to clear
+        // crashlog files. This is just a safeguard in the event more
+        // than a single file is created.
+        std::filesystem::path filepath = file.path();
+        std::cerr << "Filename to remove " << filepath << "\n";
+        if (filepath.filename().string().starts_with(crashlogFilePrefix))
+        {
+            if (!(std::filesystem::remove(filepath, ec)))
+            {
+                std::cerr << "failed to remove " << filepath << ": "
+                          << ec.message() << "\n";
+                status = Status::error;
+            }
+        }
+    }
+    return status;
+}
+
+static Status dbusAddCrashlog()
+{
+    uint64_t timestamp =
+        std::chrono::duration_cast<std::chrono::microseconds>(
+            std::chrono::system_clock::now().time_since_epoch())
+            .count();
+    std::string crashlogZipName(crashlogFilePrefix + "_" +
+                                std::to_string(timestamp));
+    size_t crashlogZipSize;
+
+    if (zipCrashlogFiles(crashlogZipName, crashlogZipSize) != Status::success)
+    {
+        return Status::error;
+    }
+
+    std::string ifaceName("/xyz/openbmc_project/dump/crashlog/entry/" +
+                          crashlogZipName);
+
+    crashlogEntryIface = server->add_interface(
+        ifaceName.c_str(), "xyz.openbmc_project.Dump.Entry");
+    crashlogEntryIface->register_property("Size", uint64_t(crashlogZipSize));
+    crashlogEntryIface->initialize();
+
+    crashlogEpochIface = server->add_interface(
+        ifaceName.c_str(), "xyz.openbmc_project.Time.EpochTime");
+    crashlogEpochIface->register_property("Elapsed", timestamp);
+    crashlogEpochIface->initialize();
+    return Status::success;
+}
+
+static void dbusRemoveCrashlog()
+{
+    removeCrashlogFiles();
+
+    if (crashlogEntryIface)
+    {
+        server->remove_interface(crashlogEntryIface);
+        crashlogEntryIface.reset();
+    }
+
+    if (crashlogEpochIface)
+    {
+        server->remove_interface(crashlogEpochIface);
+        crashlogEpochIface.reset();
+    }
+}
+
+static Status getCrashlogData(const uint8_t peciAddr, nlohmann::json& manifest)
+{
+    uint16_t numCrashlogAgents = 0;
+    if (getNumCrashlogAgents(peciAddr, numCrashlogAgents) != Status::success)
+    {
+        return Status::error;
+    }
+    if constexpr (debug)
+    {
+        std::cerr << "Num Crashlog Agents: "
+                  << static_cast<int>(numCrashlogAgents) << "\n";
+    }
+
+    for (size_t agent = 0; agent < numCrashlogAgents; agent++)
+    {
+        uint64_t crashlogAgentDetails = 0;
+        if (getCrashlogAgentDetails(peciAddr, agent, crashlogAgentDetails) !=
+            Status::success)
+        {
+            return Status::error;
+        }
+        uint8_t entryType = crashlogAgentDetails >> 0;
+        uint8_t crashType = crashlogAgentDetails >> 8;
+        uint32_t uniqueID = crashlogAgentDetails >> 16;
+        uint16_t crashSpace = crashlogAgentDetails >> 48;
+        if constexpr (debug)
+        {
+            std::cerr << "CPU 0x" << std::hex << static_cast<int>(peciAddr)
+                      << " Crashlog Agent 0x" << static_cast<int>(agent)
+                      << " Details:\n";
+            std::cerr << "   EntryType: 0x" << std::hex
+                      << static_cast<int>(entryType) << "\n";
+            std::cerr << "   CrashType: 0x" << std::hex
+                      << static_cast<int>(crashType) << "\n";
+            std::cerr << "   UniqueID: 0x" << std::hex
+                      << static_cast<int>(uniqueID) << "\n";
+            std::cerr << "   CrashSpace: 0x" << std::hex
+                      << static_cast<int>(crashSpace) << "\n";
+        }
+
+        std::vector<uint64_t> crashlog;
+        if (getAgentCrashlog(peciAddr, agent, crashSpace, crashlog) !=
+            Status::success)
+        {
+            return Status::error;
+        }
+
+        // Use the lower nibble of the PECI address as the socket number
+        uint8_t socket = peciAddr & 0xF;
+        if (saveCrashlogFile(socket, uniqueID, crashlog, manifest) !=
+            Status::success)
+        {
+            return Status::error;
+        }
+    }
+    return Status::success;
+}
+
+static Status getTelemetryData(const uint8_t peciAddr, nlohmann::json& manifest)
+{
+    uint16_t numTelemetryAggregators = 0;
+    if (getNumTelemetryAggregators(peciAddr, numTelemetryAggregators) !=
+        Status::success)
+    {
+        return Status::error;
+    }
+    if constexpr (debug)
+    {
+        std::cerr << "Num Telemetry Aggregators: "
+                  << static_cast<int>(numTelemetryAggregators) << "\n";
+    }
+
+    for (size_t aggregator = 0; aggregator < numTelemetryAggregators;
+         aggregator++)
+    {
+        uint64_t telemetryAggregatorDetails = 0;
+        if (getTelemetryAggregatorDetails(peciAddr, aggregator,
+                                          telemetryAggregatorDetails) !=
+            Status::success)
+        {
+            return Status::error;
+        }
+        uint8_t entryType = telemetryAggregatorDetails >> 0;
+        uint8_t telemType = telemetryAggregatorDetails >> 8;
+        uint32_t uniqueID = telemetryAggregatorDetails >> 16;
+        uint16_t telemSpace = telemetryAggregatorDetails >> 48;
+        if constexpr (debug)
+        {
+            std::cerr << "CPU 0x" << std::hex << static_cast<int>(peciAddr)
+                      << " Telemetry Aggregator 0x"
+                      << static_cast<int>(aggregator) << " Details:\n";
+            std::cerr << "   EntryType: 0x" << std::hex
+                      << static_cast<int>(entryType) << "\n";
+            std::cerr << "   TelemType: 0x" << std::hex
+                      << static_cast<int>(telemType) << "\n";
+            std::cerr << "   UniqueID: 0x" << std::hex
+                      << static_cast<int>(uniqueID) << "\n";
+            std::cerr << "   TelemSpace: 0x" << std::hex
+                      << static_cast<int>(telemSpace) << "\n";
+        }
+
+        std::vector<uint64_t> telemetry;
+        if (getAggregatorTelemetry(peciAddr, aggregator, telemSpace,
+                                   telemetry) != Status::success)
+        {
+            return Status::error;
+        }
+
+        // Use the lower nibble of the PECI address as the socket number
+        uint8_t socket = peciAddr & 0xF;
+        if (saveTelemetryFile(socket, uniqueID, telemetry, manifest) !=
+            Status::success)
+        {
+            return Status::error;
+        }
+    }
+    return Status::success;
+}
+
+static Status collectCrashlog(const uint8_t peciAddr, nlohmann::json& manifest)
+{
+    uint8_t cc = 0;
+    CPUModel cpuModel{};
+    uint8_t stepping = 0;
+    Status retStatus = Status::success;
+    EPECIStatus peciStatus = peci_GetCPUID(peciAddr, &cpuModel, &stepping, &cc);
+    if (peciStatus != PECI_CC_SUCCESS)
+    {
+        printPECIError("Get CPUID", peciAddr, peciStatus, cc);
+        return Status::error;
+    }
+    manifest::manifestCPUInfo(peciAddr, cpuModel, stepping, manifest);
+
+    uint8_t isSupported = 0;
+    if (getTelemetrySupported(peciAddr, isSupported) != Status::success)
+    {
+        return Status::error;
+    }
+    if constexpr (debug)
+    {
+        std::cerr << "Telemetry Supported: " << static_cast<int>(isSupported)
+                  << "\n";
+    }
+    if (!isSupported)
+    {
+        return Status::notSupported;
+    }
+
+    Status status = getCrashlogData(peciAddr, manifest);
+    if (status != Status::success)
+    {
+        retStatus = status;
+    }
+    status = getTelemetryData(peciAddr, manifest);
+    if (status != Status::success)
+    {
+        retStatus = status;
+    }
+
+    return retStatus;
+}
+
+void init(boost::asio::io_context& ioc,
+          std::shared_ptr<sdbusplus::asio::connection> conn)
+{
+    // Crashlog Service
+    conn->request_name("com.intel.crashlog");
+    server = std::make_shared<sdbusplus::asio::object_server>(conn);
+    server->add_manager("/xyz/openbmc_project/dump/crashlog");
+
+    // Crashlog Interface
+    dumpIface = server->add_interface("/xyz/openbmc_project/dump/crashlog",
+                                      "xyz.openbmc_project.Dump.Create");
+
+    // Create a Crashlog
+    dumpIface->register_method("CreateDump", [&ioc, conn]() {
+        if (!isPECIAvailable())
+        {
+            throw PowerOffException();
+        }
+        if (inProgress)
+        {
+            throw LogInProgressException();
+        }
+        inProgress = true;
+        boost::asio::post(ioc, [conn]() {
+            dbusRemoveCrashlog();
+            nlohmann::json manifest;
+            bool sysInfoDone = false;
+
+            for (uint8_t peciAddr = MIN_CLIENT_ADDR;
+                 peciAddr <= MAX_CLIENT_ADDR; peciAddr++)
+            {
+                if (!isPECIAvailable(peciAddr))
+                {
+                    continue;
+                }
+                if (!sysInfoDone)
+                {
+                    manifest::manifestSysInfo(conn, peciAddr, manifest);
+                    sysInfoDone = true;
+                }
+
+                Status status = collectCrashlog(peciAddr, manifest);
+                if (status != Status::success)
+                {
+                    std::cerr << "Failed to collect crashlog on address 0x"
+                              << std::hex << static_cast<int>(peciAddr) << ": "
+                              << static_cast<int>(status) << "\n";
+                }
+            }
+            manifest::writeManifest(crashlogDir, "manifest.json", manifest);
+            Status status = dbusAddCrashlog();
+            if (status != Status::success)
+            {
+                std::cerr << "Failed to add crashlog to D-Bus: "
+                          << static_cast<int>(status) << "\n";
+            }
+            inProgress = false;
+        });
+        return std::string("Crashlog collection started");
+    });
+    dumpIface->initialize();
+}
+
+} // namespace cpu_info::crashlog
-- 
2.17.1

