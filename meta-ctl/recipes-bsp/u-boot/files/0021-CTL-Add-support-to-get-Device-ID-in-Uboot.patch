From d6c6d946386aace9b698b4de2f4e80abee9fc793 Mon Sep 17 00:00:00 2001
From: Vinay Kumar Pabboju <vinayx.kumar.pabboju@intel.com>
Date: Tue, 13 Dec 2022 06:40:19 +0000
Subject: [PATCH] CTL: Add support to get Device ID in Uboot

Reading board id from GPIO and computing device ID
based on the board ID.

Tested:
Confirmed that GetDeviceID via KCS returning valid Platform ID
when BMC is in Uboot mode.

Running the GetDeviceID command via KCS from RHEL OS with Fab1 board
[root@localhost ~]# ipmitool raw 6 1
23 00 82 03 02 00 57 01 00 af 00 00 00 00 00

Running the GetDeviceID command via KCS from RHEL OS with Fab2 board
[root@localhost ~]# ipmitool raw 6 1
23 00 82 03 02 00 57 01 00 af 00 00 00 00 00

Earlier, BMC FW version in u-boot for get_device_id
was hardcoded.

Added a patch to read BMC version from SPI flash.

Reading the version data from SPI flash offset
PFM_ADDRESS + 0x400.

Note:
Added logic to convert hexadecimal number to decimal
as it is in phosphor-ipmi-host.

Tested:
Validated the BMC FW version from active image A and
Image B and it works fine.

Image A
[root@0csbesrhlrepo01 user]# ipmitool raw 6 1
23 00 00 19 02 00 57 01 00 af 00 00 00 00 00

Image B
[root@0csbesrhlrepo01 user]# ipmitool raw 6 1
23 00 00 19 02 00 57 01 00 af 00 00 00 00 00

Signed-off-by: Vinay Kumar Pabboju <vinayx.kumar.pabboju@intel.com>
Upstream-Status: Pending
---
 board/aspeed/ast2600_intel/ipmi-handler.c | 93 +++++++++++++++++++++--
 1 file changed, 88 insertions(+), 5 deletions(-)

diff --git a/board/aspeed/ast2600_intel/ipmi-handler.c b/board/aspeed/ast2600_intel/ipmi-handler.c
index a3ac40f201..3f61403ca7 100644
--- a/board/aspeed/ast2600_intel/ipmi-handler.c
+++ b/board/aspeed/ast2600_intel/ipmi-handler.c
@@ -2,6 +2,8 @@
 // Copyright (c) 2018-2022 Intel Corporation
 
 #include "ipmi-fwupd.h"
+#include <spi_flash.h>
+
 /* IPMI network function codes */
 #define NETFN_APP		0x06
 #define NETFN_FIRMWARE		0x08
@@ -33,6 +35,18 @@
 
 #define PRIMARY_IMAGE	0x01
 
+#define AST_GPIO_BASE		0x1e780000	/* GPIO base address */
+#define GPIO_020		0x020	/* GPIO E/F/G/H data value register offset */
+
+#define CTL_BOARD_ID		0x2f	/* Board ID */
+#define CTL_PROD_ID		0xaf	/* Product ID */
+#define CTL_INV_BOARD_ID	0x10	/* Inverted Board ID */
+
+#define PFM_REV_OFFSET	0x400
+#define SECONDARY_PFM_ADDRESS	0x4080000
+
+#define PFM_MAGIC_NUM	0x02b3ce1d
+
 typedef u16 (*fun_handler)(u8 *req, u16 req_len, u8 *res);
 
 struct get_dev_id {
@@ -68,10 +82,73 @@ struct ipmi_cmd_table {
 	fun_handler process_cmd;
 };
 
+struct pfm_revision {
+        u32 magic;
+        u8 svn;
+        u8 bkc;
+        u8 rev_maj;
+        u8 rev_min;
+}__attribute__((packed));
+
+static int get_bmc_fw_version_from_flash(u8 *fw_major, u8 *fw_minor)
+{
+        int ret;
+        struct spi_flash *flash_dev_temp = NULL;
+        struct pfm_revision pfm_data;
+        struct udevice *new_dev;
+        unsigned int bus   = CONFIG_SF_DEFAULT_BUS;
+        unsigned int cs    = CONFIG_SF_DEFAULT_CS;
+        unsigned int speed = 0;
+        unsigned int mode  = 0;
+        const u8 ipmiDevIdStateShift = 7;
+        const u8 ipmiDevIdFw1Mask = ~(1 << ipmiDevIdStateShift);
+        ret = spi_flash_probe_bus_cs(bus, cs, speed, mode, &new_dev);
+        if (ret) {
+                printf("Failed to initialize SPI flash at %u:%u (error %d)\n", bus, cs, ret);
+                return 1;
+        }
+        flash_dev_temp = dev_get_uclass_priv(new_dev);
+        u32 flash_offset = readb(BASE_ADDRESS + ACTIVE_IMAGE_OFFSET) == IMAGE_A ?
+                PFM_ADDRESS + PFM_REV_OFFSET  : SECONDARY_PFM_ADDRESS + PFM_REV_OFFSET;
+
+        if(spi_flash_read(flash_dev_temp, flash_offset, sizeof(pfm_data), &pfm_data)){
+                printf("Failed to read data at offset %08x\n", flash_offset);
+                return 1;
+        }
+
+        if (pfm_data.magic != PFM_MAGIC_NUM) {
+                printf("Read Magic number = %08x\n", pfm_data.magic);
+                return 1;
+        }
+        pfm_data.rev_maj = pfm_data.rev_maj & ipmiDevIdFw1Mask;
+        pfm_data.rev_min = (pfm_data.rev_min > 99 ? 99 : pfm_data.rev_min);
+        pfm_data.rev_min = pfm_data.rev_min % 10 + (pfm_data.rev_min / 10) * 16;
+        *fw_major = pfm_data.rev_maj;
+        *fw_minor = pfm_data.rev_min;
+        return 0;
+}
+
+static void get_platform_id(u8 *platform_id)
+{
+	/* Read Board ID from GPIO */
+	u8 board_id = ~(readl(AST_GPIO_BASE + GPIO_020) >> 8) & GENMASK(5,0);
+
+	switch(board_id)
+	{
+		case CTL_BOARD_ID:
+		case CTL_INV_BOARD_ID:
+			/* Assigning Product ID to an Array */
+			platform_id[0] = CTL_PROD_ID;
+			break;
+		default:
+			printf("Invalid Board ID: 0x%02x\n", board_id);
+			platform_id[0] = 0x00;
+	}
+}
+
 static u16 get_device_id(u8 *req, u16 req_len, u8 *res)
 {
 	/* Get Device ID */
-	bool operation = 1; /* Firmware operation */
 	u8 intel_mfg_id[3] = { 0x57, 0x01, 0x00 };
 	u8 platform_id[2] = { 0x00, 0x00 };
 	u8 aux_fw_rev[4] = { 0x00, 0x00, 0x00, 0x00 };
@@ -91,10 +168,16 @@ static u16 get_device_id(u8 *req, u16 req_len, u8 *res)
 	memcpy(result->mfg_id, intel_mfg_id, sizeof(result->mfg_id));
 	memcpy(result->aux_fw_rev, aux_fw_rev, sizeof(result->aux_fw_rev));
 
-	/* TODO: Get Firmware version from flash(PFM Header) */
-	result->fw_rev1 = ((operation << 7) | (0x02 & 0x7F));
-	result->fw_rev2 = 0x03;
-	/* TODO: Read Platform ID from GPIO */
+	/* Get Firmware version from flash(PFM Header) */
+	result->fw_rev1 = 0x00;
+	result->fw_rev2 = 0x00;
+	if(get_bmc_fw_version_from_flash(&result->fw_rev1, &result->fw_rev2)) {
+		result->completion_code = IPMI_CC_UNSPECIFIED;
+		return sizeof(result->completion_code);
+	}
+
+	/* Get Platform ID */
+	get_platform_id(platform_id);
 	memcpy(result->product_id, platform_id, sizeof(result->product_id));
 
 	return sizeof(struct get_dev_id);
-- 
2.17.1

