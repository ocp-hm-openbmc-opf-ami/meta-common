From f893c6f0a5cdc5a31904e1cb65f7ea4d897578ae Mon Sep 17 00:00:00 2001
From: arunkumarrajappa <arunkumarx.rajappa@intel.com>
Date: Thu, 27 Oct 2022 11:06:45 +0000
Subject: [PATCH] CTL: Added SVN check functionality for U-boot.

Functionality added to check PFM-SVN number from firmware
Image(fw_svn) aganist Manifest id from OTP image(otp_svn)
and also to check header revision from ROT image aganist
Manifest id from OTP image.
Also added revision id information on the ROT header.

Test Results :
1. System up and running
2. positive use case
   - System should boot successfully when PFM-SVN number from Image
     GREATER-THEN  Manifest-id from OTP image.
   - System should boot successfully when Header revision from ROT
     image is EQUAL TO Manifest id from OTP image.
   - verifying otp_svn value in the environment variable
     in uboot and linux.

3. Negative use case
   - System should not boot when Header revision from ROT image
     NOT-EQUAL to manifest id from OTP image.
   - System should not boot when PFM-SVN number from Image
     LESS THEN  manifest id from OTP image.

Signed-off-by: arunkumarrajappa <arunkumarx.rajappa@intel.com>
Upstream-Status: Pending
---
 cmd/otp.c             |   2 +-
 common/spl/otp_read.h | 133 ++++++++++++++++++++++++++++++++++++++++++
 common/spl/spl_fit.c  | 105 ++++++++++++++++++++++++++++++++-
 env/env.c             |  12 +++-
 4 files changed, 248 insertions(+), 4 deletions(-)
 create mode 100644 common/spl/otp_read.h

diff --git a/cmd/otp.c b/cmd/otp.c
index 2df410dfd0..9f08df6b95 100644
--- a/cmd/otp.c
+++ b/cmd/otp.c
@@ -423,7 +423,7 @@ static void otp_read_data(u32 offset, u32 *data)
 	data[1] = readl(OTP_COMPARE_2);
 }
 
-static void otp_read_conf(u32 offset, u32 *data)
+void otp_read_conf(u32 offset, u32 *data)
 {
 	int config_offset;
 
diff --git a/common/spl/otp_read.h b/common/spl/otp_read.h
new file mode 100644
index 0000000000..e100b6fa4e
--- /dev/null
+++ b/common/spl/otp_read.h
@@ -0,0 +1,133 @@
+/*
+ * As u-boot commands won't be available when SPL is loaded, adding the dependent functions and definitions manually here,
+ * for OTP read functionality from cmd/otp.c 
+ */
+
+#include <asm/io.h>
+
+#define PFM_IMAGE_LOAD_ADDR     0x80000
+#define PFM_HEADER_OFFSET       0x400
+#define PFM_IMAGE_LOAD_ADDR_B   0x04080000
+        
+#define OTP_BASE        0x1e6f2000
+#define OTP_ADDR        OTP_BASE + 0x10
+#define OTP_COMMAND     OTP_BASE + 0x4
+#define OTP_COMPARE_1   OTP_BASE + 0x20
+#define OTP_STATUS      OTP_BASE + 0x14
+#define OTP_A3          3
+#define OTP_PROTECT_KEY                 OTP_BASE
+#define OTP_PASSWD                      0x349fe38a
+
+#define OTP_KEY_TYPE_RSA_PUB            1
+#define OTP_KEY_TYPE_RSA_PRIV           2
+#define OTP_KEY_TYPE_AES                3
+#define OTP_KEY_TYPE_VAULT              4
+#define OTP_KEY_TYPE_HMAC               5
+
+#define ID0_AST2600A3   0x05030303
+#define ID1_AST2600A3   0x05030303
+#define ID0_AST2620A3   0x05030203
+#define ID1_AST2620A3   0x05030203
+#define ID0_AST2620A3   0x05030203
+#define ID1_AST2620A3   0x05030203
+#define ID0_AST2605A3   0x05030103
+#define ID1_AST2605A3   0x05030103
+#define ID0_AST2625A3   0x05030403
+#define ID1_AST2625A3   0x05030403
+#define OTP_FAILURE     -2
+
+
+
+struct pfm
+{
+    uint32_t magic;
+    uint8_t svn;
+    uint8_t bkc;
+    uint16_t pfm_revision;
+    uint32_t rsvd;
+    uint8_t oem_data[16];
+    uint32_t length;
+} __attribute__((packed));
+
+struct otpkey_type {
+        int value;
+        int key_type;
+        int need_id;
+        char information[110];
+};
+
+struct otpstrap_info {
+	signed char bit_offset;
+	signed char length;
+	signed char value;
+	const char *information;
+};
+
+struct otpconf_info {
+	signed char dw_offset;
+	signed char bit_offset;
+	signed char length;
+	signed char value;
+	const char *information;
+};
+
+struct scu_info {
+	signed char bit_offset;
+	signed char length;
+	const char *information;
+};
+
+static const struct otpstrap_info a1_strap_info[] = {
+	{ 0, 1, 0, "Disable Secure Boot" },
+	{ 0, 1, 1, "Enable Secure Boot" },
+	{ 1, 1, 0, "Disable boot from eMMC" },
+	{ 1, 1, 1, "Enable boot from eMMC" },
+	{ 2, 1, 0, "Disable Boot from debug SPI" },
+	{ 2, 1, 1, "Enable Boot from debug SPI" },
+	{ 3, 1, 0, "Enable ARM CM3" },
+	{ 3, 1, 1, "Disable ARM CM3" },
+	{ 4, 1, 0, "No VGA BIOS ROM, VGA BIOS is merged in the system BIOS" },
+	{ 4, 1, 1, "Enable dedicated VGA BIOS ROM" },
+	{ 5, 1, 0, "MAC 1 : RMII/NCSI" }
+
+};
+
+static const struct otpconf_info a3_conf_info[] = {
+	{ 0, 0, 1, 0, "Enable OTP Memory BIST Mode" },
+	{ 0, 0, 1, 1, "Disable OTP Memory BIST Mode" },
+	{ 0, 1, 1, 0, "Disable Secure Boot" },
+	{ 0, 1, 1, 1, "Enable Secure Boot" },
+	{ 0, 3, 1, 0, "User region ECC disable" }
+};
+
+static const struct scu_info a1_scu_info[] = {
+	{ 0, 1, "Disable ARM CA7 CPU boot (TXD5)" },
+	{ 1, 1, "Reserved0" },
+	{ 2, 1, "Enable boot from eMMC" }
+};
+
+static const struct otpkey_type a3_key_type[] = {
+        {1, OTP_KEY_TYPE_VAULT, 0, "AES-256 as secret vault key"},
+        {2, OTP_KEY_TYPE_AES,   1, "AES-256 as OEM platform key for image encryption/decryption in Mode 2 or AES-256 as OEM DSS keys for Mode GCM"},
+        {8, OTP_KEY_TYPE_RSA_PUB,   1, "RSA-public as OEM DSS public keys in Mode 2"},
+        {9, OTP_KEY_TYPE_RSA_PUB,   1, "RSA-public as OEM DSS public keys in Mode 2(big endian)"},
+        {10, OTP_KEY_TYPE_RSA_PUB,  0, "RSA-public as AES key decryption key"},
+        {11, OTP_KEY_TYPE_RSA_PUB,  0, "RSA-public as AES key decryption key(big endian)"},
+        {12, OTP_KEY_TYPE_RSA_PRIV,  0, "RSA-private as AES key decryption key"},
+        {13, OTP_KEY_TYPE_RSA_PRIV,  0, "RSA-private as AES key decryption key(big endian)"},
+};
+
+struct otp_info_cb {
+        int version;
+        char ver_name[3];
+        const struct otpstrap_info *strap_info;
+        int strap_info_len;
+        const struct otpconf_info *conf_info;
+        int conf_info_len;
+        const struct otpkey_type *key_info;
+        int key_info_len;
+        const struct scu_info *scu_info;
+        int scu_info_len;
+};
+static struct otp_info_cb info_cb;
+
diff --git a/common/spl/spl_fit.c b/common/spl/spl_fit.c
index d07955b0a6..21e40a01ed 100644
--- a/common/spl/spl_fit.c
+++ b/common/spl/spl_fit.c
@@ -10,7 +10,8 @@
 #include <image.h>
 #include <linux/libfdt.h>
 #include <spl.h>
-
+#include "otp_read.h"
+#include <secureboot_bbsram.h>
 #ifndef CONFIG_SYS_BOOTM_LEN
 #define CONFIG_SYS_BOOTM_LEN	(64 << 20)
 #endif
@@ -150,6 +151,103 @@ static int get_aligned_image_size(struct spl_load_info *info, int data_size,
 	return (data_size + info->bl_len - 1) / info->bl_len;
 }
 
+static u32 chip_version(void)
+{
+	u32 revid0, revid1;
+
+	revid0 = readl(ASPEED_REVISION_ID0);
+	revid1 = readl(ASPEED_REVISION_ID1);
+
+	if (revid0 == ID0_AST2600A3 && revid1 == ID1_AST2600A3) {
+		return OTP_A3;
+	} else if (revid0 == ID0_AST2620A3 && revid1 == ID1_AST2620A3) {
+		return OTP_A3;
+	} else if (revid0 == ID0_AST2605A3 && revid1 == ID1_AST2605A3) {
+		return OTP_A3;
+	} else if (revid0 == ID0_AST2625A3 && revid1 == ID1_AST2625A3) {
+		return OTP_A3;
+	}
+	return OTP_FAILURE;
+}
+static void otp_initialize()
+{
+	u32 ver;
+	ver = chip_version();
+	switch (ver) {
+		case OTP_A3:
+			info_cb.version = OTP_A3;
+			info_cb.conf_info = a3_conf_info;
+			info_cb.conf_info_len = ARRAY_SIZE(a3_conf_info);
+			info_cb.strap_info = a1_strap_info;
+			info_cb.strap_info_len = ARRAY_SIZE(a1_strap_info);
+			info_cb.key_info = a3_key_type;
+			info_cb.key_info_len = ARRAY_SIZE(a3_key_type);
+			info_cb.scu_info = a1_scu_info;
+			info_cb.scu_info_len = ARRAY_SIZE(a1_scu_info);
+			sprintf(info_cb.ver_name, "A3");
+			break;
+		default:
+			printf("SOC is not supported\n");
+			return CMD_RET_FAILURE;
+	}
+
+	writel(OTP_PASSWD, OTP_PROTECT_KEY); //password
+}
+
+
+static void wait_complete(void)
+{
+	int reg;
+	do {
+		reg = readl(OTP_STATUS);
+
+	} while ((reg & 0x6) != 0x6);
+}
+void otp_read_conf(u32 offset, u32 *data)
+{
+
+	int config_offset;
+	config_offset = 0x800;
+	config_offset |= (offset / 8) * 0x200;
+	config_offset |= (offset % 8) * 0x2;
+
+	writel(config_offset, OTP_ADDR);  //Read address
+	writel(0x23b1e361, OTP_COMMAND); //trigger read
+	wait_complete();
+	data[0] = readl(OTP_COMPARE_1);
+}
+bool validate_svn(void)
+{
+	struct pfm* pfm_struct;
+	u32 img_sel = readl(BBSRAM_BASE + BBSRAM_BOOT_SUCCESS);
+	if (img_sel == IMAGE_A) {
+            pfm_struct = (struct pfm*) (PFM_IMAGE_LOAD_ADDR + PFM_HEADER_OFFSET) ;     //Image A PFM at 0x80000
+	}
+	else if (img_sel == IMAGE_B) {
+            pfm_struct = (struct pfm*) (PFM_IMAGE_LOAD_ADDR_B + PFM_HEADER_OFFSET) ;   //Image B PFM at 0x04080000
+	}
+	else {
+		printf("\n Image selection Failed!\n");
+		return false;
+	}
+	uint8_t fw_svn = pfm_struct->svn;
+	uint32_t otp_svn = 0;
+
+	otp_initialize();
+	otp_svn = 0;
+	otp_read_conf(0xA, &otp_svn);
+
+	if( fw_svn >= otp_svn )
+	{
+		printf("\n Validate SVN_CHECK Passed!!!!");
+		return true;
+	}
+	else
+	{
+		printf("\n  Validate SVN_CHECK Failed!!!! expected fw_svn=%x current otp_svn=%x",fw_svn, otp_svn);
+		return false;
+	}
+}
 /**
  * spl_load_fit_image(): load the image described in a certain FIT node
  * @info:	points to information about the device to load data from
@@ -240,6 +338,11 @@ static int spl_load_fit_image(struct spl_load_info *info, ulong sector,
 	}
 
 #ifdef CONFIG_SPL_FIT_SIGNATURE
+	if (!validate_svn())
+		if(secureboot_image_recovery())//returns 1 when both images failed
+			hang();  //abort boot
+		else
+			do_reset(NULL, 0, 0, NULL);
 	printf("## Checking hash(es) for Image %s ... ",
 	       fit_get_name(fit, node, NULL));
 	if (!fit_image_verify_with_data(fit, node,
diff --git a/env/env.c b/env/env.c
index 42b17adadb..606b60bd02 100644
--- a/env/env.c
+++ b/env/env.c
@@ -196,13 +196,19 @@ void env_set_bootcmd(void)
             env_set("bootcmd", BOOT_COMMAND_IMAGE_B);
         }
 }
-
+extern void otp_read_conf(u32 offset, u32 *data);
+void env_set_otp_svn(void)
+{
+    uint32_t otp_svn = 0;
+    otp_read_conf(0xA, &otp_svn);
+    env_set_ulong("otp-svn", otp_svn);
+    env_save();
+}
 int env_load(void)
 {
 	struct env_driver *drv;
 	int best_prio = -1;
 	int prio;
-
 	for (prio = 0; (drv = env_driver_lookup(ENVOP_LOAD, prio)); prio++) {
 		int ret;
 
@@ -223,6 +229,8 @@ int env_load(void)
 			printf("OK\n");
                         /* Handle kernel FIT image switch */
                         env_set_bootcmd();
+                        /*Update OTP Manifest id to env  */
+                        env_set_otp_svn();
 			return 0;
 		} else if (ret == -ENOMSG) {
 			/* Handle "bad CRC" case */
-- 
2.17.1

