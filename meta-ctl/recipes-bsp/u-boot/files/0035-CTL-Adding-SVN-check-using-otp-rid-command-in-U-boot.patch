From 939b3c2c2f79e40cd01b859ad85e51f119e9198f Mon Sep 17 00:00:00 2001
From: arunkumarrajappa <arunkumarx.rajappa@intel.com>
Date: Tue, 11 Jul 2023 14:40:46 +0000
Subject: [PATCH] CTL:Adding SVN check using otp rid cmd in U-boot.

This changes adding SVN check using otp rid command
in U-boot.
Earlier OTP SVN was only read from OTPCFG10,
so only 32 SVN versions can be supported.
This change reads the OTP SVN using otp rid command
which will read from OTPCFG10 and 11 , hence enables
64 bit SVN support. The output of otp rid will be 8
bit and the response value ranges between 0 to 64.
So the output of otp rid can be compared against
pfm-svn , which is also of 8-bit and as per PFR HAS,
it can support the values between 0 to 64.

Test Results :
1. After firmware update System up and running.
2. positive use case
   - System should check PFM-SVN number from Image
     GREATER THAN OR EQUAL TO otp revision ID from OTP
	 image and boot the system successfully.
3. Negative use case
   - System should not boot when PFM-SVN number from
   Image LESS THAN otp revision ID from OTP image.

Signed-off-by: Anoop S <anoopx.s@intel.com>
Signed-off-by: arunkumarrajappa <arunkumarx.rajappa@intel.com>
Upstream-Status: Pending
---
 cmd/otp.c             |   5 +-
 common/spl/otp_read.h | 113 +++++++++++++++++++++++++++++++++++++++++-
 common/spl/spl_fit.c  | 112 +++++++++++------------------------------
 env/env.c             |  20 ++++++--
 include/otp.h         |  17 +++++++
 5 files changed, 174 insertions(+), 93 deletions(-)
 create mode 100644 include/otp.h

diff --git a/cmd/otp.c b/cmd/otp.c
index 9f08df6b95..602ba2f86a 100644
--- a/cmd/otp.c
+++ b/cmd/otp.c
@@ -281,7 +281,7 @@ static int get_dw_bit(u32 *rid, int offset)
 		return 0;
 }
 
-static int get_rid_num(u32 *rid)
+int get_rid_num(u32 *rid)
 {
 	int i;
 	int fz = 0;
@@ -304,7 +304,7 @@ static int get_rid_num(u32 *rid)
 
 	return rid_num;
 }
-
+EXPORT_SYMBOL_GPL(get_rid_num);
 static u32 chip_version(void)
 {
 	u32 revid0, revid1;
@@ -437,6 +437,7 @@ void otp_read_conf(u32 offset, u32 *data)
 	data[0] = readl(OTP_COMPARE_1);
 }
 
+EXPORT_SYMBOL_GPL(otp_read_conf);
 static int otp_compare(u32 otp_addr, u32 addr)
 {
 	u32 ret;
diff --git a/common/spl/otp_read.h b/common/spl/otp_read.h
index e100b6fa4e..b0af2fc3ee 100644
--- a/common/spl/otp_read.h
+++ b/common/spl/otp_read.h
@@ -35,8 +35,7 @@
 #define ID0_AST2625A3   0x05030403
 #define ID1_AST2625A3   0x05030403
 #define OTP_FAILURE     -2
-
-
+#define OTP_LOCK_VALUE  1
 
 struct pfm
 {
@@ -131,3 +130,113 @@ struct otp_info_cb {
 };
 static struct otp_info_cb info_cb;
 
+static u32 chip_version(void)
+{
+        u32 revid0, revid1;
+
+        revid0 = readl(ASPEED_REVISION_ID0);
+        revid1 = readl(ASPEED_REVISION_ID1);
+
+        if (revid0 == ID0_AST2600A3 && revid1 == ID1_AST2600A3) {
+                return OTP_A3;
+        } else if (revid0 == ID0_AST2620A3 && revid1 == ID1_AST2620A3) {
+                return OTP_A3;
+        } else if (revid0 == ID0_AST2605A3 && revid1 == ID1_AST2605A3) {
+                return OTP_A3;
+        } else if (revid0 == ID0_AST2625A3 && revid1 == ID1_AST2625A3) {
+                return OTP_A3;
+        }
+        return OTP_FAILURE;
+}
+
+static void otp_initialize()
+{
+        u32 ver;
+        ver = chip_version();
+        switch (ver) {
+                case OTP_A3:
+                        info_cb.version = OTP_A3;
+                        info_cb.conf_info = a3_conf_info;
+                        info_cb.conf_info_len = ARRAY_SIZE(a3_conf_info);
+                        info_cb.strap_info = a1_strap_info;
+                        info_cb.strap_info_len = ARRAY_SIZE(a1_strap_info);
+                        info_cb.key_info = a3_key_type;
+                        info_cb.key_info_len = ARRAY_SIZE(a3_key_type);
+                        info_cb.scu_info = a1_scu_info;
+                        info_cb.scu_info_len = ARRAY_SIZE(a1_scu_info);
+                        sprintf(info_cb.ver_name, "A3");
+                        break;
+                default:
+                        printf("SOC is not supported\n");
+                        return CMD_RET_FAILURE;
+        }
+        writel(OTP_PASSWD, OTP_PROTECT_KEY);//password
+}
+
+static void wait_complete(void)
+{
+        int reg;
+        do {
+                reg = readl(OTP_STATUS);
+        } while ((reg & 0x6) != 0x6);
+}
+
+void otp_read_conf(u32 offset, u32 *data)
+{
+        int config_offset;
+        config_offset = 0x800;
+        config_offset |= (offset / 8) * 0x200;
+        config_offset |= (offset % 8) * 0x2;
+
+        writel(config_offset, OTP_ADDR);  //Read address
+        writel(0x23b1e361, OTP_COMMAND); //trigger read
+        wait_complete();
+        data[0] = readl(OTP_COMPARE_1);
+}
+
+int get_dw_bit(uint32_t *rid, int32_t offset)
+{
+        int32_t bit_offset;
+        int32_t i;
+
+        if (offset < 32) {
+                i = 0;
+                bit_offset = offset;
+        } else {
+                i = 1;
+                bit_offset = offset - 32;
+        }
+        if ((rid[i] >> bit_offset) & 0x1)
+                return 1;
+        else
+                return 0;
+}
+
+int get_rid_num(uint32_t *rid)
+{
+        int32_t i;
+        int32_t fz = 0;
+        int32_t rid_num = 0;
+        int32_t ret = 0;
+
+        for (i = 0; i < 64; i++) {
+                if (get_dw_bit(rid, i) == 0) {
+                        if (!fz)
+                                fz = 1;
+
+                } else {
+                        rid_num++;
+                        if (fz)
+                                ret = OTP_FAILURE;
+                }
+        }
+        if (ret)
+                return ret;
+
+        return rid_num;
+}
+
+void otp_lock()
+{
+        writel(OTP_LOCK_VALUE, OTP_PROTECT_KEY);//protect otp controller
+}
diff --git a/common/spl/spl_fit.c b/common/spl/spl_fit.c
index 21e40a01ed..b087fae742 100644
--- a/common/spl/spl_fit.c
+++ b/common/spl/spl_fit.c
@@ -12,10 +12,10 @@
 #include <spl.h>
 #include "otp_read.h"
 #include <secureboot_bbsram.h>
+#include <otp.h>
 #ifndef CONFIG_SYS_BOOTM_LEN
 #define CONFIG_SYS_BOOTM_LEN	(64 << 20)
 #endif
-
 __weak void board_spl_fit_post_load(ulong load_addr, size_t length)
 {
 }
@@ -151,71 +151,6 @@ static int get_aligned_image_size(struct spl_load_info *info, int data_size,
 	return (data_size + info->bl_len - 1) / info->bl_len;
 }
 
-static u32 chip_version(void)
-{
-	u32 revid0, revid1;
-
-	revid0 = readl(ASPEED_REVISION_ID0);
-	revid1 = readl(ASPEED_REVISION_ID1);
-
-	if (revid0 == ID0_AST2600A3 && revid1 == ID1_AST2600A3) {
-		return OTP_A3;
-	} else if (revid0 == ID0_AST2620A3 && revid1 == ID1_AST2620A3) {
-		return OTP_A3;
-	} else if (revid0 == ID0_AST2605A3 && revid1 == ID1_AST2605A3) {
-		return OTP_A3;
-	} else if (revid0 == ID0_AST2625A3 && revid1 == ID1_AST2625A3) {
-		return OTP_A3;
-	}
-	return OTP_FAILURE;
-}
-static void otp_initialize()
-{
-	u32 ver;
-	ver = chip_version();
-	switch (ver) {
-		case OTP_A3:
-			info_cb.version = OTP_A3;
-			info_cb.conf_info = a3_conf_info;
-			info_cb.conf_info_len = ARRAY_SIZE(a3_conf_info);
-			info_cb.strap_info = a1_strap_info;
-			info_cb.strap_info_len = ARRAY_SIZE(a1_strap_info);
-			info_cb.key_info = a3_key_type;
-			info_cb.key_info_len = ARRAY_SIZE(a3_key_type);
-			info_cb.scu_info = a1_scu_info;
-			info_cb.scu_info_len = ARRAY_SIZE(a1_scu_info);
-			sprintf(info_cb.ver_name, "A3");
-			break;
-		default:
-			printf("SOC is not supported\n");
-			return CMD_RET_FAILURE;
-	}
-
-	writel(OTP_PASSWD, OTP_PROTECT_KEY); //password
-}
-
-
-static void wait_complete(void)
-{
-	int reg;
-	do {
-		reg = readl(OTP_STATUS);
-
-	} while ((reg & 0x6) != 0x6);
-}
-void otp_read_conf(u32 offset, u32 *data)
-{
-
-	int config_offset;
-	config_offset = 0x800;
-	config_offset |= (offset / 8) * 0x200;
-	config_offset |= (offset % 8) * 0x2;
-
-	writel(config_offset, OTP_ADDR);  //Read address
-	writel(0x23b1e361, OTP_COMMAND); //trigger read
-	wait_complete();
-	data[0] = readl(OTP_COMPARE_1);
-}
 bool validate_svn(void)
 {
 	struct pfm* pfm_struct;
@@ -227,26 +162,35 @@ bool validate_svn(void)
             pfm_struct = (struct pfm*) (PFM_IMAGE_LOAD_ADDR_B + PFM_HEADER_OFFSET) ;   //Image B PFM at 0x04080000
 	}
 	else {
-		printf("\n Image selection Failed!\n");
-		return false;
-	}
-	uint8_t fw_svn = pfm_struct->svn;
-	uint32_t otp_svn = 0;
-
-	otp_initialize();
-	otp_svn = 0;
-	otp_read_conf(0xA, &otp_svn);
-
-	if( fw_svn >= otp_svn )
-	{
-		printf("\n Validate SVN_CHECK Passed!!!!");
-		return true;
-	}
-	else
-	{
-		printf("\n  Validate SVN_CHECK Failed!!!! expected fw_svn=%x current otp_svn=%x",fw_svn, otp_svn);
+		printf("Secure boot: Image selection Failed!\n");
 		return false;
 	}
+        uint32_t fw_svn = pfm_struct->svn;
+        int32_t otp_svn = 0;
+        uint32_t otp_rid[2];
+        // Checks for valid SVN range of 0 - 64
+        if (fw_svn > SVN_MAX) {
+                printf("Secure boot: Invalid FW SVN(0x%lx) image flashed. So stopping boot \n",fw_svn);
+                return false;
+        }
+        otp_initialize();
+        otp_read_conf(OTP_REV_ID_OFFSET_1, &otp_rid[0]);
+        otp_read_conf(OTP_REV_ID_OFFSET_2, &otp_rid[1]);
+        otp_svn = get_rid_num(otp_rid);
+        otp_lock(); //protect otp controller
+        if(otp_svn < 0 ) {
+            printf("Secure boot: get_rid_num() Failed !!! \n");
+            return false;
+        }
+        printf("fw_svn=0x%lx current otp_svn=0x%lx \n",fw_svn, otp_svn);
+        if( fw_svn >= otp_svn ) {
+            printf(" Validate SVN_CHECK Passed!!!! \n");
+            return true;
+        }
+        else {
+            printf("Secure boot: Error - SVN check failed. FW_SVN: 0x%1x, OTP_SVN: 0x%1x\n", fw_svn, otp_svn);
+            return false;
+        }
 }
 /**
  * spl_load_fit_image(): load the image described in a certain FIT node
diff --git a/env/env.c b/env/env.c
index c9c6810279..714db633d7 100644
--- a/env/env.c
+++ b/env/env.c
@@ -7,6 +7,7 @@
 #include <common.h>
 #include <environment.h>
 #include <asm/io.h>
+#include <otp.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -202,13 +203,22 @@ void env_set_bootcmd(void)
             env_set("bootcmd", BOOT_COMMAND_IMAGE_B);
         }
 }
-extern void otp_read_conf(u32 offset, u32 *data);
 void env_set_otp_svn(void)
 {
-    uint32_t otp_svn = 0;
-    otp_read_conf(0xA, &otp_svn);
-    env_set_ulong("otp-svn", otp_svn);
-    env_save();
+    int32_t otp_svn = 0;
+    uint32_t otp_rid[2];
+    writel(OTP_PASSWD, OTP_PROTECT_KEY);//unlock otp region
+    otp_read_conf(OTP_REV_ID_OFFSET_1, &otp_rid[0]);
+    otp_read_conf(OTP_REV_ID_OFFSET_2, &otp_rid[1]);
+    otp_svn = get_rid_num(otp_rid);
+    writel(OTP_LOCK_VALUE, OTP_PROTECT_KEY); //protect otp controller
+    if (otp_svn >= 0) {
+        env_set_ulong("otp-svn", otp_svn);
+        env_save();
+    }
+    else {
+        printf("Current OTP revision ID is not valid !!!!!\n");
+    }
 }
 int env_load(void)
 {
diff --git a/include/otp.h b/include/otp.h
new file mode 100644
index 0000000000..5c7afdb1e4
--- /dev/null
+++ b/include/otp.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2023
+ * Intel Corporation, <www.intel.com>
+ */
+#ifndef	_OTP_H_
+#define	_OTP_H_
+#define SVN_MAX             64
+#define OTP_REV_ID_OFFSET_1 10
+#define OTP_REV_ID_OFFSET_2 11
+#define OTP_PASSWD          0x349fe38a
+#define OTP_BASE            0x1e6f2000
+#define OTP_PROTECT_KEY     OTP_BASE
+#define OTP_LOCK_VALUE      1
+void otp_read_conf(u32 offset, u32 *data);
+int get_rid_num(u32 *rid);
+#endif
-- 
2.17.1

