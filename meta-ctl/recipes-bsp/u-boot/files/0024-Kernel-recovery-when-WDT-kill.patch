From 3dd8eeae9e6d7e2efff796bc41c58329a9f38783 Mon Sep 17 00:00:00 2001
From: Anoop S <anoopx.s@intel.com>
Date: Tue, 7 Feb 2023 09:16:40 +0000
Subject: [PATCH] Kernel recovery when WDT timeout

This change for recovery of the kernel/switch the kernel
when the killed WDT timer.

Tested:
1. Flashed the image and system booting fine.
2. When Kernel-A is active and kill the WDT timer
   system will switch kernel-B image and reboot wise versa
3.If both images are marked as corrupted in BB register
  system will stay on AST mode.
4.If the new image is flashed with dediprog and system will
  boot fine

Signed-off-by: Anoop S <anoopx.s@intel.com>
Upstream-Status: Pending
---
 board/aspeed/ast2600_intel/intel.c | 14 ++++++++++++++
 common/autoboot.c                  | 24 +++++++++++++++++++-----
 2 files changed, 33 insertions(+), 5 deletions(-)

diff --git a/board/aspeed/ast2600_intel/intel.c b/board/aspeed/ast2600_intel/intel.c
index 382c311c54..c0520f7d05 100644
--- a/board/aspeed/ast2600_intel/intel.c
+++ b/board/aspeed/ast2600_intel/intel.c
@@ -32,6 +32,19 @@ static void set_boot_failures(u32 count)
 	env_save();
 }
 
+static void set_recovery_failures()
+{
+        u32 recoverycount;
+        recoverycount = env_get_ulong("recoveryfailures", 10, 0);
+        if (recoverycount) {
+            env_set_ulong("recoveryfailures", recoverycount);
+        }
+        else {
+            env_set_ulong("recoveryfailures", 0);
+        }
+        env_save();
+}
+
 int intel_failed_boot(void)
 {
 	struct udevice *dev;
@@ -704,6 +717,7 @@ int board_late_init(void)
 	else
 		set_boot_failures(0);
 
+        set_recovery_failures();
 	board_id = get_board_id();
 	printf("Board ID: 0x%02x\n", board_id);
 	set_dtb(board_id);
diff --git a/common/autoboot.c b/common/autoboot.c
index fcc81d588c..4d75cfa1e4 100644
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -19,6 +19,7 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 #define MAX_DELAY_STOP_STR 32
+#define RECOVERY_FAILURE_LIMIT 2
 
 #define WAIT_STATE_TIMEOUT	10000
 #ifndef DEBUG_BOOTKEYS
@@ -273,6 +274,13 @@ static int abortboot(int bootdelay)
 {
 	int abort = 0;
 	int clear = 0;
+	int recoverycount = env_get_ulong("recoveryfailures", 10, 0);
+
+        if (recoverycount >= RECOVERY_FAILURE_LIMIT){
+                 printf ("Both images are failed to load stop the boot ...........# \n");
+                 abort=1;
+                 goto exit;
+        }
 
 	if (bootdelay >= 0)
 		abort = __abortboot(bootdelay);
@@ -290,15 +298,21 @@ static int abortboot(int bootdelay)
 
 	if (intel_failed_boot())
 	{
-                if(secureboot_image_recovery()) {
-                    /* Allow normal boot flow */
+                ++recoverycount;
+                env_set_ulong("recoveryfailures",recoverycount );
+                env_save();
+                secureboot_image_recovery ();
+                env_set_ulong("bootfailures", clear);
+                env_save();
+                if(recoverycount >= RECOVERY_FAILURE_LIMIT) {
+                    printf ("Both images are failed to load stop the boot ............ \n");
                     abort=1;
                     goto exit;
                 }
-                else {
+                else
+                {
                     /* switch and boot from alternate image */
-                    env_set_ulong("bootfailures", clear);
-                    env_save();
+                    printf ("load alternate kernel image ............ \n");
                     do_reset(NULL, 0, 0, NULL);
                 }
 	}
-- 
2.17.1
