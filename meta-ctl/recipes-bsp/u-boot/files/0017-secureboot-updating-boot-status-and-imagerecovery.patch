From 8b87a0191e4981a5bcda09f9c7c880d4d93e19e8 Mon Sep 17 00:00:00 2001
From: Anoop S <anoopx.s@intel.com>
Date: Sat, 22 Oct 2022 04:57:30 +0000
Subject: [PATCH] secureboot-updating boot status and imagerecovery

Update the boot status (success or failure) in Battery backed registers
and also switch to alternate image for recovery.The failed image
details are updated in the Battery backed Register(offset 0x104).Switch
the image to handle the recovery by updating the value in Battery
backed Register (offset 0x100).

Solve the HUNK error

Tested:
1.Set the Battery Backed register value to 0x01 and the Uboot image
load and booted from the Image A location successfully.
2.Set the Battery Backed register value to 0x02 and the Uboot image
load and booted from the Image B location successfully.
3.The build is success and image booted fine.
4.Both image is corrupted system should halt at u-boot.

Signed-off-by: Anoop S <anoopx.s@intel.com>
Upstream-Status: Pending
---
 cmd/fdt.c                   |  9 +++++
 common/autoboot.c           | 15 ++++++--
 include/secureboot_bbsram.h | 72 +++++++++++++++++++++++++++++++++++++
 3 files changed, 94 insertions(+), 2 deletions(-)
 create mode 100644 include/secureboot_bbsram.h

diff --git a/cmd/fdt.c b/cmd/fdt.c
index 10d8f3230b..bdd626623b 100644
--- a/cmd/fdt.c
+++ b/cmd/fdt.c
@@ -16,6 +16,7 @@
 #include <fdt_support.h>
 #include <mapmem.h>
 #include <asm/io.h>
+#include <secureboot_bbsram.h>
 
 #define MAX_LEVEL	32		/* how deeply nested we will go */
 #define SCRATCHPAD	1024		/* bytes of scratchpad memory */
@@ -753,6 +754,14 @@ static int fdt_valid(struct fdt_header **blobp)
 
 	if (err < 0) {
 		printf("libfdt fdt_check_header(): %s", fdt_strerror(err));
+        if(secureboot_image_recovery()) {
+            /* Allow normal boot flow */
+            return 0;
+        }
+        else {
+            /* switch and boot from alternate image */
+            do_reset(NULL, 0, 0, NULL);
+        }
 		/*
 		 * Be more informative on bad version.
 		 */
diff --git a/common/autoboot.c b/common/autoboot.c
index f8b5b61caa..b0c61baca2 100644
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -14,6 +14,7 @@
 #include <post.h>
 #include <u-boot/sha256.h>
 #include <bootcount.h>
+#include <secureboot_bbsram.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -270,6 +271,7 @@ __weak void board_pre_abort_autoboot(void)
 static int abortboot(int bootdelay)
 {
 	int abort = 0;
+	int clear = 0;
 
 	if (bootdelay >= 0)
 		abort = __abortboot(bootdelay);
@@ -290,8 +292,17 @@ static int abortboot(int bootdelay)
 
 	if (intel_failed_boot())
 	{
-		abort=1;
-		goto exit;
+                if(secureboot_image_recovery()) {
+                    /* Allow normal boot flow */
+                    abort=1;
+                    goto exit;
+                }
+                else {
+                    /* switch and boot from alternate image */
+                    env_set_ulong("bootfailures", clear);
+                    env_save();
+                    do_reset(NULL, 0, 0, NULL);
+                }
 	}
 
 	if (verify_spi_pfm())
diff --git a/include/secureboot_bbsram.h b/include/secureboot_bbsram.h
new file mode 100644
index 0000000000..029e7310bf
--- /dev/null
+++ b/include/secureboot_bbsram.h
@@ -0,0 +1,72 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2022
+ * Intel, <www.intel.com>
+ */
+
+#ifndef _SECUREBOOT_BBSRAM_H_
+#define _SECUREBOOT_BBSRAM_H_
+
+
+#define BBSRAM_BASE             0x1E6EF000
+#define BBSRAM_BOOT_SUCCESS     0x100
+#define BBSRAM_BOOT_FAILURE     0x104
+#define PROTECTION_KEY_UNLOCK   0xDBA078E2
+#define PROTECTION_KEY_LOCK     0xFFFFFFFF
+#define MASK_VALUE_IMAGE_A      1
+#define MASK_VALUE_IMAGE_B      (1 << 1)
+
+enum {
+        IMAGE_NONE        = 0x00,
+        IMAGE_A,
+        IMAGE_B,
+        BOTH_IMAGE_FAILED,
+};
+
+static int secureboot_image_recovery (void)
+{
+    u32 img_fail = readl(BBSRAM_BASE + BBSRAM_BOOT_FAILURE);
+    writel(PROTECTION_KEY_UNLOCK, BBSRAM_BASE);
+    if (img_fail == BOTH_IMAGE_FAILED)
+    {
+        writel(IMAGE_NONE, BBSRAM_BASE + BBSRAM_BOOT_SUCCESS);
+        writel(PROTECTION_KEY_LOCK, BBSRAM_BASE);
+        /* Both images failed HALT the system */
+        return 1;
+    }
+    u32 img_sel = readl(BBSRAM_BASE + BBSRAM_BOOT_SUCCESS);
+    if (img_sel == IMAGE_A)
+    {
+        /*
+        * Update the bit 0/1 in Register 104  and update
+        * alternate image to Register 100.
+        */
+        img_fail = img_fail | MASK_VALUE_IMAGE_A;
+        writel(img_fail, BBSRAM_BASE + BBSRAM_BOOT_FAILURE);
+        writel(IMAGE_B, BBSRAM_BASE + BBSRAM_BOOT_SUCCESS);
+        writel(PROTECTION_KEY_LOCK, BBSRAM_BASE);
+        return 0;
+    }
+    else if (img_sel == IMAGE_B)
+    {
+        /*
+        * Update the bit 0/1 in Register 104  and update
+        * alternate image to Register 100.
+        */
+        img_fail = img_fail | MASK_VALUE_IMAGE_B;
+        writel(img_fail, BBSRAM_BASE + BBSRAM_BOOT_FAILURE);
+        writel(IMAGE_A, BBSRAM_BASE + BBSRAM_BOOT_SUCCESS);
+        writel(PROTECTION_KEY_LOCK, BBSRAM_BASE);
+        return 0;
+    }
+    else
+    {
+        writel(IMAGE_NONE, BBSRAM_BASE + BBSRAM_BOOT_SUCCESS);
+        writel(PROTECTION_KEY_LOCK, BBSRAM_BASE);
+        /* Both image failed Halt the system */
+        return 1;
+    }
+    writel(PROTECTION_KEY_LOCK, BBSRAM_BASE);
+}
+
+#endif
-- 
2.17.1

