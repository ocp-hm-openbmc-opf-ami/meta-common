From 438c4abcb7b98f358fc9c7e168dc03090c06b2f7 Mon Sep 17 00:00:00 2001
From: Anoop S <anoopx.s@intel.com>
Date: Mon, 9 Jan 2023 07:11:39 +0000
Subject: [PATCH] Uboot image recovery

This code changes for the uboot image recovery and image switching
between Image-A and image-B and the both images are corrupted the
system will not boot beyond SPL.

Test Results:
1.The image flashed the system and booting fine.
2.ABR indicator=0, Corrupted uboot-A and kernel-A, system booted
  completely with uboot-B and kernel-B.
3.ABR indicator=0, Corrupted uboot-B and kernel-B, system booted
  completely with uboot-A and kernel-B.
4.ABR indicator=0, both uboots and kernels are Corrupted, system
  will not boot beyond SPL and stay in SPL.
5.ABR indicator=1, Corrupted uboot-A and kernel-A, system booted
  completely with uboot-B and kernel-B.
6.ABR indicator=1, Corrupted uboot-B and kernel-B, system booted
  completely with uboot-A and kernel-B.
7.ABR indicator=1, both uboots and kernels are Corrupted, system
  will not boot beyond SPL and stay in SPL.

Signed-off-by: Anoop S <anoopx.s@intel.com>

%% original patch: 0022-CTL-Uboot-Image-Recovery-Fix.patch
Upstream-Status: Pending
---
 common/spl/spl_ram.c | 68 +++++++++++++++++++++++++++++++++++++-------
 1 file changed, 58 insertions(+), 10 deletions(-)

diff --git a/common/spl/spl_ram.c b/common/spl/spl_ram.c
index 5eb15f65fd..240b5dc626 100644
--- a/common/spl/spl_ram.c
+++ b/common/spl/spl_ram.c
@@ -16,6 +16,7 @@
 #include <linux/libfdt.h>
 #include <asm/io.h>
 #include <mmc.h>
+#include <secureboot_bbsram.h>
 
 #define CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_A     0x00010000
 #define CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_B     0x04010000
@@ -38,6 +39,7 @@
 #define MASK_VALUE_IMAGE_A              1
 #define MASK_VALUE_IMAGE_B              (1 << 1)
 
+u32 ABR_INDICATOR = 0;
 
 static ulong spl_ram_load_read(struct spl_load_info *load, ulong sector,
 			       ulong count, void *buf)
@@ -47,16 +49,33 @@ static ulong spl_ram_load_read(struct spl_load_info *load, ulong sector,
         u32 img_sel = readl(BBSRAM_BASE + BBSRAM_BOOT_SUCCESS);
         u32 img_fail = readl(BBSRAM_BASE + BBSRAM_BOOT_FAIL);
         if ((img_sel == IMAGE_A) && !(img_fail & MASK_VALUE_IMAGE_A)) {
-
-            memcpy(buf, (void *)(CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_A + sector), count);
+            if(ABR_INDICATOR) {
+                memcpy(buf, (void *)(CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_B + sector), count);
+            }
+            else
+            {
+                memcpy(buf, (void *)(CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_A + sector), count);
+            }
         }
         else if ((img_sel == IMAGE_B) && !(img_fail & MASK_VALUE_IMAGE_B)) {
-            memcpy(buf, (void *)(CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_B + sector), count);
+            if(ABR_INDICATOR) {
+                memcpy(buf, (void *)(CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_A + sector), count);
+            }
+            else
+            {
+                memcpy(buf, (void *)(CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_B + sector), count);
+            }
         }
         else {
-            memcpy(buf, (void *)(CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_A + sector), count);
+            if(ABR_INDICATOR) {
+                memcpy(buf, (void *)(CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_B + sector), count);
+            }
+            else {
+                memcpy(buf, (void *)(CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_A + sector), count);
+            }
         }
-
+	/* Clear the ABR indicator  */
+        writel(FMC_WDT2_CONTROL, FMC_WDT2_BASE + WDT_LOAD_TIMER);
 	return count;
 }
 
@@ -68,27 +87,51 @@ static int spl_ram_load_image(struct spl_image_info *spl_image,
         writel(PROTECTION_KEY, BBSRAM_BASE);
         if(abr_status & (1 << BOOT_FLASH_SOURCE_INDICATOR_BIT)){
             writel(IMAGE_B, BBSRAM_BASE + BBSRAM_ROT_BOOT);
+            ABR_INDICATOR =1;
         }
         else{
             writel(IMAGE_A, BBSRAM_BASE + BBSRAM_ROT_BOOT);
+            ABR_INDICATOR =0;
         }
-        writel(FMC_WDT2_CONTROL, FMC_WDT2_BASE + WDT_LOAD_TIMER);
         u32 img_sel = readl(BBSRAM_BASE + BBSRAM_BOOT_SUCCESS);
         u32 img_fail = readl(BBSRAM_BASE + BBSRAM_BOOT_FAIL);
         if ((img_sel == IMAGE_A) && !(img_fail & MASK_VALUE_IMAGE_A)) {
-            header = (struct image_header *)CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_A;
+            printf("\n Loading from Uboot-A ...");
+	    /* If the Source indicator is set, the uboot-A is preset in 0x04010000
+	     * address and load uboot from that address.
+	    */
+            if(ABR_INDICATOR) {
+                header = (struct image_header *)CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_B;
+            }
+            else {
+                header = (struct image_header *)CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_A;
+            }
         }
         else if ((img_sel == IMAGE_B) && !(img_fail & MASK_VALUE_IMAGE_B)) {
-            header = (struct image_header *)CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_B;
+            printf("\n Loading from Uboot-B ...");
+	    /* If the Source indicator is set, the uboot-B is preset in 0x00010000
+             * address and load uboot from that address.
+	    */
+            if(ABR_INDICATOR) {
+                header = (struct image_header *)CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_A;
+            }
+            else {
+                header = (struct image_header *)CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_B;
+            }
         }
         else
         {
+            printf("\n Loading from Uboot-A ...");
             writel(IMAGE_NONE, BBSRAM_BASE + BBSRAM_BOOT_FAIL);
             writel(IMAGE_A, BBSRAM_BASE + BBSRAM_BOOT_SUCCESS);
-            header = (struct image_header *)CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_A;
+            if(ABR_INDICATOR) {
+                header = (struct image_header *)CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_B;
+            }
+            else {
+                header = (struct image_header *)CONFIG_SPL_LOAD_FIT_ADDRESS_IMAGE_A;
+            }
         }
 
-
 #if CONFIG_IS_ENABLED(DFU)
 	if (bootdev->boot_device == BOOT_DEVICE_DFU)
 		spl_dfu_cmd(0, "dfu_alt_info_ram", "ram", "0");
@@ -106,6 +149,11 @@ static int spl_ram_load_image(struct spl_image_info *spl_image,
 		ulong u_boot_pos = binman_sym(ulong, u_boot_any, image_pos);
 
 		debug("Legacy image\n");
+        if(secureboot_image_recovery())//returns 1 when both images failed
+            hang();  //abort boot
+        else
+            //Switch to recovery image
+            do_reset(NULL, 0, 0, NULL);
 		/*
 		 * Get the header.  It will point to an address defined by
 		 * handoff which will tell where the image located inside
-- 
2.17.1
