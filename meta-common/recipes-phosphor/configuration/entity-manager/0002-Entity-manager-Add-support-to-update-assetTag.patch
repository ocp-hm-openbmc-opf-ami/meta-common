From 8a87b9d8eedc9ece3d2badbdd8b4c6069156b2ba Mon Sep 17 00:00:00 2001
From: vijayabharathi shetty <vijayabharathix.shetty@intel.com>
Date: Tue, 31 May 2022 04:13:34 +0000
Subject: [PATCH] Entity-manager: Add support to update assetTag

Asset tag is an updateable property from User level interface like
Redfish. User-level interface will update Asset tag in entity-manager,
which will further update the needed FRU interface property exposed.

Tested:
Successfully updated in assetTag interface as well as in fru interface
while using set-property and using redfish as well.
The new value is preserved after BMC resets.

Signed-off-by: mansijos <mansi.joshi@intel.com>
---
 src/entity_manager.cpp | 74 ++++++++++++++++++++++++++++++++++++++++--
 src/perform_scan.cpp   |  3 ++
 2 files changed, 75 insertions(+), 2 deletions(-)

diff --git a/src/entity_manager.cpp b/src/entity_manager.cpp
index 12c57c5..ea24901 100644
--- a/src/entity_manager.cpp
+++ b/src/entity_manager.cpp
@@ -51,6 +51,13 @@ constexpr const char* lastConfiguration = "/tmp/configuration/last.json";
 constexpr const char* currentConfiguration = "/var/configuration/system.json";
 constexpr const char* globalSchema = "global.json";
 
+using foundProbeData = std::map<std::string, std::string>;
+static foundProbeData foundData;
+static std::map<std::string, foundProbeData> mapFoundData;
+
+constexpr const char* fruConn = "xyz.openbmc_project.FruDevice";
+constexpr const char* fruIntf = "xyz.openbmc_project.FruDevice";
+
 const boost::container::flat_map<const char*, probe_type_codes, CmpStr>
     probeTypes{{{"FALSE", probe_type_codes::FALSE_T},
                 {"TRUE", probe_type_codes::TRUE_T},
@@ -199,6 +206,43 @@ void addArrayToDbus(const std::string& name, const nlohmann::json& array,
     }
 }
 
+template <typename PropertyType>
+bool persistAssetTag(const PropertyType& newVal,
+                     const std::string& jsonPointerString)
+{
+    std::size_t found = jsonPointerString.find_last_of("/\\");
+    std::string jsonPointerPath = jsonPointerString.substr(0, found);
+
+    auto it = mapFoundData.find(jsonPointerPath);
+    if (it == mapFoundData.end())
+    {
+        std::cerr << "Error in finding jsonPointerPath in mapFoundData"
+                  << "\n";
+        return false;
+    }
+
+    foundProbeData& tmpMap = it->second;
+    auto foundPath = tmpMap.find("foundPath");
+    if (foundPath == tmpMap.end())
+    {
+        std::cerr << "No prob object data is avaliable in foundProbeData"
+                  << "\n";
+        return false;
+    }
+
+    systemBus->async_method_call(
+        [](const boost::system::error_code& ec) {
+            if (ec)
+            {
+                std::cerr << "Error setting AssetTag in FRU interface " << ec
+                          << "\n";
+            }
+        },
+        fruConn, foundPath->second, "org.freedesktop.DBus.Properties", "Set",
+        fruIntf, "PRODUCT_ASSET_TAG", std::variant<PropertyType>(newVal));
+    return true;
+}
+
 template <typename PropertyType>
 void addProperty(const std::string& name, const PropertyType& value,
                  sdbusplus::asio::dbus_interface* iface,
@@ -213,9 +257,18 @@ void addProperty(const std::string& name, const PropertyType& value,
     }
     iface->register_property(
         name, value,
-        [&systemConfiguration,
+        [name, &systemConfiguration,
          jsonPointerString{std::string(jsonPointerString)}](
             const PropertyType& newVal, PropertyType& val) {
+            if (name == "AssetTag")
+            {
+                if (!persistAssetTag(newVal, jsonPointerString))
+                {
+                    std::cerr << "error setting AssetTag in FRU interface\n";
+                    return -1;
+                }
+            }
+
             val = newVal;
             if (!setJsonFromPointer(jsonPointerString, val,
                                     systemConfiguration))
@@ -613,18 +666,35 @@ void postToDbus(const nlohmann::json& newConfiguration,
         populateInterfaceFromJson(systemConfiguration, jsonPointerPath,
                                   boardIface, boardValues, objServer);
         jsonPointerPath += "/";
+
+        std::string foundPath;
+
         // iterate through board properties
         for (const auto& [propName, propValue] : boardValues.items())
         {
+            if (propName == "FoundProbePath")
+            {
+                foundPath = propValue;
+            }
+
             if (propValue.type() == nlohmann::json::value_t::object)
             {
                 std::shared_ptr<sdbusplus::asio::dbus_interface> iface =
                     createInterface(objServer, boardName, propName,
                                     boardKeyOrig);
 
+                auto perm = sdbusplus::asio::PropertyPermission::readOnly;
+                if (propName ==
+                    "xyz.openbmc_project.Inventory.Decorator.AssetTag")
+                {
+                    foundData["foundPath"] = foundPath;
+                    mapFoundData[jsonPointerPath + propName] = foundData;
+                    perm = sdbusplus::asio::PropertyPermission::readWrite;
+                }
+
                 populateInterfaceFromJson(systemConfiguration,
                                           jsonPointerPath + propName, iface,
-                                          propValue, objServer);
+                                          propValue, objServer, perm);
             }
         }
 
diff --git a/src/perform_scan.cpp b/src/perform_scan.cpp
index 44f284c..bb0f633 100644
--- a/src/perform_scan.cpp
+++ b/src/perform_scan.cpp
@@ -543,6 +543,9 @@ void PerformScan::updateSystemConfiguration(const nlohmann::json& recordRef,
         getName.value() = deviceName;
         usedNames.insert(deviceName);
 
+        // Save the dbus path info of the device
+        record["FoundProbePath"] = path;
+
         for (auto keyPair = record.begin(); keyPair != record.end(); keyPair++)
         {
             if (keyPair.key() != "Name")
-- 
2.38.1

