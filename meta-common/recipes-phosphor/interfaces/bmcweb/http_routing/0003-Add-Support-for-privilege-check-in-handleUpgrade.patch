From b103894a7edcfb99b02a4483348bca11889c58b3 Mon Sep 17 00:00:00 2001
From: P Dheeraj Srujan Kumar <p.dheeraj.srujan.kumar@intel.com>
Date: Mon, 3 Oct 2022 16:55:53 +0000
Subject: [PATCH] Add Support for privilege check in handleUpgrade

This commit enables privilege check for user(s) in case of upgraded
connections.
Currently users with no privileges will also be able to access
Websockets connections (Ex: KVM).

Tested:
 - websocket_test.py Passed
 - Admin and Operator users are able to access KVM on WebUI
 - Readonly User was unable to access KVM on WebUI

Signed-off-by: P Dheeraj Srujan Kumar <p.dheeraj.srujan.kumar@intel.com>

%% original patch: 0003-Add-Support-for-privilege-check-in-handleUpgrade.patch
---
 http/app.hpp     |   2 +-
 http/routing.hpp | 274 +++++++++++++++++++++++++----------------------
 2 files changed, 147 insertions(+), 129 deletions(-)

diff --git a/http/app.hpp b/http/app.hpp
index a2892ced..60c2215a 100644
--- a/http/app.hpp
+++ b/http/app.hpp
@@ -58,7 +58,7 @@ class App
     App& operator=(const App&&) = delete;
 
     template <typename Adaptor>
-    void handleUpgrade(const Request& req,
+    void handleUpgrade(Request& req,
                        const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                        Adaptor&& adaptor)
     {
diff --git a/http/routing.hpp b/http/routing.hpp
index f5957e66..2eafa2af 100644
--- a/http/routing.hpp
+++ b/http/routing.hpp
@@ -1320,8 +1320,120 @@ class Router
         return findRoute;
     }
 
+    template <typename CallbackFn>
+    void authorizeUser(Request& req,
+                       const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                       BaseRule* rule, CallbackFn callback)
+    {
+        crow::connections::systemBus->async_method_call(
+            [&req, asyncResp, rule,
+             callback](const boost::system::error_code ec,
+                       const dbus::utility::DBusPropertiesMap& userInfoMap) {
+            if (ec)
+            {
+                BMCWEB_LOG_ERROR << "GetUserInfo failed...";
+                asyncResp->res.result(
+                    boost::beast::http::status::internal_server_error);
+                return;
+            }
+            std::string userRole{};
+            const bool* remoteUser = nullptr;
+            std::optional<bool> passwordExpired;
+
+            for (const auto& userInfo : userInfoMap)
+            {
+                if (userInfo.first == "UserPrivilege")
+                {
+                    const std::string* userRolePtr =
+                        std::get_if<std::string>(&userInfo.second);
+                    if (userRolePtr == nullptr)
+                    {
+                        continue;
+                    }
+                    userRole = *userRolePtr;
+                    BMCWEB_LOG_DEBUG << "userName = " << req.session->username
+                                     << " userRole = " << *userRolePtr;
+                }
+                else if (userInfo.first == "RemoteUser")
+                {
+                    remoteUser = std::get_if<bool>(&userInfo.second);
+                }
+                else if (userInfo.first == "UserPasswordExpired")
+                {
+                    const bool* passwordExpiredPtr =
+                        std::get_if<bool>(&userInfo.second);
+                    if (passwordExpiredPtr == nullptr)
+                    {
+                        continue;
+                    }
+                    passwordExpired = *passwordExpiredPtr;
+                }
+            }
+
+            if (remoteUser == nullptr)
+            {
+                BMCWEB_LOG_ERROR << "RemoteUser property missing or wrong type";
+                asyncResp->res.result(
+                    boost::beast::http::status::internal_server_error);
+                return;
+            }
+
+            if (passwordExpired == std::nullopt)
+            {
+                if (!*remoteUser)
+                {
+                    BMCWEB_LOG_ERROR
+                        << "UserPasswordExpired property is expected for"
+                           " local user but is missing or wrong type";
+                    asyncResp->res.result(
+                        boost::beast::http::status::internal_server_error);
+                    return;
+                }
+                passwordExpired = false;
+            }
+
+            // Get the userprivileges from the role
+            redfish::Privileges userPrivileges =
+                redfish::getUserPrivileges(userRole);
+
+            // Set isConfigureSelfOnly based on D-Bus results.  This
+            // ignores the results from both pamAuthenticateUser and the
+            // value from any previous use of this session.
+            req.session->isConfigureSelfOnly = *passwordExpired;
+
+            // Modifyprivileges if isConfigureSelfOnly.
+            if (req.session->isConfigureSelfOnly)
+            {
+                // Remove allprivileges except ConfigureSelf
+                userPrivileges = userPrivileges.intersection(
+                    redfish::Privileges{"ConfigureSelf"});
+                BMCWEB_LOG_DEBUG << "Operation limited to ConfigureSelf";
+            }
+
+            if (!rule->checkPrivileges(userPrivileges))
+            {
+                asyncResp->res.result(boost::beast::http::status::forbidden);
+                if (req.session->isConfigureSelfOnly)
+                {
+                    redfish::messages::passwordChangeRequired(
+                        asyncResp->res, crow::utility::urlFromPieces(
+                                            "redfish", "v1", "AccountService",
+                                            "Accounts", req.session->username));
+                }
+                return;
+            }
+
+            req.userRole = userRole;
+
+            callback();
+            },
+            "xyz.openbmc_project.User.Manager", "/xyz/openbmc_project/user",
+            "xyz.openbmc_project.User.Manager", "GetUserInfo",
+            req.session->username);
+    }
+
     template <typename Adaptor>
-    void handleUpgrade(const Request& req,
+    void handleUpgrade(Request& req,
                        const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                        Adaptor&& adaptor)
     {
@@ -1356,7 +1468,8 @@ class Router
                              << " with " << req.methodString() << "("
                              << static_cast<uint32_t>(req.method()) << ") / "
                              << rules[ruleIndex]->getMethods();
-            asyncResp->res.result(boost::beast::http::status::not_found);
+            asyncResp->res.result(
+                boost::beast::http::status::method_not_allowed);
             return;
         }
 
@@ -1364,28 +1477,32 @@ class Router
                          << "' " << static_cast<uint32_t>(req.method()) << " / "
                          << rules[ruleIndex]->getMethods();
 
-        // any uncaught exceptions become 500s
-        try
-        {
-            rules[ruleIndex]->handleUpgrade(req, asyncResp,
-                                            std::forward<Adaptor>(adaptor));
-        }
-        catch (const std::exception& e)
-        {
-            BMCWEB_LOG_ERROR << "An uncaught exception occurred: " << e.what();
-            asyncResp->res.result(
-                boost::beast::http::status::internal_server_error);
-            return;
-        }
-        catch (...)
-        {
-            BMCWEB_LOG_ERROR
-                << "An uncaught exception occurred. The type was unknown "
-                   "so no information was available.";
-            asyncResp->res.result(
-                boost::beast::http::status::internal_server_error);
-            return;
-        }
+        authorizeUser(req, asyncResp, rules[ruleIndex],
+                      [&req, asyncResp, rule(rules[ruleIndex]), &adaptor]() {
+            // any uncaught exceptions become 500s
+            try
+            {
+                rule->handleUpgrade(req, asyncResp,
+                                    std::forward<Adaptor>(adaptor));
+            }
+            catch (std::exception& e)
+            {
+                BMCWEB_LOG_ERROR << "An uncaught exception occurred: "
+                                 << e.what();
+                asyncResp->res.result(
+                    boost::beast::http::status::internal_server_error);
+                return;
+            }
+            catch (...)
+            {
+                BMCWEB_LOG_ERROR
+                    << "An uncaught exception occurred. The type was "
+                       "unknown so no information was available.";
+                asyncResp->res.result(
+                    boost::beast::http::status::internal_server_error);
+                return;
+            }
+        });
     }
 
     void handle(Request& req,
@@ -1452,110 +1569,11 @@ class Router
             return;
         }
 
-        crow::connections::systemBus->async_method_call(
-            [&req, asyncResp, &rule,
-             params](const boost::system::error_code ec,
-                     const dbus::utility::DBusPropertiesMap& userInfoMap) {
-            if (ec)
-            {
-                BMCWEB_LOG_ERROR << "GetUserInfo failed...";
-                asyncResp->res.result(
-                    boost::beast::http::status::internal_server_error);
-                return;
-            }
-            std::string userRole{};
-            const bool* remoteUser = nullptr;
-            std::optional<bool> passwordExpired;
-
-            for (const auto& userInfo : userInfoMap)
-            {
-                if (userInfo.first == "UserPrivilege")
-                {
-                    const std::string* userRolePtr =
-                        std::get_if<std::string>(&userInfo.second);
-                    if (userRolePtr == nullptr)
-                    {
-                        continue;
-                    }
-                    userRole = *userRolePtr;
-                    BMCWEB_LOG_DEBUG << "userName = " << req.session->username
-                                     << " userRole = " << *userRolePtr;
-                }
-                else if (userInfo.first == "RemoteUser")
-                {
-                    remoteUser = std::get_if<bool>(&userInfo.second);
-                }
-                else if (userInfo.first == "UserPasswordExpired")
-                {
-                    const bool* passwordExpiredPtr =
-                        std::get_if<bool>(&userInfo.second);
-                    if (passwordExpiredPtr == nullptr)
-                    {
-                        continue;
-                    }
-                    passwordExpired = *passwordExpiredPtr;
-                }
-            }
-
-            if (remoteUser == nullptr)
-            {
-                BMCWEB_LOG_ERROR << "RemoteUser property missing or wrong type";
-                asyncResp->res.result(
-                    boost::beast::http::status::internal_server_error);
-                return;
-            }
-
-            if (passwordExpired == std::nullopt)
-            {
-                if (!*remoteUser)
-                {
-                    BMCWEB_LOG_ERROR
-                        << "UserPasswordExpired property is expected for"
-                           " local user but is missing or wrong type";
-                    asyncResp->res.result(
-                        boost::beast::http::status::internal_server_error);
-                    return;
-                }
-                passwordExpired = false;
-            }
-
-            // Get the user's privileges from the role
-            redfish::Privileges userPrivileges =
-                redfish::getUserPrivileges(userRole);
-
-            // Set isConfigureSelfOnly based on D-Bus results.  This
-            // ignores the results from both pamAuthenticateUser and the
-            // value from any previous use of this session.
-            req.session->isConfigureSelfOnly = *passwordExpired;
-
-            // Modify privileges if isConfigureSelfOnly.
-            if (req.session->isConfigureSelfOnly)
-            {
-                // Remove all privileges except ConfigureSelf
-                userPrivileges = userPrivileges.intersection(
-                    redfish::Privileges{"ConfigureSelf"});
-                BMCWEB_LOG_DEBUG << "Operation limited to ConfigureSelf";
-            }
-
-            if (!rule.checkPrivileges(userPrivileges))
-            {
-                asyncResp->res.result(boost::beast::http::status::forbidden);
-                if (req.session->isConfigureSelfOnly)
-                {
-                    redfish::messages::passwordChangeRequired(
-                        asyncResp->res, crow::utility::urlFromPieces(
-                                            "redfish", "v1", "AccountService",
-                                            "Accounts", req.session->username));
-                }
-                return;
-            }
-
-            req.userRole = userRole;
-            rule.handle(req, asyncResp, params);
-            },
-            "xyz.openbmc_project.User.Manager", "/xyz/openbmc_project/user",
-            "xyz.openbmc_project.User.Manager", "GetUserInfo",
-            req.session->username);
+        authorizeUser(req, asyncResp, foundRoute.route.rule,
+                      [&req, asyncResp, rule(foundRoute.route.rule),
+                       routingParam(params)]() {
+            rule->handle(req, asyncResp, routingParam);
+        });
     }
 
     void debugPrint()
-- 
2.17.1

