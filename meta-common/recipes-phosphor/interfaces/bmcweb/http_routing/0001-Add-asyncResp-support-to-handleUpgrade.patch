From 281797132b1afe6790dcec6fa22005b8beb660e1 Mon Sep 17 00:00:00 2001
From: P Dheeraj Srujan Kumar <p.dheeraj.srujan.kumar@intel.com>
Date: Mon, 18 Oct 2021 22:45:37 +0530
Subject: [PATCH] Add asyncResp support to handleUpgrade

This commit enables paasing down the asyncResp (of the connection) to
the handler of upgraded connections. This is already in place for normal
requests (i.e. Class Router -> handle())

This change would enable any async calls that would be required during
upgrade of the connection. For example, as on today, we have only
Authentication of user in place for upgraded connection, but not
Authorization. So, this asyncResp could further be used for such dbus
calls to return informative response. This could also enable further OEM
checks during upgrade of the connection.

This commit updates the signature of all the handleUpgrade() functions
present in router.hpp to take in asyncResp object instead of normal
response.

This commit further adds an additional parametric constructor in the
Response class to enable constructing a Response by taking in
websocket::response_type object (used in websocket.hpp)

Tested :
 - websocket_test.py Passed
 - KVM was functional in WebUI.
 - POST to /redfish/v1/EventService/Subscriptions/SSE returned an error
   message as expected and the connection was kept alive.
 - GET on /redfish/v1/EventService/Subscriptions/SSE (SSE subscription)
   was successful. The existing connection was successfully closed and
   upgraded to SSE connection.

Change-Id: I1c6c91f126b734e1b5573d5ef204fe2bf6ed6c26
Signed-off-by: P Dheeraj Srujan Kumar <p.dheeraj.srujan.kumar@intel.com>
Signed-off-by: Abhishek Patel <Abhishek.Patel@ibm.com>
Signed-off-by: Gayathri Leburu <gayathri.leburu@intel.com>

---
 http/app.hpp             |  6 +++--
 http/http_connection.hpp | 26 ++++++++++++++++---
 http/http_response.hpp   |  3 +++
 http/routing.hpp         | 54 +++++++++++++++++++++-------------------
 http/websocket.hpp       |  7 +++---
 5 files changed, 62 insertions(+), 34 deletions(-)

diff --git a/http/app.hpp b/http/app.hpp
index d3afe60f..a2892ced 100644
--- a/http/app.hpp
+++ b/http/app.hpp
@@ -58,9 +58,11 @@ class App
     App& operator=(const App&&) = delete;
 
     template <typename Adaptor>
-    void handleUpgrade(const Request& req, Response& res, Adaptor&& adaptor)
+    void handleUpgrade(const Request& req,
+                       const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                       Adaptor&& adaptor)
     {
-        router.handleUpgrade(req, res, std::forward<Adaptor>(adaptor));
+        router.handleUpgrade(req, asyncResp, std::forward<Adaptor>(adaptor));
     }
 
     void handle(Request& req,
diff --git a/http/http_connection.hpp b/http/http_connection.hpp
index cbc31ce2..939b6721 100644
--- a/http/http_connection.hpp
+++ b/http/http_connection.hpp
@@ -383,10 +383,28 @@ class Connection :
         {
             BMCWEB_LOG_DEBUG << "Request: " << this << " is getting upgraded";
 
-            handler->handleUpgrade(thisReq, res, std::move(adaptor));
-            // delete lambda with self shared_ptr
-            // to enable connection destruction
-            asyncResp->res.setCompleteRequestHandler(nullptr);
+            asyncResp->res.setCompleteRequestHandler(
+                [self(shared_from_this())](crow::Response& thisRes) {
+                if (thisRes.resultInt() != 200)
+                {
+                    // When any error occurs during handle upgradation,
+                    // the result in response will be set to respective
+                    // error. By default the Result will be OK (200),
+                    // which implies successful handle upgrade. Response
+                    // needs to be sent over this connection only on
+                    // failure.
+                    self->completeRequest(thisRes);
+                    return;
+                }
+
+                // Set Complete request handler to NULL to remove
+                // the shared pointer of connection to enable
+                // connection destruction. As the connection would
+                // get upgraded, we wouldn't need this connection
+                // any longer
+                self->res.setCompleteRequestHandler(nullptr);
+            });
+            handler->handleUpgrade(thisReq, asyncResp, std::move(adaptor));
             return;
         }
         std::string_view expected =
diff --git a/http/http_response.hpp b/http/http_response.hpp
index eaeb0ab7..9f89987f 100644
--- a/http/http_response.hpp
+++ b/http/http_response.hpp
@@ -45,6 +45,9 @@ struct Response
     Response() : stringResponse(response_type{})
     {}
 
+    Response(response_type& stringRes) : stringResponse(stringRes)
+    {}
+
     Response(Response&& res) noexcept :
         stringResponse(std::move(res.stringResponse)), completed(res.completed)
     {
diff --git a/http/routing.hpp b/http/routing.hpp
index 25deb102..cd4a5c7c 100644
--- a/http/routing.hpp
+++ b/http/routing.hpp
@@ -64,19 +64,20 @@ class BaseRule
     virtual void handle(const Request& /*req*/,
                         const std::shared_ptr<bmcweb::AsyncResp>&,
                         const RoutingParams&) = 0;
-    virtual void handleUpgrade(const Request& /*req*/, Response& res,
-                               boost::asio::ip::tcp::socket&& /*adaptor*/)
+    virtual void
+        handleUpgrade(const Request& /*req*/,
+                      const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                      boost::asio::ip::tcp::socket&& /*adaptor*/)
     {
-        res.result(boost::beast::http::status::not_found);
-        res.end();
+        asyncResp->res.result(boost::beast::http::status::not_found);
     }
 #ifdef BMCWEB_ENABLE_SSL
     virtual void handleUpgrade(
-        const Request& /*req*/, Response& res,
+        const Request& /*req*/,
+        const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
         boost::beast::ssl_stream<boost::asio::ip::tcp::socket>&& /*adaptor*/)
     {
-        res.result(boost::beast::http::status::not_found);
-        res.end();
+        asyncResp->res.result(boost::beast::http::status::not_found);
     }
 #endif
 
@@ -354,7 +355,8 @@ class WebSocketRule : public BaseRule
         asyncResp->res.result(boost::beast::http::status::not_found);
     }
 
-    void handleUpgrade(const Request& req, Response& /*res*/,
+    void handleUpgrade(const Request& req,
+                       const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                        boost::asio::ip::tcp::socket&& adaptor) override
     {
         BMCWEB_LOG_DEBUG << "Websocket handles upgrade";
@@ -364,10 +366,11 @@ class WebSocketRule : public BaseRule
                 crow::websocket::ConnectionImpl<boost::asio::ip::tcp::socket>>(
                 req, std::move(adaptor), openHandler, messageHandler,
                 closeHandler, errorHandler);
-        myConnection->start();
+        myConnection->start(asyncResp);
     }
 #ifdef BMCWEB_ENABLE_SSL
-    void handleUpgrade(const Request& req, Response& /*res*/,
+    void handleUpgrade(const Request& req,
+                       const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                        boost::beast::ssl_stream<boost::asio::ip::tcp::socket>&&
                            adaptor) override
     {
@@ -378,7 +381,7 @@ class WebSocketRule : public BaseRule
                 boost::beast::ssl_stream<boost::asio::ip::tcp::socket>>>(
                 req, std::move(adaptor), openHandler, messageHandler,
                 closeHandler, errorHandler);
-        myConnection->start();
+        myConnection->start(asyncResp);
     }
 #endif
 
@@ -439,7 +442,8 @@ class SseSocketRule : public BaseRule
         asyncResp->res.result(boost::beast::http::status::not_found);
     }
 
-    void handleUpgrade(const Request& req, Response& /*res*/,
+    void handleUpgrade(const Request& req,
+                       const std::shared_ptr<bmcweb::AsyncResp>& /*asyncResp*/,
                        boost::asio::ip::tcp::socket&& adaptor) override
     {
         std::shared_ptr<crow::SseConnectionImpl<boost::asio::ip::tcp::socket>>
@@ -449,7 +453,8 @@ class SseSocketRule : public BaseRule
         myConnection->start();
     }
 #ifdef BMCWEB_ENABLE_SSL
-    void handleUpgrade(const Request& req, Response& /*res*/,
+    void handleUpgrade(const Request& req,
+                       const std::shared_ptr<bmcweb::AsyncResp>& /*asyncResp*/,
                        boost::beast::ssl_stream<boost::asio::ip::tcp::socket>&&
                            adaptor) override
     {
@@ -1319,13 +1324,14 @@ class Router
     }
 
     template <typename Adaptor>
-    void handleUpgrade(const Request& req, Response& res, Adaptor&& adaptor)
+    void handleUpgrade(const Request& req,
+                       const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                       Adaptor&& adaptor)
     {
         std::optional<HttpVerb> verb = httpVerbFromBoost(req.method());
         if (!verb || static_cast<size_t>(*verb) >= perMethods.size())
         {
-            res.result(boost::beast::http::status::not_found);
-            res.end();
+            asyncResp->res.result(boost::beast::http::status::not_found);
             return;
         }
         PerMethod& perMethod = perMethods[static_cast<size_t>(*verb)];
@@ -1337,8 +1343,7 @@ class Router
         if (ruleIndex == 0U)
         {
             BMCWEB_LOG_DEBUG << "Cannot match rules " << req.url;
-            res.result(boost::beast::http::status::not_found);
-            res.end();
+            asyncResp->res.result(boost::beast::http::status::not_found);
             return;
         }
 
@@ -1354,8 +1359,7 @@ class Router
                              << " with " << req.methodString() << "("
                              << static_cast<uint32_t>(req.method()) << ") / "
                              << rules[ruleIndex]->getMethods();
-            res.result(boost::beast::http::status::not_found);
-            res.end();
+            asyncResp->res.result(boost::beast::http::status::not_found);
             return;
         }
 
@@ -1366,14 +1370,14 @@ class Router
         // any uncaught exceptions become 500s
         try
         {
-            rules[ruleIndex]->handleUpgrade(req, res,
+            rules[ruleIndex]->handleUpgrade(req, asyncResp,
                                             std::forward<Adaptor>(adaptor));
         }
         catch (const std::exception& e)
         {
             BMCWEB_LOG_ERROR << "An uncaught exception occurred: " << e.what();
-            res.result(boost::beast::http::status::internal_server_error);
-            res.end();
+            asyncResp->res.result(
+                boost::beast::http::status::internal_server_error);
             return;
         }
         catch (...)
@@ -1381,8 +1385,8 @@ class Router
             BMCWEB_LOG_ERROR
                 << "An uncaught exception occurred. The type was unknown "
                    "so no information was available.";
-            res.result(boost::beast::http::status::internal_server_error);
-            res.end();
+            asyncResp->res.result(
+                boost::beast::http::status::internal_server_error);
             return;
         }
     }
diff --git a/http/websocket.hpp b/http/websocket.hpp
index 677e02e6..beda2700 100644
--- a/http/websocket.hpp
+++ b/http/websocket.hpp
@@ -95,7 +95,7 @@ class ConnectionImpl : public Connection
             ws.get_executor().context());
     }
 
-    void start()
+    void start(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
     {
         BMCWEB_LOG_DEBUG << "starting connection " << this;
 
@@ -104,8 +104,8 @@ class ConnectionImpl : public Connection
         std::string_view protocol = req[bf::sec_websocket_protocol];
 
         ws.set_option(boost::beast::websocket::stream_base::decorator(
-            [session{session}, protocol{std::string(protocol)}](
-                boost::beast::websocket::response_type& m) {
+            [session{session}, protocol{std::string(protocol)},
+             asyncResp](boost::beast::websocket::response_type& m) {
 
 #ifndef BMCWEB_INSECURE_DISABLE_CSRF_PREVENTION
             if (session != nullptr)
@@ -135,6 +135,7 @@ class ConnectionImpl : public Connection
             m.insert("X-XSS-Protection", "1; "
                                          "mode=block");
             m.insert("X-Content-Type-Options", "nosniff");
+            asyncResp->res = std::move(Response(m));
         }));
 
         // Perform the websocket upgrade
-- 
2.17.1

