From fdcfac4e46a23759e1d6ab180099d5ecc71babbf Mon Sep 17 00:00:00 2001
From: Przemyslaw Czarnowski <przemyslaw.hawrylewicz.czarnowski@intel.com>
Date: Tue, 5 Jul 2022 15:38:26 +0200
Subject: [PATCH 4/4] Apply async dbus API

In order to support new asynchronous dbus API for Virtual Media generic
listener for signals has been introduced.
Using AsynsResp object lifetime expanded by listener waiting for signal
response is passed to user once signal arrives.
This patch covers mounting legacy mode and unmounting both legacy and
proxy mode.

Tested:
Manually in companion with updated service signal is catched and redfish
releases connection with appropriate reply

Signed-off-by: Przemyslaw Czarnowski <przemyslaw.hawrylewicz.czarnowski@intel.com>
---
 redfish-core/lib/virtual_media.hpp | 269 ++++++++++++++++++++++-------
 1 file changed, 210 insertions(+), 59 deletions(-)

diff --git a/redfish-core/lib/virtual_media.hpp b/redfish-core/lib/virtual_media.hpp
index f154a214..19d8b7e6 100644
--- a/redfish-core/lib/virtual_media.hpp
+++ b/redfish-core/lib/virtual_media.hpp
@@ -16,14 +16,21 @@
 #pragma once
 
 #include "async_resp.hpp"
+#include "logging.hpp"
 
 #include <account_service.hpp>
 #include <app.hpp>
+#include <boost/asio/error.hpp>
+#include <boost/asio/io_context.hpp>
+#include <boost/asio/steady_timer.hpp>
+#include <boost/container/flat_map.hpp>
 #include <boost/process/async_pipe.hpp>
 #include <boost/type_traits/has_dereference.hpp>
 #include <boost/url/url_view.hpp>
+#include <dbus_singleton.hpp>
 #include <query.hpp>
 #include <registries/privilege_registry.hpp>
+#include <sdbusplus/bus/match.hpp>
 #include <sdbusplus/message/native_types.hpp>
 #include <utils/json_utils.hpp>
 
@@ -33,6 +40,15 @@ namespace redfish
 static constexpr const char* legacyMode = "Legacy";
 static constexpr const char* proxyMode = "Proxy";
 
+std::string getModeName(bool isLegacy)
+{
+    if (isLegacy)
+    {
+        return legacyMode;
+    }
+    return proxyMode;
+}
+
 std::optional<std::string>
     parseObjectPathAndGetMode(const sdbusplus::message::object_path& itemPath,
                               const std::string& resName)
@@ -751,6 +767,106 @@ class Pipe
     Buffer buffer;
 };
 
+/**
+ * @brief holder for dbus signal matchers
+ */
+struct MatchWrapper
+{
+    void stop()
+    {
+        timer->cancel();
+        matcher = std::nullopt;
+    }
+
+    std::optional<sdbusplus::bus::match::match> matcher{};
+    std::optional<boost::asio::steady_timer> timer;
+};
+
+/**
+ * @brief Function starts waiting for signal completion
+ */
+static inline std::shared_ptr<MatchWrapper>
+    doListenForCompletion(const std::string& name,
+                          const std::string& objectPath,
+                          const std::string& action, bool legacy,
+                          std::shared_ptr<bmcweb::AsyncResp> asyncResp)
+{
+    BMCWEB_LOG_DEBUG << "Start Listening for completion : " << action;
+    std::string matcherString = sdbusplus::bus::match::rules::type::signal();
+
+    std::string interface =
+        std::string("xyz.openbmc_project.VirtualMedia.") + getModeName(legacy);
+
+    matcherString += sdbusplus::bus::match::rules::interface(interface);
+    matcherString += sdbusplus::bus::match::rules::member("Completion");
+    matcherString += sdbusplus::bus::match::rules::sender(
+        "xyz.openbmc_project.VirtualMedia");
+    matcherString += sdbusplus::bus::match::rules::path(objectPath);
+
+    auto matchWrapper = std::make_shared<MatchWrapper>();
+    auto matchHandler = [asyncResp = std::move(asyncResp), name, action,
+                         objectPath,
+                         matchWrapper](sdbusplus::message::message& m) {
+        int errorCode = 0;
+        try
+        {
+            BMCWEB_LOG_INFO << "Completion signal from " << m.get_path()
+                            << " has been received";
+
+            m.read(errorCode);
+            switch (errorCode)
+            {
+                case 0: // success
+                    BMCWEB_LOG_INFO << "Signal received: Success";
+                    messages::success(asyncResp->res);
+                    break;
+                case EPERM:
+                    BMCWEB_LOG_ERROR << "Signal received: EPERM";
+                    messages::accessDenied(
+                        asyncResp->res, crow::utility::urlFromPieces(action));
+                    break;
+                case EBUSY:
+                    BMCWEB_LOG_ERROR << "Signal received: EAGAIN";
+                    messages::resourceInUse(asyncResp->res);
+                    break;
+                default:
+                    BMCWEB_LOG_ERROR << "Signal received: Other: " << errorCode;
+                    messages::operationFailed(asyncResp->res);
+                    break;
+            };
+        }
+        catch (sdbusplus::exception::SdBusError& e)
+        {
+            BMCWEB_LOG_ERROR << e.what();
+        };
+        // postpone matcher deletion after callback finishes
+        boost::asio::post(crow::connections::systemBus->get_io_context(),
+                          [name, matchWrapper = matchWrapper]()
+
+                          {
+            BMCWEB_LOG_DEBUG << "Removing matcher for " << name << " node.";
+            matchWrapper->stop();
+        });
+    };
+    matchWrapper->timer.emplace(crow::connections::systemBus->get_io_context());
+
+    // Safety valve. Clean itself after 3 minutes without signal
+    matchWrapper->timer->expires_after(std::chrono::minutes(3));
+    matchWrapper->timer->async_wait(
+        [matchWrapper](const boost::system::error_code& ec) {
+        if (ec != boost::asio::error::operation_aborted)
+        {
+            BMCWEB_LOG_DEBUG << "Timer expired! Signal did not come";
+            matchWrapper->matcher = std::nullopt;
+            return;
+        }
+    });
+
+    matchWrapper->matcher.emplace(*crow::connections::systemBus, matcherString,
+                                  matchHandler);
+    return matchWrapper;
+}
+
 /**
  * @brief Function transceives data with dbus directly.
  *
@@ -806,24 +922,46 @@ inline void doMountVmLegacy(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
             }
         });
     }
+    const std::string objectPath =
+        "/xyz/openbmc_project/VirtualMedia/Legacy/" + name;
+    const std::string action = "VirtualMedia.InsertMedia";
+    auto wrapper =
+        doListenForCompletion(name, objectPath, action, true, asyncResp);
 
     crow::connections::systemBus->async_method_call(
-        [asyncResp, secretPipe](const boost::system::error_code ec,
-                                bool success) {
+        [asyncResp, secretPipe, name, action, wrapper,
+         objectPath](const boost::system::error_code ec, bool success) {
         if (ec)
         {
             BMCWEB_LOG_ERROR << "Bad D-Bus request error: " << ec;
-            messages::internalError(asyncResp->res);
+            if (ec == boost::system::errc::device_or_resource_busy)
+            {
+                messages::resourceInUse(asyncResp->res);
+            }
+            else if (ec == boost::system::errc::permission_denied)
+            {
+                messages::accessDenied(
+                    asyncResp->res,
+                    crow::utility::urlFromPieces("redfish", "v1", "Managers",
+                                                 "bmc", "VirtualMedia", name,
+                                                 "Actions", action));
+            }
+            else
+            {
+                messages::internalError(asyncResp->res);
+            }
+            wrapper->stop();
+            return;
         }
-        else if (!success)
+        if (!success)
         {
             BMCWEB_LOG_ERROR << "Service responded with error";
-            messages::generalError(asyncResp->res);
+            messages::operationFailed(asyncResp->res);
+            wrapper->stop();
         }
         },
-        service, "/xyz/openbmc_project/VirtualMedia/Legacy/" + name,
-        "xyz.openbmc_project.VirtualMedia.Legacy", "Mount", imageUrl, rw,
-        unixFd);
+        service, objectPath, "xyz.openbmc_project.VirtualMedia.Legacy", "Mount",
+        imageUrl, rw, unixFd);
 }
 
 /**
@@ -835,38 +973,48 @@ inline void doEjectAction(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                           const std::string& service, const std::string& name,
                           bool legacy)
 {
+    const std::string vmMode = getModeName(legacy);
+    const std::string objectPath =
+        "/xyz/openbmc_project/VirtualMedia/" + vmMode + "/" + name;
+    const std::string ifaceName = "xyz.openbmc_project.VirtualMedia." + vmMode;
+    std::string action = "VirtualMedia.Eject";
 
-    // Legacy mount requires parameter with image
-    if (legacy)
-    {
-        crow::connections::systemBus->async_method_call(
-            [asyncResp](const boost::system::error_code ec) {
-            if (ec)
-            {
-                BMCWEB_LOG_ERROR << "Bad D-Bus request error: " << ec;
+    auto wrapper =
+        doListenForCompletion(name, objectPath, action, legacy, asyncResp);
 
-                messages::internalError(asyncResp->res);
-                return;
+    crow::connections::systemBus->async_method_call(
+        [asyncResp, name, action, objectPath,
+         wrapper](const boost::system::error_code ec, bool success) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR << "Bad D-Bus request error: " << ec;
+            if (ec == boost::system::errc::device_or_resource_busy)
+            {
+                messages::resourceInUse(asyncResp->res);
             }
-            },
-            service, "/xyz/openbmc_project/VirtualMedia/Legacy/" + name,
-            "xyz.openbmc_project.VirtualMedia.Legacy", "Unmount");
-    }
-    else // proxy
-    {
-        crow::connections::systemBus->async_method_call(
-            [asyncResp](const boost::system::error_code ec) {
-            if (ec)
+            else if (ec == boost::system::errc::permission_denied)
+            {
+                messages::accessDenied(
+                    asyncResp->res,
+                    crow::utility::urlFromPieces("redfish", "v1", "Managers",
+                                                 "bmc", "VirtualMedia", name,
+                                                 "Actions", action));
+            }
+            else
             {
-                BMCWEB_LOG_ERROR << "Bad D-Bus request error: " << ec;
-
                 messages::internalError(asyncResp->res);
-                return;
             }
-            },
-            service, "/xyz/openbmc_project/VirtualMedia/Proxy/" + name,
-            "xyz.openbmc_project.VirtualMedia.Proxy", "Unmount");
-    }
+            wrapper->stop();
+            return;
+        }
+
+        if (!success)
+        {
+            messages::operationFailed(asyncResp->res);
+            wrapper->stop();
+        }
+        },
+        service, objectPath, ifaceName, "Unmount");
 }
 
 inline void handleManagersVirtualMediaActionInsertPost(
@@ -958,6 +1106,7 @@ inline void handleManagersVirtualMediaActionInsertPost(
                             !(*actionParams->writeProtected),
                             *actionParams->userName, *actionParams->password);
         };
+        BMCWEB_LOG_DEBUG << "Entering findAndParseObject";
         findAndParseObject(service, resName, asyncResp, std::move(handler));
         },
         "xyz.openbmc_project.ObjectMapper",
@@ -983,6 +1132,7 @@ inline void handleManagersVirtualMediaActionEject(
 
         return;
     }
+    BMCWEB_LOG_DEBUG << "Entering " << __func__ << "()...";
 
     crow::connections::systemBus->async_method_call(
         [asyncResp, resName,
@@ -993,37 +1143,38 @@ inline void handleManagersVirtualMediaActionEject(
             BMCWEB_LOG_ERROR << "ObjectMapper::GetObject call failed: " << ec2;
             messages::internalError(asyncResp->res);
 
-            if (getObjectType.empty())
-            {
-                BMCWEB_LOG_ERROR << "ObjectMapper : No Service found";
-                messages::resourceNotFound(asyncResp->res, action, resName);
-                return;
-            }
+            return;
+        }
 
-            std::string service = getObjectType.begin()->first;
-            BMCWEB_LOG_DEBUG << "GetObjectType: " << service;
+        if (getObjectType.empty())
+        {
+            BMCWEB_LOG_ERROR << "ObjectMapper : No Service found";
+            messages::resourceNotFound(asyncResp->res, action, resName);
+            return;
+        }
 
-            auto handler =
-                [action](
-                    const std::string& service2, const std::string& resName2,
-                    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp2,
-                    std::pair<sdbusplus::message::object_path,
-                              dbus::utility::DBusInteracesMap>& item) mutable {
-                auto mode =
-                    redfish::parseObjectPathAndGetMode(item.first, resName2);
+        std::string service = getObjectType.begin()->first;
+        BMCWEB_LOG_DEBUG << "GetObjectType: " << service;
 
-                if (!mode)
-                {
-                    messages::resourceNotFound(asyncResp2->res, action,
-                                               resName2);
-                    return;
-                }
+        auto handler =
+            [action](const std::string& service2, const std::string& resName2,
+                     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp2,
+                     std::pair<sdbusplus::message::object_path,
+                               dbus::utility::DBusInteracesMap>& item) mutable {
+            auto mode =
+                redfish::parseObjectPathAndGetMode(item.first, resName2);
+
+            if (!mode)
+            {
+                messages::resourceNotFound(asyncResp2->res, action, resName2);
+                return;
+            }
 
             doEjectAction(asyncResp2, service2, resName2, *mode == legacyMode);
-            };
+        };
 
-            findAndParseObject(service, resName, asyncResp, std::move(handler));
-        }
+        BMCWEB_LOG_DEBUG << "Exec fundAndParseOBject";
+        findAndParseObject(service, resName, asyncResp, std::move(handler));
         },
         "xyz.openbmc_project.ObjectMapper",
         "/xyz/openbmc_project/object_mapper",

-- 
2.35.3

