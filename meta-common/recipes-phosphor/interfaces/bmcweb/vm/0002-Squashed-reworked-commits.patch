From efdb037d84b0708249fe1bac8fa132480d649f4b Mon Sep 17 00:00:00 2001
From: Przemyslaw Czarnowski <przemyslaw.hawrylewicz.czarnowski@intel.com>
Date: Fri, 24 Jun 2022 13:47:08 +0200
Subject: [PATCH 2/4] Squashed reworked commits

After inclusion of one upstreamed commit, Ed added one patch from the
middle of series and modified it (introducing regression).
This patch(es) makes update basing on that single change adding the rest
of VM changes.

* Use actionParams struct instead of fields

Make validateParams use of actionParams (InsertMediaActionParams
structure) instead of fields one by one.

This will make possible to remove reference to crow::Response in lambda
containing vaildateParams structure.

* Postpone params validation to legacy path

Only legacy mode needs to validate parameters passed as input.
Making it before makes proxy mode return inappropriate error message.

* Use same method to parse dbus object

Introduced function checks if redfish path is valid and have service
counterpart (with appropriate endpoint name) in dbus object. Separated
function checks dbus object, and if check is successful returns VM mode
in response.

* Extract out common parts

* Rename doVmAction to doEjectAction

Simple renaming of one function

* Seal "NotConnected" usage

When media is disconnected, "NotConnected" field did not exist.
This change adds default value of this field for all code paths.

Tested:
curl -X GET https://some_addr/redfish/v1/Managers/bmc/VirtualMedia/Legacy

  "@odata.id": "/redfish/v1/Managers/bmc/VirtualMedia/Legacy",
  "@odata.type": "#VirtualMedia.v1_3_0.VirtualMedia",
  "Actions": {
    "#VirtualMedia.EjectMedia": {
      "target": "/redfish/v1/Managers/bmc/VirtualMedia/Legacy/Actions/VirtualMedia.EjectMedia"
    },
    "#VirtualMedia.InsertMedia": {
      "target": "/redfish/v1/Managers/bmc/VirtualMedia/Legacy/Actions/VirtualMedia.InsertMedia"
    }
  },
  "ConnectedVia": "NotConnected",
  "Id": "Legacy",
  "Inserted": false,
  "MediaTypes": [
    "CD",
    "USBStick"
  ],
  "Name": "Virtual Removable Media",
  "Oem": {
    "OpenBMC": {
      "@odata.type": "#OemVirtualMedia.v1_0_0.VirtualMedia"
    }
  },
  "TransferMethod": "Stream",
  "WriteProtected": true
}

- Collection:
curl "https://some_addr//redfish/v1/Managers/bmc/VirtualMedia"
- Item:
curl "https://some_addr//redfish/v1/Managers/bmc/VirtualMedia/Slot_0"
- InsertMedia:
curl -X POST
"https://some_addr//redfish/v1/Managers/bmc/VirtualMedia/Slot0/Actions/VirtualMedia,InsertMedia" -H "Content-Type: application/json" -d '{"Image":"https://some_uri", "UserName":"some_username", "Password":"some_password"}'
curl -X POST
"https://some_addr//redfish/v1/Managers/bmc/VirtualMedia/Slot0/Actions/VirtualMedia,InsertMedia" -H "Content-Type: application/json" -d '{"Image":"smb://some_uri", "UserName":"some_username", "Password":"some_password"}'
- EjectMedia:
curl -X POST "https://some_addr//redfish/v1/Managers/bmc/VirtualMedia/Slot0/Actions/VirtualMedia,EjectMedia"
---
 redfish-core/lib/virtual_media.hpp | 378 +++++++++++++++--------------
 1 file changed, 195 insertions(+), 183 deletions(-)

diff --git a/redfish-core/lib/virtual_media.hpp b/redfish-core/lib/virtual_media.hpp
index 17971dc0..492e4cd9 100644
--- a/redfish-core/lib/virtual_media.hpp
+++ b/redfish-core/lib/virtual_media.hpp
@@ -15,6 +15,8 @@
 */
 #pragma once
 
+#include "async_resp.hpp"
+
 #include <account_service.hpp>
 #include <app.hpp>
 #include <boost/process/async_pipe.hpp>
@@ -22,10 +24,87 @@
 #include <boost/url/url_view.hpp>
 #include <query.hpp>
 #include <registries/privilege_registry.hpp>
+#include <sdbusplus/message/native_types.hpp>
 #include <utils/json_utils.hpp>
 
 namespace redfish
 {
+
+static constexpr const char* legacyMode = "Legacy";
+static constexpr const char* proxyMode = "Proxy";
+
+std::optional<std::string>
+    parseObjectPathAndGetMode(const sdbusplus::message::object_path& itemPath,
+                              const std::string& resName)
+{
+    std::string thisPath = itemPath.filename();
+    BMCWEB_LOG_DEBUG << "Filename: " << itemPath.str
+                     << ", ThisPath: " << thisPath;
+
+    if (thisPath.empty())
+    {
+        return std::nullopt;
+    }
+
+    if (thisPath != resName)
+    {
+        return std::nullopt;
+    }
+
+    auto mode = itemPath.parent_path();
+    auto type = mode.parent_path();
+
+    if (mode.filename().empty() || type.filename().empty())
+    {
+        return std::nullopt;
+    }
+
+    if (type.filename() != "VirtualMedia")
+    {
+        return std::nullopt;
+    }
+
+    return {mode.filename()};
+}
+
+using CheckItemHandler =
+    std::function<void(const std::string& service, const std::string& resName,
+                       const std::shared_ptr<bmcweb::AsyncResp>&,
+                       std::pair<sdbusplus::message::object_path,
+                                 dbus::utility::DBusInteracesMap>&)>;
+
+void findAndParseObject(const std::string& service, const std::string& resName,
+                        const std::shared_ptr<bmcweb::AsyncResp>& aResp,
+                        CheckItemHandler&& handler)
+{
+    crow::connections::systemBus->async_method_call(
+        [service, resName, aResp,
+         handler](const boost::system::error_code ec,
+                  dbus::utility::ManagedObjectType& subtree) {
+        if (ec)
+        {
+            BMCWEB_LOG_DEBUG << "DBUS response error";
+
+            return;
+        }
+
+        for (auto& item : subtree)
+        {
+            auto mode = parseObjectPathAndGetMode(item.first, resName);
+            if (mode)
+            {
+                handler(service, resName, aResp, item);
+                return;
+            }
+        }
+
+        BMCWEB_LOG_DEBUG << "Parent item not found";
+        aResp->res.result(boost::beast::http::status::not_found);
+        },
+        service, "/xyz/openbmc_project/VirtualMedia",
+        "org.freedesktop.DBus.ObjectManager", "GetManagedObjects");
+}
+
 /**
  * @brief Function extracts transfer protocol name from URI.
  */
@@ -152,6 +231,7 @@ inline nlohmann::json vmItemTemplate(const std::string& name,
         "redfish", "v1", "Managers", name, "VirtualMedia", resName);
 
     item["@odata.type"] = "#VirtualMedia.v1_3_0.VirtualMedia";
+    item["ConnectedVia"] = "NotConnected";
     item["Name"] = "Virtual Removable Media";
     item["Id"] = resName;
     item["WriteProtected"] = true;
@@ -218,33 +298,15 @@ inline void getVmData(const std::shared_ptr<bmcweb::AsyncResp>& aResp,
         if (ec)
         {
             BMCWEB_LOG_DEBUG << "DBUS response error";
+            messages::internalError(aResp->res);
 
             return;
         }
 
         for (const auto& item : subtree)
         {
-            std::string thispath = item.first.filename();
-            if (thispath.empty())
-            {
-                continue;
-            }
-
-            if (thispath != resName)
-            {
-                continue;
-            }
-
-            // "Legacy"/"Proxy"
-            auto mode = item.first.parent_path();
-            // "VirtualMedia"
-            auto type = mode.parent_path();
-            if (mode.filename().empty() || type.filename().empty())
-            {
-                continue;
-            }
-
-            if (type.filename() != "VirtualMedia")
+            auto mode = parseObjectPathAndGetMode(item.first, resName);
+            if (!mode)
             {
                 continue;
             }
@@ -252,7 +314,7 @@ inline void getVmData(const std::shared_ptr<bmcweb::AsyncResp>& aResp,
             aResp->res.jsonValue = vmItemTemplate(name, resName);
 
             // Check if dbus path is Legacy type
-            if (mode.filename() == "Legacy")
+            if (*mode == legacyMode)
             {
                 aResp->res.jsonValue["Actions"]["#VirtualMedia.InsertMedia"]
                                     ["target"] = crow::utility::urlFromPieces(
@@ -358,19 +420,27 @@ inline std::string
     return imageUri;
 }
 
+struct InsertMediaActionParams
+{
+    std::string imageUrl;
+    std::optional<std::string> userName;
+    std::optional<std::string> password;
+    std::optional<std::string> transferMethod;
+    std::optional<std::string> transferProtocolType;
+    std::optional<bool> writeProtected = true;
+    std::optional<bool> inserted;
+};
+
 /**
  * @brief Function validate parameters of insert media request.
  *
  */
-inline bool
-    validateParams(crow::Response& res, std::string& imageUrl,
-                   const std::optional<bool>& inserted,
-                   const std::optional<std::string>& transferMethod,
-                   const std::optional<std::string>& transferProtocolType)
+inline bool validateParams(crow::Response& res,
+                           InsertMediaActionParams& actionParams)
 {
     BMCWEB_LOG_DEBUG << "Validation started";
     // required param imageUrl must not be empty
-    if (imageUrl.empty())
+    if (actionParams.imageUrl.empty())
     {
         BMCWEB_LOG_ERROR << "Request action parameter Image is empty.";
 
@@ -380,7 +450,7 @@ inline bool
     }
 
     // optional param inserted must be true
-    if ((inserted != std::nullopt) && !*inserted)
+    if ((actionParams.inserted != std::nullopt) && !*actionParams.inserted)
     {
         BMCWEB_LOG_ERROR
             << "Request action optional parameter Inserted must be true.";
@@ -391,7 +461,8 @@ inline bool
     }
 
     // optional param transferMethod must be stream
-    if ((transferMethod != std::nullopt) && (*transferMethod != "Stream"))
+    if ((actionParams.transferMethod != std::nullopt) &&
+        (*actionParams.transferMethod != "Stream"))
     {
         BMCWEB_LOG_ERROR << "Request action optional parameter "
                             "TransferMethod must be Stream.";
@@ -402,18 +473,18 @@ inline bool
         return false;
     }
     boost::urls::result<boost::urls::url_view> url =
-        boost::urls::parse_uri(boost::string_view(imageUrl));
+        boost::urls::parse_uri(boost::string_view(actionParams.imageUrl));
     if (!url)
     {
-        messages::actionParameterValueFormatError(res, imageUrl, "Image",
-                                                  "InsertMedia");
+        messages::actionParameterValueFormatError(res, actionParams.imageUrl,
+                                                  "Image", "InsertMedia");
         return false;
     }
     std::optional<TransferProtocol> uriTransferProtocolType =
         getTransferProtocolFromUri(*url);
 
     std::optional<TransferProtocol> paramTransferProtocolType =
-        getTransferProtocolFromParam(transferProtocolType);
+        getTransferProtocolFromParam(actionParams.transferProtocolType);
 
     // ImageUrl does not contain valid protocol type
     if (*uriTransferProtocolType == TransferProtocol::invalid)
@@ -434,8 +505,8 @@ inline bool
                             "must be provided with value from list: "
                             "(CIFS, HTTPS).";
 
-        messages::propertyValueNotInList(res, *transferProtocolType,
-                                         "TransferProtocolType");
+        messages::propertyValueNotInList(
+            res, *actionParams.transferProtocolType, "TransferProtocolType");
         return false;
     }
 
@@ -464,20 +535,19 @@ inline bool
                                 "same protocol type as protocol type "
                                 "provided with param imageUrl.";
 
-            messages::actionParameterValueTypeError(res, *transferProtocolType,
-                                                    "TransferProtocolType",
-                                                    "InsertMedia");
+            messages::actionParameterValueTypeError(
+                res, *actionParams.transferProtocolType, "TransferProtocolType",
+                "InsertMedia");
 
             return false;
         }
     }
 
-    // validation passed
-    // add protocol to URI if needed
+    // validation passed, add protocol to URI if needed
     if (uriTransferProtocolType == std::nullopt)
     {
-        imageUrl =
-            getUriWithTransferProtocol(imageUrl, *paramTransferProtocolType);
+        actionParams.imageUrl = getUriWithTransferProtocol(
+            actionParams.imageUrl, *paramTransferProtocolType);
     }
 
     return true;
@@ -641,7 +711,7 @@ class Pipe
 inline void doMountVmLegacy(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                             const std::string& service, const std::string& name,
                             const std::string& imageUrl, const bool rw,
-                            std::string&& userName, std::string&& password)
+                            std::string& userName, std::string& password)
 {
     using SecurePipe = Pipe<CredentialsProvider::SecureBuffer>;
     constexpr const size_t secretLimit = 1024;
@@ -713,9 +783,9 @@ inline void doMountVmLegacy(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
  *
  * All BMC state properties will be retrieved before sending reset request.
  */
-inline void doVmAction(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
-                       const std::string& service, const std::string& name,
-                       bool legacy)
+inline void doEjectAction(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+                          const std::string& service, const std::string& name,
+                          bool legacy)
 {
 
     // Legacy mount requires parameter with image
@@ -751,17 +821,6 @@ inline void doVmAction(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
     }
 }
 
-struct InsertMediaActionParams
-{
-    std::string imageUrl;
-    std::optional<std::string> userName;
-    std::optional<std::string> password;
-    std::optional<std::string> transferMethod;
-    std::optional<std::string> transferProtocolType;
-    std::optional<bool> writeProtected = true;
-    std::optional<bool> inserted;
-};
-
 inline void handleManagersVirtualMediaActionInsertPost(
     crow::App& app, const crow::Request& req,
     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
@@ -771,113 +830,87 @@ inline void handleManagersVirtualMediaActionInsertPost(
     {
         return;
     }
+
+    const char* action = "VirtualMedia.InsertMedia";
     if (name != "bmc")
     {
-        messages::resourceNotFound(asyncResp->res, "VirtualMedia.Insert",
-                                   resName);
+        messages::resourceNotFound(asyncResp->res, action, resName);
 
         return;
     }
-    InsertMediaActionParams actionParams;
 
-    // Read obligatory parameters (url of
-    // image)
+    std::optional<InsertMediaActionParams> actionParams =
+        InsertMediaActionParams();
+
+    // Read obligatory parameters (url of image)
     if (!json_util::readJsonAction(
-            req, asyncResp->res, "Image", actionParams.imageUrl,
-            "WriteProtected", actionParams.writeProtected, "UserName",
-            actionParams.userName, "Password", actionParams.password,
-            "Inserted", actionParams.inserted, "TransferMethod",
-            actionParams.transferMethod, "TransferProtocolType",
-            actionParams.transferProtocolType))
+            req, asyncResp->res, "Image", actionParams->imageUrl,
+            "WriteProtected", actionParams->writeProtected, "UserName",
+            actionParams->userName, "Password", actionParams->password,
+            "Inserted", actionParams->inserted, "TransferMethod",
+            actionParams->transferMethod, "TransferProtocolType",
+            actionParams->transferProtocolType))
     {
         BMCWEB_LOG_DEBUG << "Image is not provided";
-        return;
-    }
-
-    bool paramsValid = validateParams(
-        asyncResp->res, actionParams.imageUrl, actionParams.inserted,
-        actionParams.transferMethod, actionParams.transferProtocolType);
 
-    if (!paramsValid)
-    {
-        return;
+        actionParams = std::nullopt;
     }
 
     crow::connections::systemBus->async_method_call(
-        [asyncResp, actionParams,
-         resName](const boost::system::error_code ec,
-                  const dbus::utility::MapperGetObject& getObjectType) mutable {
+        [asyncResp, resName, action, actionParams](
+            const boost::system::error_code ec,
+            const dbus::utility::MapperGetObject& getObjectType) mutable {
         if (ec)
         {
             BMCWEB_LOG_ERROR << "ObjectMapper::GetObject call failed: " << ec;
-            messages::internalError(asyncResp->res);
+            messages::resourceNotFound(asyncResp->res, action, resName);
 
             return;
         }
+
         std::string service = getObjectType.begin()->first;
         BMCWEB_LOG_DEBUG << "GetObjectType: " << service;
 
-        crow::connections::systemBus->async_method_call(
-            [service, resName, actionParams,
-             asyncResp](const boost::system::error_code ec2,
-                        dbus::utility::ManagedObjectType& subtree) mutable {
-            if (ec2)
+        auto handler =
+            [actionParams,
+             action](const std::string& service2, const std::string& resName2,
+                     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp2,
+                     std::pair<sdbusplus::message::object_path,
+                               dbus::utility::DBusInteracesMap>& item) mutable {
+            auto mode = parseObjectPathAndGetMode(item.first, resName2);
+
+            if (*mode == proxyMode)
             {
-                BMCWEB_LOG_DEBUG << "DBUS response error";
+                // Not possible in proxy mode
+                BMCWEB_LOG_DEBUG << "InsertMedia not "
+                                    "allowed in proxy mode";
+                messages::resourceNotFound(asyncResp2->res, action, resName2);
 
                 return;
             }
 
-            for (const auto& object : subtree)
+            if (!actionParams)
             {
-                const std::string& path =
-                    static_cast<const std::string&>(object.first);
-
-                std::size_t lastIndex = path.rfind('/');
-                if (lastIndex == std::string::npos)
-                {
-                    continue;
-                }
-
-                lastIndex += 1;
-
-                if (path.substr(lastIndex) == resName)
-                {
-                    lastIndex = path.rfind("Proxy");
-                    if (lastIndex != std::string::npos)
-                    {
-                        // Not possible in proxy mode
-                        BMCWEB_LOG_DEBUG << "InsertMedia not "
-                                            "allowed in proxy mode";
-                        messages::resourceNotFound(asyncResp->res,
-                                                   "VirtualMedia.InsertMedia",
-                                                   resName);
+                BMCWEB_LOG_DEBUG
+                    << "ActionParams can't be empty for legacy mode";
+                messages::actionParameterMissing(asyncResp2->res, action,
+                                                 "Image");
 
-                        return;
-                    }
-
-                    lastIndex = path.rfind("Legacy");
-                    if (lastIndex == std::string::npos)
-                    {
-                        continue;
-                    }
-
-                    // manager is irrelevant for
-                    // VirtualMedia dbus calls
-                    doMountVmLegacy(asyncResp, service, resName,
-                                    actionParams.imageUrl,
-                                    !(*actionParams.writeProtected),
-                                    std::move(*actionParams.userName),
-                                    std::move(*actionParams.password));
+                return;
+            }
 
-                    return;
-                }
+            if (!validateParams(asyncResp2->res, *actionParams))
+            {
+                return;
             }
-            BMCWEB_LOG_DEBUG << "Parent item not found";
-            messages::resourceNotFound(asyncResp->res, "VirtualMedia", resName);
-            },
-            service, "/xyz/openbmc_project/VirtualMedia",
-            "org.freedesktop.DBus.ObjectManager", "GetManagedObjects");
+
+            // manager is irrelevant for VirtualMedia dbus calls
+            doMountVmLegacy(asyncResp2, service2, resName2,
+                            actionParams->imageUrl,
+                            !(*actionParams->writeProtected),
+                            *actionParams->userName, *actionParams->password);
+        };
+        findAndParseObject(service, resName, asyncResp, std::move(handler));
         },
         "xyz.openbmc_project.ObjectMapper",
         "/xyz/openbmc_project/object_mapper",
@@ -894,76 +927,55 @@ inline void handleManagersVirtualMediaActionEject(
     {
         return;
     }
+
+    const char* action = "VirtualMedia.EjectMedia";
     if (managerName != "bmc")
     {
-        messages::resourceNotFound(asyncResp->res, "VirtualMedia.Eject",
-                                   resName);
+        messages::resourceNotFound(asyncResp->res, action, resName);
 
         return;
     }
 
     crow::connections::systemBus->async_method_call(
-        [asyncResp,
-         resName](const boost::system::error_code ec2,
-                  const dbus::utility::MapperGetObject& getObjectType) {
+        [asyncResp, resName,
+         action](const boost::system::error_code ec2,
+                 const dbus::utility::MapperGetObject& getObjectType) mutable {
         if (ec2)
         {
             BMCWEB_LOG_ERROR << "ObjectMapper::GetObject call failed: " << ec2;
             messages::internalError(asyncResp->res);
 
-            return;
-        }
-        std::string service = getObjectType.begin()->first;
-        BMCWEB_LOG_DEBUG << "GetObjectType: " << service;
-
-        crow::connections::systemBus->async_method_call(
-            [resName, service, asyncResp{asyncResp}](
-                const boost::system::error_code ec,
-                const dbus::utility::ManagedObjectType& subtree) {
-            if (ec)
+            if (getObjectType.empty())
             {
-                BMCWEB_LOG_DEBUG << "DBUS response error";
-
+                BMCWEB_LOG_ERROR << "ObjectMapper : No Service found";
+                messages::resourceNotFound(asyncResp->res, action, resName);
                 return;
             }
 
-            for (const auto& object : subtree)
-            {
-                const std::string& path =
-                    static_cast<const std::string&>(object.first);
-
-                std::size_t lastIndex = path.rfind('/');
-                if (lastIndex == std::string::npos)
-                {
-                    continue;
-                }
+            std::string service = getObjectType.begin()->first;
+            BMCWEB_LOG_DEBUG << "GetObjectType: " << service;
 
-                lastIndex += 1;
+            auto handler =
+                [action](
+                    const std::string& service2, const std::string& resName2,
+                    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp2,
+                    std::pair<sdbusplus::message::object_path,
+                              dbus::utility::DBusInteracesMap>& item) mutable {
+                auto mode =
+                    redfish::parseObjectPathAndGetMode(item.first, resName2);
 
-                if (path.substr(lastIndex) == resName)
+                if (!mode)
                 {
-                    lastIndex = path.rfind("Proxy");
-                    if (lastIndex != std::string::npos)
-                    {
-                        // Proxy mode
-                        doVmAction(asyncResp, service, resName, false);
-                    }
-
-                    lastIndex = path.rfind("Legacy");
-                    if (lastIndex != std::string::npos)
-                    {
-                        // Legacy mode
-                        doVmAction(asyncResp, service, resName, true);
-                    }
-
+                    messages::resourceNotFound(asyncResp2->res, action,
+                                               resName2);
                     return;
                 }
-            }
-            BMCWEB_LOG_DEBUG << "Parent item not found";
-            messages::resourceNotFound(asyncResp->res, "VirtualMedia", resName);
-            },
-            service, "/xyz/openbmc_project/VirtualMedia",
-            "org.freedesktop.DBus.ObjectManager", "GetManagedObjects");
+
+            doEjectAction(asyncResp2, service2, resName2, *mode == legacyMode);
+            };
+
+            findAndParseObject(service, resName, asyncResp, std::move(handler));
+        }
         },
         "xyz.openbmc_project.ObjectMapper",
         "/xyz/openbmc_project/object_mapper",
-- 
2.35.3

