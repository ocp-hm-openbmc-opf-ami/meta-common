From bcd09995ffa2b6f86dcf69c9eacbc6315703acde Mon Sep 17 00:00:00 2001
From: P Dheeraj Srujan Kumar <p.dheeraj.srujan.kumar@intel.com>
Date: Mon, 11 Jul 2022 00:07:00 +0530
Subject: [PATCH] Delete Terminated Event Subscriptions

Added functionality to delete/remove event subscription(s) which are
configured to Terminate after retries.

Currently, when an Event is subscribed with Retry Policy as
"TerminateAfterRetries", the response is set to bad_gateway, but the
subscription is not removed.
This commit adds the functionality to delete terminated subscriptions by
capturing the response and calling deleteSubscription.
In order to acheive this, sendDataWithCallback() of HttpClient is used
to which the lambda to handle deletion of subscription is passed.

Tested:
 - Created a Subscription with
   DeliveryRetryPolicy: "TerminateAfterRetries"
 - Received Events successfully on Event listener
 - Once the Event listener was stopped, the Subscription was
   removed/deleted after retries.

Change-Id: I641e37b39885705d751c56bdf65e2ff25cb42790
Signed-off-by: P Dheeraj Srujan Kumar <p.dheeraj.srujan.kumar@intel.com>
Signed-off-by: Priyanka Chikane <priyanka.chikane@intel.com>
Signed-off-by: V-Sanjana <sanjana.v@intel.com>
---
 .../include/event_service_manager.hpp         | 34 +++++++++++++++++--
 1 file changed, 32 insertions(+), 2 deletions(-)

diff --git a/redfish-core/include/event_service_manager.hpp b/redfish-core/include/event_service_manager.hpp
index d0e0e497..761f265e 100644
--- a/redfish-core/include/event_service_manager.hpp
+++ b/redfish-core/include/event_service_manager.hpp
@@ -58,6 +58,9 @@ static constexpr const char* subscriptionTypeSSE = "SSE";
 static constexpr const char* eventServiceFile =
     "/var/lib/bmcweb/eventservice_config.json";
 
+std::function<void(const std::string&)> deleteTerminatedSubscription =
+    [](const std::string&) {};
+
 static constexpr const uint8_t maxNoOfSubscriptions = 20;
 static constexpr const uint8_t maxNoOfSSESubscriptions = 10;
 
@@ -417,10 +420,30 @@ class Subscription : public persistent_data::UserSubscription
             return true;
         }
 
+        std::function<void(crow::Response&)> sendEventCallback =
+            [subId(id), retryPolicy(retryPolicy),
+             deleteTerminatedSubscription(deleteTerminatedSubscription)](
+                crow::Response& res) {
+            if (res.result() == boost::beast::http::status::bad_gateway)
+            {
+                // Response is going to have bad_gateway result if the event
+                // listener was not able to receive the event even after
+                // multiple retries. This response is received only when retry
+                // policy is Suspend after retires or Terminate after reties.
+                // Call Delete subscription only when policy is terminate after
+                // retries.
+                if (retryPolicy == "TerminateAfterRetries")
+                {
+                    deleteTerminatedSubscription(subId);
+                }
+            }
+        };
+
         bool useSSL = (uriProto == "https");
         // A connection pool will be created if one does not already exist
-        client.sendData(msg, host, port, path, useSSL, httpHeaders,
-                        verifyCertificate, boost::beast::http::verb::post);
+        client.sendDataWithCallback(
+            msg, host, port, path, useSSL, verifyCertificate, httpHeaders,
+            boost::beast::http::verb::post, sendEventCallback);
         eventSeqNum++;
 
         return true;
@@ -641,6 +664,12 @@ class EventServiceManager
 
     EventServiceManager()
     {
+        // Set Lambda for deletion of terminated subscriptions
+        deleteTerminatedSubscription = [](const std::string& id) {
+            BMCWEB_LOG_DEBUG << "Deleting Terminated Subscription : " << id;
+            EventServiceManager::getInstance().deleteSubscription(id);
+        };
+
         // Load config from persist store.
         initConfig();
     }
@@ -950,6 +979,7 @@ class EventServiceManager
             return "";
         }
 
+        subValue->id = id;
         std::shared_ptr<persistent_data::UserSubscription> newSub =
             std::make_shared<persistent_data::UserSubscription>();
         newSub->id = id;
-- 
2.17.1

