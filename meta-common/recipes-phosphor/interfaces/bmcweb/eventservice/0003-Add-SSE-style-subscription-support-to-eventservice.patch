From d218e8a72f87e0fc020e2b89f18c7807c9214617 Mon Sep 17 00:00:00 2001
From: AppaRao Puli <apparao.puli@intel.com>
Date: Tue, 28 Jun 2022 10:40:11 +0000
Subject: [PATCH] Add SSE style subscription support to eventservice

This commit adds the SSE style eventservice subscription
style event. Using this, end user can subscribe for
Redfish event logs using GET on SSE usri from
browser.

URI: /redfish/v1/EventService/Subscriptions/SSE

As per redfish specification, SSE streams have these formats:
 - Metric report SSE stream
 - Event message SSE stream

It also implements the Event Service SSE stream filters support. To
reduce the amount of data streamed over EventService SSE, It supports
the $filter query parameters in SSE URI.
Below properties supportted as filters:
 - EventFormatType( Event & MetricReport)
 - MessageId
 - RegistryPrefix
 - MetricReportDefinition

For more details, refer Redfish specification section 13.5.2

Tested:
 Created SSE stream with different filters and observed
 desired events on SSE stream client(browser), some examples
 - From Browser did GET on above SSE URI and
   generated some Redfish event logs(power cycle)
   and saw redfish event logs streaming on browser.
 - After SSE registration, Check Subscription collections
   and GET on individual subscription and saw desired
   response.
 - Ran RedfishValidation and its passed.
 - To get all Redfish events,
   URI: /redfish/v1/EventService/Subscriptions/SSE?$filter=(EventFormatType%20eq%20Event)
 - To get Redfish events with RegistryPrefix "OpenBMC"
   URI: /redfish/v1/EventService/Subscriptions/SSE?$filter=(RegistryPrefix%20eq%20OpenBMC)
 - To get only DC power of Events,
   URI: /redfish/v1/EventService/Subscriptions/SSE?$filter=(EventFormatType%20eq%20Event)%20and%20(MessageId%20eq%20DCPowerOff)

Change-Id: I7f4b7a34974080739c4ba968ed570489af0474de
Signed-off-by: AppaRao Puli <apparao.puli@linux.intel.com>
Signed-off-by: P Dheeraj Srujan Kumar <p.dheeraj.srujan.kumar@intel.com>
Signed-off-by: AppaRao Puli <apparao.puli@intel.com>
Signed-off-by: V-Sanjana <sanjana.v@intel.com>
---
 http/http_connection.hpp                      |  11 +-
 include/eventservice_sse.hpp                  | 210 ++++++++++++++++++
 redfish-core/include/error_messages.hpp       |   9 +
 .../include/event_service_manager.hpp         | 133 ++++++++---
 redfish-core/include/server_sent_events.hpp   |  16 ++
 redfish-core/lib/event_service.hpp            |   8 +-
 redfish-core/src/error_messages.cpp           |  27 +++
 src/webserver_main.cpp                        |   4 +
 8 files changed, 373 insertions(+), 45 deletions(-)
 create mode 100644 include/eventservice_sse.hpp

diff --git a/http/http_connection.hpp b/http/http_connection.hpp
index d4428df5..9807f190 100644
--- a/http/http_connection.hpp
+++ b/http/http_connection.hpp
@@ -244,11 +244,14 @@ class Connection :
             self->completeRequest(thisRes);
         });
 
-        if (thisReq.isUpgrade() &&
-            boost::iequals(
-                thisReq.getHeaderValue(boost::beast::http::field::upgrade),
-                "websocket"))
+        if ((thisReq.isUpgrade() &&
+             boost::iequals(
+                 thisReq.getHeaderValue(boost::beast::http::field::upgrade),
+                 "websocket")) ||
+            (req->url().encoded_path() == "/redfish/v1/EventService/SSE"))
         {
+            BMCWEB_LOG_DEBUG << "Request: " << this << " is getting upgraded";
+
             asyncResp->res.setCompleteRequestHandler(
                 [self(shared_from_this())](crow::Response& thisRes) {
                 if (thisRes.result() != boost::beast::http::status::ok)
diff --git a/include/eventservice_sse.hpp b/include/eventservice_sse.hpp
new file mode 100644
index 00000000..7d17b303
--- /dev/null
+++ b/include/eventservice_sse.hpp
@@ -0,0 +1,210 @@
+#pragma once
+
+#include <app.hpp>
+#include <event_service_manager.hpp>
+
+namespace redfish
+{
+namespace eventservice_sse
+{
+
+static bool createSubscription(std::shared_ptr<crow::SseConnection>& conn,
+                               const crow::Request& req, crow::Response& res)
+{
+    if ((EventServiceManager::getInstance().getNumberOfSubscriptions() >=
+         maxNoOfSubscriptions) ||
+        EventServiceManager::getInstance().getNumberOfSSESubscriptions() >=
+            maxNoOfSSESubscriptions)
+    {
+        BMCWEB_LOG_ERROR << "Max SSE subscriptions reached";
+        messages::eventSubscriptionLimitExceeded(res);
+        res.end();
+        return false;
+    }
+    BMCWEB_LOG_DEBUG << "Request query param size: "
+                     << req.url().params().size();
+
+    // EventService SSE supports only "$filter" query param.
+    if (req.url().params().size() > 1)
+    {
+        messages::invalidQueryFilter(res);
+        res.end();
+        return false;
+    }
+    std::string eventFormatType;
+    std::string queryFilters;
+    if (req.url().params().size())
+    {
+        boost::urls::params_view::iterator it =
+            req.url().params().find("$filter");
+        if (it == req.url().params().end())
+        {
+            messages::invalidQueryFilter(res);
+            res.end();
+            return false;
+        }
+        queryFilters = std::string((*it).value);
+    }
+    else
+    {
+        eventFormatType = "Event";
+    }
+
+    std::vector<std::string> msgIds;
+    std::vector<std::string> regPrefixes;
+    std::vector<std::string> mrdsArray;
+    if (!queryFilters.empty())
+    {
+        // Reading from query params.
+        bool status = readSSEQueryParams(queryFilters, eventFormatType, msgIds,
+                                         regPrefixes, mrdsArray);
+        if (!status)
+        {
+            messages::invalidQueryFilter(res);
+            res.end();
+            return false;
+        }
+
+        // RegsitryPrefix and messageIds are mutuly exclusive as per redfish
+        // specification.
+        if (!regPrefixes.empty() && !msgIds.empty())
+        {
+            messages::propertyValueConflict(res, "RegistryPrefix", "MessageId");
+            res.end();
+            return false;
+        }
+
+        if (!eventFormatType.empty())
+        {
+            if (std::find(supportedEvtFormatTypes.begin(),
+                          supportedEvtFormatTypes.end(),
+                          eventFormatType) == supportedEvtFormatTypes.end())
+            {
+                messages::propertyValueNotInList(res, eventFormatType,
+                                                 "EventFormatType");
+                res.end();
+                return false;
+            }
+        }
+        else
+        {
+            // If nothing specified, using default "Event"
+            eventFormatType = "Event";
+        }
+
+        if (!regPrefixes.empty())
+        {
+            for (const std::string& it : regPrefixes)
+            {
+                if (std::find(supportedRegPrefixes.begin(),
+                              supportedRegPrefixes.end(),
+                              it) == supportedRegPrefixes.end())
+                {
+                    messages::propertyValueNotInList(res, it, "RegistryPrefix");
+                    res.end();
+                    return false;
+                }
+            }
+        }
+
+        if (!msgIds.empty())
+        {
+            std::vector<std::string> registryPrefix;
+
+            // If no registry prefixes are mentioned, consider all supported
+            // prefixes to validate message ID
+            if (regPrefixes.empty())
+            {
+                registryPrefix.assign(supportedRegPrefixes.begin(),
+                                      supportedRegPrefixes.end());
+            }
+            else
+            {
+                registryPrefix = regPrefixes;
+            }
+
+            for (const std::string& id : msgIds)
+            {
+                bool validId = false;
+
+                // Check for Message ID in each of the selected Registry
+                for (const std::string& it : registryPrefix)
+                {
+                    const std::span<const redfish::registries::MessageEntry>
+                        registry =
+                            redfish::registries::getRegistryFromPrefix(it);
+
+                    if (std::any_of(
+                            registry.begin(), registry.end(),
+                            [&id](const redfish::registries::MessageEntry&
+                                      messageEntry) {
+                        return !id.compare(messageEntry.first);
+                            }))
+                    {
+                        validId = true;
+                        break;
+                    }
+                }
+
+                if (!validId)
+                {
+                    messages::propertyValueNotInList(res, id, "MessageIds");
+                    res.end();
+                    return false;
+                }
+            }
+        }
+    }
+
+    std::shared_ptr<redfish::Subscription> subValue =
+        std::make_shared<redfish::Subscription>(std::move(conn));
+
+    // GET on this URI means, Its SSE subscriptionType.
+    subValue->subscriptionType = subscriptionTypeSSE;
+    subValue->protocol = "Redfish";
+    subValue->retryPolicy = "TerminateAfterRetries";
+    subValue->owner = req.session->username;
+    subValue->eventFormatType = eventFormatType;
+    subValue->registryMsgIds = msgIds;
+    subValue->registryPrefixes = regPrefixes;
+    subValue->metricReportDefinitions = mrdsArray;
+
+    std::string id =
+        redfish::EventServiceManager::getInstance().addSubscription(subValue,
+                                                                    false);
+    if (id.empty())
+    {
+        messages::internalError(res);
+        res.end();
+        return false;
+    }
+    subValue->setSubscriptionId(id);
+
+    return true;
+}
+
+static void deleteSubscription(std::shared_ptr<crow::SseConnection>& conn)
+{
+    redfish::EventServiceManager::getInstance().deleteSubscription(conn);
+}
+
+inline void requestRoutes(App& app)
+{
+    BMCWEB_ROUTE(app, "/redfish/v1/EventService/SSE/")
+        .serverSentEvent()
+        .onopen([](std::shared_ptr<crow::SseConnection>& conn,
+                   const crow::Request& req, crow::Response& res) {
+            BMCWEB_LOG_DEBUG << "Connection " << conn << " opened.";
+            if (createSubscription(conn, req, res))
+            {
+                // All success, lets send SSE haader
+                conn->sendSSEHeader();
+            }
+        })
+        .onclose([](std::shared_ptr<crow::SseConnection>& conn) {
+            BMCWEB_LOG_DEBUG << "Connection " << conn << " closed";
+            deleteSubscription(conn);
+        });
+}
+} // namespace eventservice_sse
+} // namespace redfish
diff --git a/redfish-core/include/error_messages.hpp b/redfish-core/include/error_messages.hpp
index e45ea457..db70ce27 100644
--- a/redfish-core/include/error_messages.hpp
+++ b/redfish-core/include/error_messages.hpp
@@ -1070,6 +1070,15 @@ nlohmann::json operationNotAllowed();
 
 void operationNotAllowed(crow::Response& res);
 
+/**
+ * @brief Formats InvalidQueryFilter message into JSON
+ * Message body: "The requested URL contains the invalid query filters"
+ *
+ * @returns Message InvalidQueryFilter formatted to JSON */
+nlohmann::json invalidQueryFilter();
+
+void invalidQueryFilter(crow::Response& res);
+
 } // namespace messages
 
 } // namespace redfish
diff --git a/redfish-core/include/event_service_manager.hpp b/redfish-core/include/event_service_manager.hpp
index 17d5e021..47dfc07a 100644
--- a/redfish-core/include/event_service_manager.hpp
+++ b/redfish-core/include/event_service_manager.hpp
@@ -25,7 +25,7 @@
 #include "registries/base_message_registry.hpp"
 #include "registries/openbmc_message_registry.hpp"
 #include "registries/task_event_message_registry.hpp"
-#include "server_sent_events.hpp"
+#include "server_sent_event.hpp"
 #include "str_utility.hpp"
 #include "utility.hpp"
 #include "utils/json_utils.hpp"
@@ -38,6 +38,7 @@
 #include <boost/url/format.hpp>
 #include <sdbusplus/bus/match.hpp>
 
+#include <algorithm>
 #include <cstdlib>
 #include <ctime>
 #include <fstream>
@@ -53,29 +54,17 @@ using ReadingsObjType =
 static constexpr const char* eventFormatType = "Event";
 static constexpr const char* metricReportFormatType = "MetricReport";
 
+static constexpr const char* subscriptionTypeSSE = "SSE";
 static constexpr const char* eventServiceFile =
     "/var/lib/bmcweb/eventservice_config.json";
 
-namespace registries
-{
-inline std::span<const MessageEntry>
-    getRegistryFromPrefix(const std::string& registryName)
-{
-    if (task_event::header.registryPrefix == registryName)
-    {
-        return {task_event::registry};
-    }
-    if (openbmc::header.registryPrefix == registryName)
-    {
-        return {openbmc::registry};
-    }
-    if (base::header.registryPrefix == registryName)
-    {
-        return {base::registry};
-    }
-    return {openbmc::registry};
-}
-} // namespace registries
+static constexpr const uint8_t maxNoOfSubscriptions = 20;
+static constexpr const uint8_t maxNoOfSSESubscriptions = 10;
+
+static constexpr const std::array<const char*, 2> supportedEvtFormatTypes = {
+    eventFormatType, metricReportFormatType};
+static constexpr const std::array<const char*, 2> supportedRegPrefixes = {
+    "OpenBMC", "TaskEvent"};
 
 #ifndef BMCWEB_ENABLE_REDFISH_DBUS_LOG_ENTRIES
 // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
@@ -98,6 +87,23 @@ using EventLogObjectsType =
 
 namespace registries
 {
+inline std::span<const MessageEntry>
+    getRegistryFromPrefix(const std::string& registryName)
+{
+    if (task_event::header.registryPrefix == registryName)
+    {
+        return {task_event::registry};
+    }
+    if (openbmc::header.registryPrefix == registryName)
+    {
+        return {openbmc::registry};
+    }
+    if (base::header.registryPrefix == registryName)
+    {
+        return {base::registry};
+    }
+    return {openbmc::registry};
+}
 static const Message*
     getMsgFromRegistry(const std::string& messageKey,
                        const std::span<const MessageEntry>& registry)
@@ -387,11 +393,9 @@ class Subscription : public persistent_data::UserSubscription
         policy->invalidResp = retryRespHandler;
     }
 
-    explicit Subscription(
-        const std::shared_ptr<boost::asio::ip::tcp::socket>& adaptor) :
-        policy(std::make_shared<crow::ConnectionPolicy>()),
-        client(policy),
-        sseConn(std::make_shared<crow::ServerSentEvents>(adaptor))
+    Subscription(const std::shared_ptr<crow::SseConnection>& adaptor) :
+        sseConn(adaptor), eventSeqNum(1),
+        policy(std::make_shared<crow::ConnectionPolicy>()), client(policy)
     {}
 
     ~Subscription() = default;
@@ -406,16 +410,19 @@ class Subscription : public persistent_data::UserSubscription
             return false;
         }
 
+        if (sseConn != nullptr)
+        {
+            sseConn->sendEvent(std::to_string(eventSeqNum), msg);
+            eventSeqNum++;
+            return true;
+        }
+
         bool useSSL = (uriProto == "https");
         // A connection pool will be created if one does not already exist
         client.sendData(msg, host, port, path, useSSL, httpHeaders,
                         verifyCertificate, boost::beast::http::verb::post);
         eventSeqNum++;
 
-        if (sseConn != nullptr)
-        {
-            sseConn->sendData(eventSeqNum, msg);
-        }
         return true;
     }
 
@@ -567,7 +574,32 @@ class Subscription : public persistent_data::UserSubscription
         return eventSeqNum;
     }
 
+    void setSubscriptionId(const std::string& idIn)
+    {
+        BMCWEB_LOG_DEBUG << "Subscription ID: " << idIn;
+        subId = idIn;
+    }
+
+    std::string getSubscriptionId()
+    {
+        return subId;
+    }
+
+    std::optional<std::string>
+        getSubscriptionId(const std::shared_ptr<crow::SseConnection>& connPtr)
+    {
+        if (sseConn != nullptr && connPtr == sseConn)
+        {
+            BMCWEB_LOG_DEBUG << __FUNCTION__
+                             << " conn matched, subId: " << subId;
+            return subId;
+        }
+
+        return std::nullopt;
+    }
+
   private:
+    std::shared_ptr<crow::SseConnection> sseConn = nullptr;
     uint64_t eventSeqNum = 1;
     std::string host;
     uint16_t port = 0;
@@ -575,7 +607,7 @@ class Subscription : public persistent_data::UserSubscription
     crow::HttpClient client;
     std::string path;
     std::string uriProto;
-    std::shared_ptr<crow::ServerSentEvents> sseConn = nullptr;
+    std::string subId;
 
     // As per DMTF Redfish EventDestination schema, if 'VerifyCertificate'
     // is not supported by service, It shall be assumed 'false'. So setting
@@ -967,18 +999,49 @@ class EventServiceManager
             subscriptionsMap.erase(obj);
             auto obj2 = persistent_data::EventServiceStore::getInstance()
                             .subscriptionsConfigMap.find(id);
-            persistent_data::EventServiceStore::getInstance()
-                .subscriptionsConfigMap.erase(obj2);
-            updateNoOfSubscribersCount();
-            updateSubscriptionData();
+            if (obj2 != persistent_data::EventServiceStore::getInstance()
+                            .subscriptionsConfigMap.end())
+            {
+                persistent_data::EventServiceStore::getInstance()
+                    .subscriptionsConfigMap.erase(obj2);
+                updateNoOfSubscribersCount();
+                updateSubscriptionData();
+            }
         }
     }
 
+    void deleteSubscription(const std::shared_ptr<crow::SseConnection>& connPtr)
+    {
+        for (const auto& it : this->subscriptionsMap)
+        {
+            std::shared_ptr<Subscription> entry = it.second;
+            if (entry->subscriptionType == subscriptionTypeSSE)
+            {
+                std::optional<std::string> id =
+                    entry->getSubscriptionId(connPtr);
+                if (id)
+                {
+                    deleteSubscription(*id);
+                    return;
+                }
+            }
+        }
+    }
     size_t getNumberOfSubscriptions()
     {
         return subscriptionsMap.size();
     }
 
+    size_t getNumberOfSSESubscriptions() const
+    {
+        auto count = std::count_if(
+            subscriptionsMap.begin(), subscriptionsMap.end(),
+            [this](const std::pair<std::string, std::shared_ptr<Subscription>>&
+                       entry) {
+            return (entry.second->subscriptionType == subscriptionTypeSSE);
+            });
+        return static_cast<size_t>(count);
+    }
     std::vector<std::string> getAllIDs()
     {
         std::vector<std::string> idList;
diff --git a/redfish-core/include/server_sent_events.hpp b/redfish-core/include/server_sent_events.hpp
index 1592d507..75f4cd20 100644
--- a/redfish-core/include/server_sent_events.hpp
+++ b/redfish-core/include/server_sent_events.hpp
@@ -110,6 +110,14 @@ class ServerSentEvents : public std::enable_shared_from_this<ServerSentEvents>
             return;
         }
 
+        if (!sseConn)
+        {
+            BMCWEB_LOG_ERROR << "SSE connection terminated/closed.";
+            state = SseConnState::suspended;
+            checkQueue();
+            return;
+        }
+
         sseConn->async_write_some(
             boost::asio::buffer(outBuffer.data(), outBuffer.size()),
             [self(shared_from_this())](
@@ -167,6 +175,14 @@ class ServerSentEvents : public std::enable_shared_from_this<ServerSentEvents>
         response->body().size = 0;
         response->body().more = true;
 
+        if (!sseConn)
+        {
+            BMCWEB_LOG_ERROR << "SSE connection terminated/closed.";
+            state = SseConnState::suspended;
+            checkQueue();
+            return;
+        }
+
         boost::beast::http::async_write_header(
             *sseConn, *serializer,
             [this, response,
diff --git a/redfish-core/lib/event_service.hpp b/redfish-core/lib/event_service.hpp
index f74f2153..d2662dcb 100644
--- a/redfish-core/lib/event_service.hpp
+++ b/redfish-core/lib/event_service.hpp
@@ -28,10 +28,6 @@
 namespace redfish
 {
 
-static constexpr const std::array<const char*, 2> supportedEvtFormatTypes = {
-    eventFormatType, metricReportFormatType};
-static constexpr const std::array<const char*, 3> supportedRegPrefixes = {
-    "Base", "OpenBMC", "TaskEvent"};
 static constexpr const std::array<const char*, 3> supportedRetryPolicies = {
     "TerminateAfterRetries", "SuspendRetries", "RetryForever"};
 
@@ -43,8 +39,6 @@ static constexpr const std::array<const char*, 1> supportedResourceTypes = {
     "Task"};
 #endif
 
-static constexpr const uint8_t maxNoOfSubscriptions = 20;
-
 inline void requestRoutesEventService(App& app)
 {
     BMCWEB_ROUTE(app, "/redfish/v1/EventService/")
@@ -62,6 +56,8 @@ inline void requestRoutesEventService(App& app)
             "#EventService.v1_5_0.EventService";
         asyncResp->res.jsonValue["Id"] = "EventService";
         asyncResp->res.jsonValue["Name"] = "Event Service";
+        asyncResp->res.jsonValue["ServerSentEventUri"] =
+            "/redfish/v1/EventService/SSE";
         asyncResp->res.jsonValue["Subscriptions"]["@odata.id"] =
             "/redfish/v1/EventService/Subscriptions";
         asyncResp->res
diff --git a/redfish-core/src/error_messages.cpp b/redfish-core/src/error_messages.cpp
index 5f802462..16816680 100644
--- a/redfish-core/src/error_messages.cpp
+++ b/redfish-core/src/error_messages.cpp
@@ -1804,6 +1804,33 @@ nlohmann::json invalidUpload(std::string_view arg1, std::string_view arg2)
     return ret;
 }
 
+/**
+ * @internal
+ * @brief Formats InvalidQueryFilter into JSON
+ *
+ * See header file for more information
+ * @endinternal
+ */
+nlohmann::json invalidQueryFilter()
+{
+    return nlohmann::json{
+        {"@odata.type", "#Message.v1_0_0.Message"},
+        {"MessageId", "Base.1.5.0.InvalidQueryFilter"},
+        {"Message", "The requested url contains the invalid query filter."},
+        {"MessageArgs", nlohmann::json::array()},
+        {"Severity", "Warning"},
+        {"Resolution",
+         "Ensure the correct query filter is specified in requested url "
+         "and resubmit the request."}};
+}
+
+void invalidQueryFilter(crow::Response& res)
+{
+    res.result(boost::beast::http::status::bad_request);
+    addMessageToErrorJson(res.jsonValue, invalidQueryFilter());
+}
+
+
 } // namespace messages
 
 } // namespace redfish
diff --git a/src/webserver_main.cpp b/src/webserver_main.cpp
index a7f06b8e..dd19f7c7 100644
--- a/src/webserver_main.cpp
+++ b/src/webserver_main.cpp
@@ -4,6 +4,7 @@
 #include "cors_preflight.hpp"
 #include "dbus_monitor.hpp"
 #include "dbus_singleton.hpp"
+#include "eventservice_sse.hpp"
 #include "hostname_monitor.hpp"
 #include "ibm/management_console_rest.hpp"
 #include "image_upload.hpp"
@@ -81,6 +82,9 @@ static int run()
     crow::obmc_kvm::requestRoutes(app);
 #endif
 
+    // Register the EventService SSE routes
+    redfish::eventservice_sse::requestRoutes(app);
+
 #ifdef BMCWEB_ENABLE_REDFISH
     redfish::RedfishService redfish(app);
 
-- 
2.25.1

