From fb8ea028049784382030786ee3cc31107491039f Mon Sep 17 00:00:00 2001
From: AppaRao Puli <apparao.puli@intel.com>
Date: Fri, 19 May 2023 17:13:35 +0000
Subject: [PATCH] Adopt upstream ConnectionPolicy

Upstream contributors made some rework on Connection
policy for all subscriptions. This change is not
not adopted in local patches which caused the bmcweb
crash when Event/MetricReport subscriptions are made
on EventService.

Corrected the code to initailize the ConnectionPolicy
while constructing the HtppClient.

Tested:
Created Events subscription and observed events on Listener.

Created MRD's and subscribed them to EventService - Observed
Reports sent to EventListener as expected.

Created SSE subscription and Observed that Events are shown
on browser as expected.

Signed-off-by: AppaRao Puli <apparao.puli@intel.com>
Upstream-Status: Pending
---
 http/http_client.hpp                          | 12 +++++-----
 .../include/event_service_manager.hpp         | 22 ++++++++++++++++++-
 2 files changed, 27 insertions(+), 7 deletions(-)

diff --git a/http/http_client.hpp b/http/http_client.hpp
index c46c46f1..cb16638e 100644
--- a/http/http_client.hpp
+++ b/http/http_client.hpp
@@ -624,11 +624,11 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
     }
 
   public:
-    explicit ConnectionInfo(boost::asio::io_context& iocIn,
-                            const std::string& idIn,
-                            const std::string& destIPIn, uint16_t destPortIn,
-                            bool useSSLIn, bool verifyCertIn,
-                            unsigned int connIdIn) :
+    explicit ConnectionInfo(
+        boost::asio::io_context& iocIn, const std::string& idIn,
+        const std::shared_ptr<ConnectionPolicy>& connPolicyIn,
+        const std::string& destIPIn, uint16_t destPortIn, bool useSSLIn,
+        bool verifyCertIn, unsigned int connIdIn) :
         subId(idIn),
         connPolicy(connPolicyIn), host(destIPIn), port(destPortIn),
         useSSL(useSSLIn), verifyCert(verifyCertIn), connId(connIdIn),
@@ -822,7 +822,7 @@ class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
         unsigned int newId = static_cast<unsigned int>(connections.size());
 
         auto& ret = connections.emplace_back(std::make_shared<ConnectionInfo>(
-            ioc, id, destIP, destPort, useSSL, verifyCert, newId));
+            ioc, id, connPolicy, destIP, destPort, useSSL, verifyCert, newId));
 
         BMCWEB_LOG_DEBUG("Added connection {} to pool {}:{}",
                          std::to_string(connections.size() - 1), destIP,
diff --git a/redfish-core/include/event_service_manager.hpp b/redfish-core/include/event_service_manager.hpp
index 988e7545..e702b52d 100644
--- a/redfish-core/include/event_service_manager.hpp
+++ b/redfish-core/include/event_service_manager.hpp
@@ -352,6 +352,25 @@ inline bool
     return true;
 }
 
+inline boost::system::error_code subRetryHandler(unsigned int respCode)
+{
+    // Allow all response codes because we want to surface Listener
+    // issue to the client
+    BMCWEB_LOG_DEBUG("Received {} response from Listener", respCode);
+    return boost::system::errc::make_error_code(boost::system::errc::success);
+}
+
+constexpr unsigned int subReadBodyLimit = 4 * 1024 * 1024; // 4MB
+inline crow::ConnectionPolicy getSubPolicy()
+{
+    return {.maxRetryAttempts = 1,
+            .requestByteLimit = subReadBodyLimit,
+            .maxConnections = 20,
+            .retryPolicyAction = "TerminateAfterRetries",
+            .retryIntervalSecs = std::chrono::seconds(30),
+            .invalidResp = subRetryHandler};
+}
+
 class Subscription : public persistent_data::UserSubscription
 {
   public:
@@ -364,7 +383,8 @@ class Subscription : public persistent_data::UserSubscription
                  const std::string& inPath, const std::string& inUriProto,
                  boost::asio::io_context& ioc) :
         host(inHost),
-        port(inPort), policy(std::make_shared<crow::ConnectionPolicy>()),
+        port(inPort),
+        policy(std::make_shared<crow::ConnectionPolicy>(getSubPolicy())),
         path(inPath), uriProto(inUriProto)
     {
         client.emplace(ioc, policy);
-- 
2.25.1

