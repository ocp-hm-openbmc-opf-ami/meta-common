From bca49c22369457a2d5e28cafddbd61de23a52943 Mon Sep 17 00:00:00 2001
From: AppaRao Puli <apparao.puli@intel.com>
Date: Wed, 15 Mar 2023 16:13:46 +0000
Subject: [PATCH] Conditional verify certificate check in HttpClient

This commit adds the support for conditionally enable the certificate
verification for http client. Currently http client is used by
EventService for sending events. As per DMTF redfish EventDestination
schema, "VerifyCertificate" should be set false if the service is not
having support for it. So added code to set the default value to false
and parse same to http client which can be used while creating SSL
context before establishing SSL connection.

SSL context is setup during connectionPool initialization and that is
used for setting up the SSL connection at once during construction but
this will work only for first time and fails from second event sending
onwards with "asio.ssl" error.

So moved the SSL connection setup from constructor to async_connect so
that SSL connection is establishes correctly.

Tested:
 - Ran the DMTF redfish-event-listener and subscribed to EventService
for "Event" type. Created Event logs in BMC by doing DC cycle and can
see all events on redfish-event-listener side.

Signed-off-by: AppaRao Puli <apparao.puli@intel.com>
Signed-off-by: V-Sanjana <sanjana.v@intel.com>
Change-Id: Icc71049cd844a4f7ba5def3f43e0d66d522c9bbe
---
 http/http_client.hpp                          | 83 +++++++++++--------
 include/ssl_key_handler.hpp                   | 12 ++-
 .../include/event_service_manager.hpp         |  7 +-
 redfish-core/include/redfish_aggregator.hpp   |  4 +-
 4 files changed, 67 insertions(+), 39 deletions(-)

diff --git a/http/http_client.hpp b/http/http_client.hpp
index 42014990..eb717f25 100644
--- a/http/http_client.hpp
+++ b/http/http_client.hpp
@@ -134,6 +134,8 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
     std::shared_ptr<ConnectionPolicy> connPolicy;
     std::string host;
     uint16_t port;
+    bool useSSL;
+    bool verifyCert;
     uint32_t connId;
 
     // Data buffers
@@ -155,6 +157,31 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
 
     friend class ConnectionPool;
 
+    void setupSSLConn()
+    {
+        if (useSSL)
+        {
+            std::optional<boost::asio::ssl::context> sslCtx =
+                ensuressl::getSSLClientContext(verifyCert);
+
+            if (!sslCtx)
+            {
+                BMCWEB_LOG_ERROR << "prepareSSLContext failed - " << host << ":"
+                                 << port << ", id: " << std::to_string(connId);
+                // Don't retry if failure occurs while preparing SSL context
+                // such as certificate is invalid or set cipher failure or set
+                // host name failure etc... Setting conn state to sslInitFailed
+                // and connection state will be transitioned to next state
+                // depending on retry policy set by subscription.
+                state = ConnState::sslInitFailed;
+                sslConn = std::nullopt;
+                return;
+            }
+            sslConn.emplace(conn, *sslCtx);
+            setCipherSuiteTLSext();
+        }
+    }
+
     void doResolve()
     {
         state = ConnState::resolveInProgress;
@@ -183,6 +210,16 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
                          << ", id: " << std::to_string(connId);
         state = ConnState::connectInProgress;
 
+        if (useSSL)
+        {
+            setupSSLConn();
+            if (!sslConn)
+            {
+                waitAndRetry();
+                return;
+            }
+        }
+
         BMCWEB_LOG_DEBUG << "Trying to connect to: " << host << ":"
                          << std::to_string(port)
                          << ", id: " << std::to_string(connId);
@@ -587,35 +624,13 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
   public:
     explicit ConnectionInfo(
         boost::asio::io_context& iocIn, const std::string& idIn,
-        const std::shared_ptr<ConnectionPolicy>& connPolicyIn,
-        const std::string& destIPIn, uint16_t destPortIn, bool useSSL,
+        const std::string& destIPIn, uint16_t destPortIn, bool useSSLIn,
+        bool verifyCertIn,
         unsigned int connIdIn) :
         subId(idIn),
-        connPolicy(connPolicyIn), host(destIPIn), port(destPortIn),
-        connId(connIdIn), conn(iocIn), timer(iocIn)
-    {
-        if (useSSL)
-        {
-            std::optional<boost::asio::ssl::context> sslCtx =
-                ensuressl::getSSLClientContext();
-
-            if (!sslCtx)
-            {
-                BMCWEB_LOG_ERROR << "prepareSSLContext failed - " << host << ":"
-                                 << port << ", id: " << std::to_string(connId);
-                // Don't retry if failure occurs while preparing SSL context
-                // such as certificate is invalid or set cipher failure or set
-                // host name failure etc... Setting conn state to sslInitFailed
-                // and connection state will be transitioned to next state
-                // depending on retry policy set by subscription.
-                state = ConnState::sslInitFailed;
-                waitAndRetry();
-                return;
-            }
-            sslConn.emplace(conn, *sslCtx);
-            setCipherSuiteTLSext();
-        }
-    }
+        host(destIPIn), port(destPortIn), useSSL(useSSLIn),
+        verifyCert(verifyCertIn), connId(connIdIn), conn(iocIn), timer(iocIn)
+    {}
 };
 
 class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
@@ -627,6 +642,7 @@ class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
     std::string destIP;
     uint16_t destPort;
     bool useSSL;
+    bool verifyCert;
     std::vector<std::shared_ptr<ConnectionInfo>> connections;
     boost::container::devector<PendingRequest> requestQueue;
 
@@ -802,7 +818,7 @@ class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
         unsigned int newId = static_cast<unsigned int>(connections.size());
 
         auto& ret = connections.emplace_back(std::make_shared<ConnectionInfo>(
-            ioc, id, connPolicy, destIP, destPort, useSSL, newId));
+            ioc, id, destIP, destPort, useSSL, verifyCert, newId));
 
         BMCWEB_LOG_DEBUG << "Added connection "
                          << std::to_string(connections.size() - 1)
@@ -816,10 +832,10 @@ class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
     explicit ConnectionPool(
         boost::asio::io_context& iocIn, const std::string& idIn,
         const std::shared_ptr<ConnectionPolicy>& connPolicyIn,
-        const std::string& destIPIn, uint16_t destPortIn, bool useSSLIn) :
+        const std::string& destIPIn, uint16_t destPortIn, bool useSSLIn, bool verifyCertIn) :
         ioc(iocIn),
         id(idIn), connPolicy(connPolicyIn), destIP(destIPIn),
-        destPort(destPortIn), useSSL(useSSLIn)
+        destPort(destPortIn), useSSL(useSSLIn), verifyCert(verifyCertIn)
     {
         BMCWEB_LOG_DEBUG << "Initializing connection pool for " << destIP << ":"
                          << std::to_string(destPort);
@@ -861,12 +877,12 @@ class HttpClient
     // result is not required
     void sendData(std::string& data, const std::string& destIP,
                   uint16_t destPort, const std::string& destUri, bool useSSL,
-                  const boost::beast::http::fields& httpHeader,
+                  bool verifyCert, const boost::beast::http::fields& httpHeader,
                   const boost::beast::http::verb verb)
     {
         const std::function<void(Response&)> cb = genericResHandler;
         sendDataWithCallback(data, destIP, destPort, destUri, useSSL,
-                             httpHeader, verb, cb);
+                             verifyCert, httpHeader, verb, cb);
     }
 
     // Send request to destIP:destPort and use the provided callback to
@@ -874,6 +890,7 @@ class HttpClient
     void sendDataWithCallback(std::string& data, const std::string& destIP,
                               uint16_t destPort, const std::string& destUri,
                               bool useSSL,
+                              bool verifyCert,
                               const boost::beast::http::fields& httpHeader,
                               const boost::beast::http::verb verb,
                               const std::function<void(Response&)>& resHandler)
@@ -886,7 +903,7 @@ class HttpClient
         if (pool.first->second == nullptr)
         {
             pool.first->second = std::make_shared<ConnectionPool>(
-                ioc, clientKey, connPolicy, destIP, destPort, useSSL);
+                ioc, clientKey, connPolicy, destIP, destPort, useSSL, verifyCert);
         }
         // Send the data using either the existing connection pool or the newly
         // created connection pool
diff --git a/include/ssl_key_handler.hpp b/include/ssl_key_handler.hpp
index acf42f10..7ca65cd7 100644
--- a/include/ssl_key_handler.hpp
+++ b/include/ssl_key_handler.hpp
@@ -482,7 +482,8 @@ inline std::shared_ptr<boost::asio::ssl::context>
     return mSslContext;
 }
 
-inline std::optional<boost::asio::ssl::context> getSSLClientContext()
+inline std::optional<boost::asio::ssl::context>
+    getSSLClientContext(const bool verifyCertificate)
 {
     boost::asio::ssl::context sslCtx(boost::asio::ssl::context::tls_client);
 
@@ -511,8 +512,13 @@ inline std::optional<boost::asio::ssl::context> getSSLClientContext()
         return std::nullopt;
     }
 
-    // Verify the remote server's certificate
-    sslCtx.set_verify_mode(boost::asio::ssl::verify_peer, ec);
+    int mode = boost::asio::ssl::verify_peer;
+    if (!verifyCertificate)
+    {
+        mode = boost::asio::ssl::verify_none;
+    }
+    // Set Verify the remote server's certificate mode
+    sslCtx.set_verify_mode(mode, ec);
     if (ec)
     {
         BMCWEB_LOG_ERROR << "SSL context set_verify_mode failed";
diff --git a/redfish-core/include/event_service_manager.hpp b/redfish-core/include/event_service_manager.hpp
index 0b87555e..1f4b0a3a 100644
--- a/redfish-core/include/event_service_manager.hpp
+++ b/redfish-core/include/event_service_manager.hpp
@@ -408,7 +408,7 @@ class Subscription : public persistent_data::UserSubscription
         bool useSSL = (uriProto == "https");
         // A connection pool will be created if one does not already exist
         client.sendData(msg, host, port, path, useSSL, httpHeaders,
-                        boost::beast::http::verb::post);
+                        verifyCertificate, boost::beast::http::verb::post);
         eventSeqNum++;
 
         if (sseConn != nullptr)
@@ -576,6 +576,11 @@ class Subscription : public persistent_data::UserSubscription
     std::string uriProto;
     std::shared_ptr<crow::ServerSentEvents> sseConn = nullptr;
 
+    // As per DMTF Redfish EventDestination schema, if 'VerifyCertificate'
+    // is not supported by service, It shall be assumed 'false'. So setting
+    // this value to false default till EventService add support it.
+    bool verifyCertificate = false;
+
     // Check used to indicate what response codes are valid as part of our retry
     // policy.  2XX is considered acceptable
     static boost::system::error_code retryRespHandler(unsigned int respCode)
diff --git a/redfish-core/include/redfish_aggregator.hpp b/redfish-core/include/redfish_aggregator.hpp
index 1d340f77..f32f2827 100644
--- a/redfish-core/include/redfish_aggregator.hpp
+++ b/redfish-core/include/redfish_aggregator.hpp
@@ -565,7 +565,7 @@ class RedfishAggregator
         std::string data = thisReq.req.body();
         client.sendDataWithCallback(data, std::string(sat->second.host()),
                                     sat->second.port_number(), targetURI,
-                                    false /*useSSL*/, thisReq.fields(),
+                                    false /*verifyCert*/, false /*useSSL*/, thisReq.fields(),
                                     thisReq.method(), cb);
     }
 
@@ -584,7 +584,7 @@ class RedfishAggregator
             std::string data = thisReq.req.body();
             client.sendDataWithCallback(data, std::string(sat.second.host()),
                                         sat.second.port_number(), targetURI,
-                                        false /*useSSL*/, thisReq.fields(),
+                                        false /*verifyCert*/, false /*useSSL*/, thisReq.fields(),
                                         thisReq.method(), cb);
         }
     }
-- 
2.17.1

