From e22d0ce5d0e85a9235d3122ce64c5565d28e8fb0 Mon Sep 17 00:00:00 2001
From: AppaRao Puli <apparao.puli@intel.com>
Date: Thu, 25 Aug 2022 12:47:47 +0000
Subject: [PATCH] Conditional verify certificate check in HttpClient

This commit adds the support for conditionally enable the certificate
verification for http client. Currently http client is used by
EventService for sending events. As per DMTF redfish EventDestination
schema, "VerifyCertificate" should be set false if the service is not
having support for it. So added code to set the default value to false
and parse same to http client which can be used while creating SSL
context before establishing SSL connection.

SSL context is setup during connectionPool initialization and that is
used for setting up the SSL connection at once during construction but
this will work only for first time and fails from second event sending
onwards with "asio.ssl" error.

So moved the SSL connection setup from constructor to async_connect so
that SSL connection is establishes correctly.

Tested:
 - Ran the DMTF redfish-event-listener and subscribed to EventService
for "Event" type. Created Event logs in BMC by doing DC cycle and can
see all events on redfish-event-listener side.

Signed-off-by: AppaRao Puli <apparao.puli@intel.com>
Change-Id: Icc71049cd844a4f7ba5def3f43e0d66d522c9bbe
---
 http/http_client.hpp                          | 83 ++++++++++++-------
 include/ssl_key_handler.hpp                   | 12 ++-
 .../include/event_service_manager.hpp         |  7 +-
 redfish-core/include/redfish_aggregator.hpp   |  6 +-
 4 files changed, 70 insertions(+), 38 deletions(-)

diff --git a/http/http_client.hpp b/http/http_client.hpp
index 11758457..8519f8df 100644
--- a/http/http_client.hpp
+++ b/http/http_client.hpp
@@ -127,6 +127,8 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
     std::string subId;
     std::string host;
     uint16_t port;
+    bool useSSL;
+    bool verifyCert;
     uint32_t connId;
 
     // Retry policy information
@@ -152,6 +154,31 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
 
     friend class ConnectionPool;
 
+    void setupSSLConn()
+    {
+        if (useSSL)
+        {
+            std::optional<boost::asio::ssl::context> sslCtx =
+                ensuressl::getSSLClientContext(verifyCert);
+
+            if (!sslCtx)
+            {
+                BMCWEB_LOG_ERROR << "prepareSSLContext failed - " << host << ":"
+                                 << port << ", id: " << std::to_string(connId);
+                // Don't retry if failure occurs while preparing SSL context
+                // such as certificate is invalid or set cipher failure or set
+                // host name failure etc... Setting conn state to sslInitFailed
+                // and connection state will be transitioned to next state
+                // depending on retry policy set by subscription.
+                state = ConnState::sslInitFailed;
+                sslConn = std::nullopt;
+                return;
+            }
+            sslConn.emplace(conn, *sslCtx);
+            setCipherSuiteTLSext();
+        }
+    }
+
     void doResolve()
     {
         state = ConnState::resolveInProgress;
@@ -180,6 +207,16 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
                          << ", id: " << std::to_string(connId);
         state = ConnState::connectInProgress;
 
+        if (useSSL)
+        {
+            setupSSLConn();
+            if (!sslConn)
+            {
+                waitAndRetry();
+                return;
+            }
+        }
+
         BMCWEB_LOG_DEBUG << "Trying to connect to: " << host << ":"
                          << std::to_string(port)
                          << ", id: " << std::to_string(connId);
@@ -584,33 +621,12 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
     explicit ConnectionInfo(boost::asio::io_context& iocIn,
                             const std::string& idIn,
                             const std::string& destIPIn, uint16_t destPortIn,
-                            bool useSSL, unsigned int connIdIn) :
+                            bool useSSLIn, bool verifyCertIn,
+                            unsigned int connIdIn) :
         subId(idIn),
-        host(destIPIn), port(destPortIn), connId(connIdIn), conn(iocIn),
-        timer(iocIn)
-    {
-        if (useSSL)
-        {
-            std::optional<boost::asio::ssl::context> sslCtx =
-                ensuressl::getSSLClientContext();
-
-            if (!sslCtx)
-            {
-                BMCWEB_LOG_ERROR << "prepareSSLContext failed - " << host << ":"
-                                 << port << ", id: " << std::to_string(connId);
-                // Don't retry if failure occurs while preparing SSL context
-                // such as certificate is invalid or set cipher failure or set
-                // host name failure etc... Setting conn state to sslInitFailed
-                // and connection state will be transitioned to next state
-                // depending on retry policy set by subscription.
-                state = ConnState::sslInitFailed;
-                waitAndRetry();
-                return;
-            }
-            sslConn.emplace(conn, *sslCtx);
-            setCipherSuiteTLSext();
-        }
-    }
+        host(destIPIn), port(destPortIn), useSSL(useSSLIn),
+        verifyCert(verifyCertIn), connId(connIdIn), conn(iocIn), timer(iocIn)
+    {}
 };
 
 class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
@@ -621,6 +637,7 @@ class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
     std::string destIP;
     uint16_t destPort;
     bool useSSL;
+    bool verifyCert;
     std::vector<std::shared_ptr<ConnectionInfo>> connections;
     boost::container::devector<PendingRequest> requestQueue;
 
@@ -806,7 +823,7 @@ class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
         unsigned int newId = static_cast<unsigned int>(connections.size());
 
         auto& ret = connections.emplace_back(std::make_shared<ConnectionInfo>(
-            ioc, id, destIP, destPort, useSSL, newId));
+            ioc, id, destIP, destPort, useSSL, verifyCert, newId));
 
         BMCWEB_LOG_DEBUG << "Added connection "
                          << std::to_string(connections.size() - 1)
@@ -820,9 +837,10 @@ class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
     explicit ConnectionPool(boost::asio::io_context& iocIn,
                             const std::string& idIn,
                             const std::string& destIPIn, uint16_t destPortIn,
-                            bool useSSLIn) :
+                            bool useSSLIn, bool verifyCertIn) :
         ioc(iocIn),
-        id(idIn), destIP(destIPIn), destPort(destPortIn), useSSL(useSSLIn)
+        id(idIn), destIP(destIPIn), destPort(destPortIn), useSSL(useSSLIn),
+        verifyCert(verifyCertIn)
     {
         BMCWEB_LOG_DEBUG << "Initializing connection pool for " << destIP << ":"
                          << std::to_string(destPort);
@@ -867,14 +885,14 @@ class HttpClient
     // result is not required
     void sendData(std::string& data, const std::string& id,
                   const std::string& destIP, uint16_t destPort,
-                  const std::string& destUri, bool useSSL,
+                  const std::string& destUri, bool useSSL, bool verifyCert,
                   const boost::beast::http::fields& httpHeader,
                   const boost::beast::http::verb verb,
                   const std::string& retryPolicyName)
     {
         const std::function<void(Response&)> cb = genericResHandler;
         sendDataWithCallback(data, id, destIP, destPort, destUri, useSSL,
-                             httpHeader, verb, retryPolicyName, cb);
+                             verifyCert, httpHeader, verb, retryPolicyName, cb);
     }
 
     // Send request to destIP:destPort and use the provided callback to
@@ -882,6 +900,7 @@ class HttpClient
     void sendDataWithCallback(std::string& data, const std::string& id,
                               const std::string& destIP, uint16_t destPort,
                               const std::string& destUri, bool useSSL,
+                              bool verifyCert,
                               const boost::beast::http::fields& httpHeader,
                               const boost::beast::http::verb verb,
                               const std::string& retryPolicyName,
@@ -898,7 +917,7 @@ class HttpClient
             // Now actually create the ConnectionPool shared_ptr since it does
             // not already exist
             conn = std::make_shared<ConnectionPool>(ioc, id, destIP, destPort,
-                                                    useSSL);
+                                                    useSSL, verifyCert);
             BMCWEB_LOG_DEBUG << "Created connection pool for " << clientKey;
         }
         else
diff --git a/include/ssl_key_handler.hpp b/include/ssl_key_handler.hpp
index 838cd708..92950df7 100644
--- a/include/ssl_key_handler.hpp
+++ b/include/ssl_key_handler.hpp
@@ -478,7 +478,8 @@ inline std::shared_ptr<boost::asio::ssl::context>
     return mSslContext;
 }
 
-inline std::optional<boost::asio::ssl::context> getSSLClientContext()
+inline std::optional<boost::asio::ssl::context>
+    getSSLClientContext(const bool verifyCertificate)
 {
     boost::asio::ssl::context sslCtx(boost::asio::ssl::context::tls_client);
 
@@ -507,8 +508,13 @@ inline std::optional<boost::asio::ssl::context> getSSLClientContext()
         return std::nullopt;
     }
 
-    // Verify the remote server's certificate
-    sslCtx.set_verify_mode(boost::asio::ssl::verify_peer, ec);
+    int mode = boost::asio::ssl::verify_peer;
+    if (!verifyCertificate)
+    {
+        mode = boost::asio::ssl::verify_none;
+    }
+    // Set Verify the remote server's certificate mode
+    sslCtx.set_verify_mode(mode, ec);
     if (ec)
     {
         BMCWEB_LOG_ERROR << "SSL context set_verify_mode failed";
diff --git a/redfish-core/include/event_service_manager.hpp b/redfish-core/include/event_service_manager.hpp
index 7f3b43a8..e686da70 100644
--- a/redfish-core/include/event_service_manager.hpp
+++ b/redfish-core/include/event_service_manager.hpp
@@ -399,7 +399,7 @@ class Subscription : public persistent_data::UserSubscription
         bool useSSL = (uriProto == "https");
         // A connection pool will be created if one does not already exist
         crow::HttpClient::getInstance().sendData(
-            msg, id, host, port, path, useSSL, httpHeaders,
+            msg, id, host, port, path, useSSL, verifyCertificate, httpHeaders,
             boost::beast::http::verb::post, retryPolicyName);
         eventSeqNum++;
 
@@ -574,6 +574,11 @@ class Subscription : public persistent_data::UserSubscription
     std::shared_ptr<crow::ServerSentEvents> sseConn = nullptr;
     std::string retryPolicyName = "SubscriptionEvent";
 
+    // As per DMTF Redfish EventDestination schema, if 'VerifyCertificate'
+    // is not supported by service, It shall be assumed 'false'. So setting
+    // this value to false default till EventService add support it.
+    bool verifyCertificate = false;
+
     // Check used to indicate what response codes are valid as part of our retry
     // policy.  2XX is considered acceptable
     static boost::system::error_code retryRespHandler(unsigned int respCode)
diff --git a/redfish-core/include/redfish_aggregator.hpp b/redfish-core/include/redfish_aggregator.hpp
index b91498e9..c7ababc8 100644
--- a/redfish-core/include/redfish_aggregator.hpp
+++ b/redfish-core/include/redfish_aggregator.hpp
@@ -544,7 +544,8 @@ class RedfishAggregator
         crow::HttpClient::getInstance().sendDataWithCallback(
             data, id, std::string(sat->second.host()),
             sat->second.port_number(), targetURI, false /*useSSL*/,
-            thisReq.fields, thisReq.method(), retryPolicyName, cb);
+            false /*verifyCert*/, thisReq.fields, thisReq.method(),
+            retryPolicyName, cb);
     }
 
     // Forward a request for a collection URI to each known satellite BMC
@@ -563,7 +564,8 @@ class RedfishAggregator
             crow::HttpClient::getInstance().sendDataWithCallback(
                 data, id, std::string(sat.second.host()),
                 sat.second.port_number(), targetURI, false /*useSSL*/,
-                thisReq.fields, thisReq.method(), retryPolicyName, cb);
+                false /*verifyCert*/, thisReq.fields, thisReq.method(),
+                retryPolicyName, cb);
         }
     }
 
-- 
2.25.1

