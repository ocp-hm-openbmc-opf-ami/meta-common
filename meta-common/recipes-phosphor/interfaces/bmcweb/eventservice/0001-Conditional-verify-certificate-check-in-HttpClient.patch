From cda8e3ea5c0982da3aabeaa04694d3ea8467edc7 Mon Sep 17 00:00:00 2001
From: AppaRao Puli <apparao.puli@intel.com>
Date: Wed, 15 Mar 2023 16:13:46 +0000
Subject: [PATCH] Conditional verify certificate check in HttpClient

This commit adds the support for conditionally enable the certificate
verification for http client. Currently http client is used by
EventService for sending events. As per DMTF redfish EventDestination
schema, "VerifyCertificate" should be set false if the service is not
having support for it. So added code to set the default value to false
and parse same to http client which can be used while creating SSL
context before establishing SSL connection.

SSL context is setup during connectionPool initialization and that is
used for setting up the SSL connection at once during construction but
this will work only for first time and fails from second event sending
onwards with "asio.ssl" error.

So moved the SSL connection setup from constructor to async_connect so
that SSL connection is establishes correctly.

Tested:
 - Ran the DMTF redfish-event-listener and subscribed to EventService
for "Event" type. Created Event logs in BMC by doing DC cycle and can
see all events on redfish-event-listener side.

Signed-off-by: AppaRao Puli <apparao.puli@intel.com>
Signed-off-by: V-Sanjana <sanjana.v@intel.com>
Change-Id: Icc71049cd844a4f7ba5def3f43e0d66d522c9bbe
Upstream-Status: Pending
---
 http/http_client.hpp                          | 91 +++++++++++--------
 include/ssl_key_handler.hpp                   | 12 ++-
 .../include/event_service_manager.hpp         |  8 +-
 redfish-core/include/redfish_aggregator.hpp   |  6 +-
 4 files changed, 74 insertions(+), 43 deletions(-)

diff --git a/http/http_client.hpp b/http/http_client.hpp
index d82c566a..c46c46f1 100644
--- a/http/http_client.hpp
+++ b/http/http_client.hpp
@@ -134,6 +134,8 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
     std::shared_ptr<ConnectionPolicy> connPolicy;
     std::string host;
     uint16_t port;
+    bool useSSL;
+    bool verifyCert;
     uint32_t connId;
 
     // Data buffers
@@ -162,6 +164,31 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
 
     friend class ConnectionPool;
 
+    void setupSSLConn()
+    {
+        if (useSSL)
+        {
+            std::optional<boost::asio::ssl::context> sslCtx =
+                ensuressl::getSSLClientContext(verifyCert);
+
+            if (!sslCtx)
+            {
+                BMCWEB_LOG_ERROR("prepareSSLContext failed - {}:{}, id: {}",
+                                 host, port, std::to_string(connId));
+                // Don't retry if failure occurs while preparing SSL context
+                // such as certificate is invalid or set cipher failure or set
+                // host name failure etc... Setting conn state to sslInitFailed
+                // and connection state will be transitioned to next state
+                // depending on retry policy set by subscription.
+                state = ConnState::sslInitFailed;
+                sslConn = std::nullopt;
+                return;
+            }
+            sslConn.emplace(conn, *sslCtx);
+            setCipherSuiteTLSext();
+        }
+    }
+
     void doResolve()
     {
         state = ConnState::resolveInProgress;
@@ -189,6 +216,16 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
                          std::to_string(connId));
         state = ConnState::connectInProgress;
 
+        if (useSSL)
+        {
+            setupSSLConn();
+            if (!sslConn)
+            {
+                waitAndRetry();
+                return;
+            }
+        }
+
         BMCWEB_LOG_DEBUG("Trying to connect to: {}:{}, id: {}", host,
                          std::to_string(port), std::to_string(connId));
 
@@ -587,37 +624,16 @@ class ConnectionInfo : public std::enable_shared_from_this<ConnectionInfo>
     }
 
   public:
-    explicit ConnectionInfo(
-        boost::asio::io_context& iocIn, const std::string& idIn,
-        const std::shared_ptr<ConnectionPolicy>& connPolicyIn,
-        const std::string& destIPIn, uint16_t destPortIn, bool useSSL,
-        unsigned int connIdIn) :
+    explicit ConnectionInfo(boost::asio::io_context& iocIn,
+                            const std::string& idIn,
+                            const std::string& destIPIn, uint16_t destPortIn,
+                            bool useSSLIn, bool verifyCertIn,
+                            unsigned int connIdIn) :
         subId(idIn),
         connPolicy(connPolicyIn), host(destIPIn), port(destPortIn),
-        connId(connIdIn), resolver(iocIn), conn(iocIn), timer(iocIn)
-    {
-        if (useSSL)
-        {
-            std::optional<boost::asio::ssl::context> sslCtx =
-                ensuressl::getSSLClientContext();
-
-            if (!sslCtx)
-            {
-                BMCWEB_LOG_ERROR("prepareSSLContext failed - {}:{}, id: {}",
-                                 host, port, std::to_string(connId));
-                // Don't retry if failure occurs while preparing SSL context
-                // such as certificate is invalid or set cipher failure or set
-                // host name failure etc... Setting conn state to sslInitFailed
-                // and connection state will be transitioned to next state
-                // depending on retry policy set by subscription.
-                state = ConnState::sslInitFailed;
-                waitAndRetry();
-                return;
-            }
-            sslConn.emplace(conn, *sslCtx);
-            setCipherSuiteTLSext();
-        }
-    }
+        useSSL(useSSLIn), verifyCert(verifyCertIn), connId(connIdIn),
+        resolver(iocIn), conn(iocIn), timer(iocIn)
+    {}
 };
 
 class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
@@ -629,6 +645,7 @@ class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
     std::string destIP;
     uint16_t destPort;
     bool useSSL;
+    bool verifyCert;
     std::vector<std::shared_ptr<ConnectionInfo>> connections;
     boost::container::devector<PendingRequest> requestQueue;
 
@@ -805,7 +822,7 @@ class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
         unsigned int newId = static_cast<unsigned int>(connections.size());
 
         auto& ret = connections.emplace_back(std::make_shared<ConnectionInfo>(
-            ioc, id, connPolicy, destIP, destPort, useSSL, newId));
+            ioc, id, destIP, destPort, useSSL, verifyCert, newId));
 
         BMCWEB_LOG_DEBUG("Added connection {} to pool {}:{}",
                          std::to_string(connections.size() - 1), destIP,
@@ -818,10 +835,11 @@ class ConnectionPool : public std::enable_shared_from_this<ConnectionPool>
     explicit ConnectionPool(
         boost::asio::io_context& iocIn, const std::string& idIn,
         const std::shared_ptr<ConnectionPolicy>& connPolicyIn,
-        const std::string& destIPIn, uint16_t destPortIn, bool useSSLIn) :
+        const std::string& destIPIn, uint16_t destPortIn, bool useSSLIn,
+        bool verifyCertIn) :
         ioc(iocIn),
         id(idIn), connPolicy(connPolicyIn), destIP(destIPIn),
-        destPort(destPortIn), useSSL(useSSLIn)
+        destPort(destPortIn), useSSL(useSSLIn), verifyCert(verifyCertIn)
     {
         BMCWEB_LOG_DEBUG("Initializing connection pool for {}:{}", destIP,
                          std::to_string(destPort));
@@ -865,19 +883,19 @@ class HttpClient
     // result is not required
     void sendData(std::string&& data, const std::string& destIP,
                   uint16_t destPort, const std::string& destUri, bool useSSL,
-                  const boost::beast::http::fields& httpHeader,
+                  bool verifyCert, const boost::beast::http::fields& httpHeader,
                   const boost::beast::http::verb verb)
     {
         const std::function<void(Response&)> cb = genericResHandler;
         sendDataWithCallback(std::move(data), destIP, destPort, destUri, useSSL,
-                             httpHeader, verb, cb);
+                             verifyCert, httpHeader, verb, cb);
     }
 
     // Send request to destIP:destPort and use the provided callback to
     // handle the response
     void sendDataWithCallback(std::string&& data, const std::string& destIP,
                               uint16_t destPort, const std::string& destUri,
-                              bool useSSL,
+                              bool useSSL, bool verifyCert,
                               const boost::beast::http::fields& httpHeader,
                               const boost::beast::http::verb verb,
                               const std::function<void(Response&)>& resHandler)
@@ -890,7 +908,8 @@ class HttpClient
         if (pool.first->second == nullptr)
         {
             pool.first->second = std::make_shared<ConnectionPool>(
-                ioc, clientKey, connPolicy, destIP, destPort, useSSL);
+                ioc, clientKey, connPolicy, destIP, destPort, useSSL,
+                verifyCert);
         }
         // Send the data using either the existing connection pool or the newly
         // created connection pool
diff --git a/include/ssl_key_handler.hpp b/include/ssl_key_handler.hpp
index 6c243f5f..cd89acc4 100644
--- a/include/ssl_key_handler.hpp
+++ b/include/ssl_key_handler.hpp
@@ -527,7 +527,8 @@ inline std::shared_ptr<boost::asio::ssl::context>
     return mSslContext;
 }
 
-inline std::optional<boost::asio::ssl::context> getSSLClientContext()
+inline std::optional<boost::asio::ssl::context>
+    getSSLClientContext(const bool verifyCertificate)
 {
     boost::asio::ssl::context sslCtx(boost::asio::ssl::context::tls_client);
 
@@ -556,8 +557,13 @@ inline std::optional<boost::asio::ssl::context> getSSLClientContext()
         return std::nullopt;
     }
 
-    // Verify the remote server's certificate
-    sslCtx.set_verify_mode(boost::asio::ssl::verify_peer, ec);
+    int mode = boost::asio::ssl::verify_peer;
+    if (!verifyCertificate)
+    {
+        mode = boost::asio::ssl::verify_none;
+    }
+    // Set Verify the remote server's certificate mode
+    sslCtx.set_verify_mode(mode, ec);
     if (ec)
     {
         BMCWEB_LOG_ERROR("SSL context set_verify_mode failed");
diff --git a/redfish-core/include/event_service_manager.hpp b/redfish-core/include/event_service_manager.hpp
index 00d77c87..581cff57 100644
--- a/redfish-core/include/event_service_manager.hpp
+++ b/redfish-core/include/event_service_manager.hpp
@@ -390,7 +390,8 @@ class Subscription : public persistent_data::UserSubscription
         if (client)
         {
             client->sendData(std::move(msg), host, port, path, useSSL,
-                             httpHeaders, boost::beast::http::verb::post);
+                             verifyCertificate, httpHeaders,
+                             boost::beast::http::verb::post);
             return true;
         }
 
@@ -577,6 +578,11 @@ class Subscription : public persistent_data::UserSubscription
     std::string path;
     std::string uriProto;
 
+    // As per DMTF Redfish EventDestination schema, if 'VerifyCertificate'
+    // is not supported by service, It shall be assumed 'false'. So setting
+    // this value to false default till EventService add support it.
+    bool verifyCertificate = false;
+
     // Check used to indicate what response codes are valid as part of our retry
     // policy.  2XX is considered acceptable
     static boost::system::error_code retryRespHandler(unsigned int respCode)
diff --git a/redfish-core/include/redfish_aggregator.hpp b/redfish-core/include/redfish_aggregator.hpp
index 59a4eb97..5ed9be4e 100644
--- a/redfish-core/include/redfish_aggregator.hpp
+++ b/redfish-core/include/redfish_aggregator.hpp
@@ -724,7 +724,7 @@ class RedfishAggregator
         client.sendDataWithCallback(
             std::move(data), std::string(sat->second.host()),
             sat->second.port_number(), targetURI, false /*useSSL*/,
-            thisReq.fields(), thisReq.method(), cb);
+            false /*verifyCert*/, thisReq.fields(), thisReq.method(), cb);
     }
 
     // Forward a request for a collection URI to each known satellite BMC
@@ -743,7 +743,7 @@ class RedfishAggregator
             client.sendDataWithCallback(
                 std::move(data), std::string(sat.second.host()),
                 sat.second.port_number(), targetURI, false /*useSSL*/,
-                thisReq.fields(), thisReq.method(), cb);
+                false /*verifyCert*/, thisReq.fields(), thisReq.method(), cb);
         }
     }
 
@@ -768,7 +768,7 @@ class RedfishAggregator
             client.sendDataWithCallback(
                 std::move(data), std::string(sat.second.host()),
                 sat.second.port_number(), targetURI, false /*useSSL*/,
-                thisReq.fields(), thisReq.method(), cb);
+                false /*verifyCert*/, thisReq.fields(), thisReq.method(), cb);
         }
     }
 
-- 
2.25.1

