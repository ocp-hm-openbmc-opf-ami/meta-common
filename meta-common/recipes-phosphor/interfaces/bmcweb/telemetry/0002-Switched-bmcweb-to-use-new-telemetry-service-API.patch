From a47cb83da12d325b188b611773c1a8edfcee8afa Mon Sep 17 00:00:00 2001
From: Krzysztof Grobelny <krzysztof.grobelny@intel.com>
Date: Thu, 17 Jun 2021 13:37:57 +0000
Subject: [PATCH] Switched bmcweb to use new telemetry service API

Added support for multiple MetricProperties. Added support for new
parameters: CollectionTimeScope, CollectionDuration. ReadingParameters
was not yet changed in telemetry backend, instead temporary property
ReadingParametersFutureVersion was introduced. Once bmcweb is adapted to
use ReadingParametersFutureVersion this property will be renamed in
backend to ReadingParameters. Then bmcweb will change to use
ReadingParameters. Then ReadingParametersFutureVersion will be removed
from backend and everything will be exactly like described in
phosphor-dbus-interfaces without introducing breaking changes.

Related change in phosphor-dbus-interfaces [1]. This change needs to be
bumped together with [2].

Tested:
  - It is possible to create MetricReportDefinitions with multiple
    MetricProperties.
  - Stub values for new parameters are correctly passed to telemetry
    service.
  - All existing telemetry service functionalities remain unchanged.

[1]: https://github.com/openbmc/phosphor-dbus-interfaces/commit/4f9c09144b60edc015291d2c120fc5b33aa0bec2
[2]: https://gerrit.openbmc.org/c/openbmc/telemetry/+/58229

Change-Id: I2cd17069e3ea015c8f5571c29278f1d50536272a
Signed-off-by: Krzysztof Grobelny <krzysztof.grobelny@intel.com>
Signed-off-by: Lukasz Kazmierczak <lukasz.kazmierczak@intel.com>
---
 include/dbus_utility.hpp                      |   5 +-
 redfish-core/lib/metric_report_definition.hpp | 479 ++++++++++++------
 redfish-core/lib/telemetry_service.hpp        |  10 +-
 3 files changed, 327 insertions(+), 167 deletions(-)

diff --git a/include/dbus_utility.hpp b/include/dbus_utility.hpp
index 393ffe3a..94b2b64d 100644
--- a/include/dbus_utility.hpp
+++ b/include/dbus_utility.hpp
@@ -67,8 +67,9 @@ using DbusVariantType = std::variant<
     std::vector<std::tuple<std::string, std::string>>,
     std::vector<std::tuple<uint32_t, std::vector<uint32_t>>>,
     std::vector<std::tuple<uint32_t, size_t>>,
-    std::vector<std::tuple<sdbusplus::message::object_path, std::string,
-                           std::string, std::string>>
+    std::vector<std::tuple<
+      std::vector<std::tuple<sdbusplus::message::object_path, std::string>>,
+      std::string, std::string, std::string, uint64_t>>
  >;
 
 // clang-format on
diff --git a/redfish-core/lib/metric_report_definition.hpp b/redfish-core/lib/metric_report_definition.hpp
index bc1b894b..e064cd2f 100644
--- a/redfish-core/lib/metric_report_definition.hpp
+++ b/redfish-core/lib/metric_report_definition.hpp
@@ -23,41 +23,58 @@ namespace redfish
 namespace telemetry
 {
 
-using ReadingParameters =
-    std::vector<std::tuple<sdbusplus::message::object_path, std::string,
-                           std::string, std::string>>;
+using ReadingParameters = std::vector<std::tuple<
+    std::vector<std::tuple<sdbusplus::message::object_path, std::string>>,
+    std::string, std::string, std::string, uint64_t>>;
+
+std::string toRedfishReportAction(std::string_view action)
+{
+
+    if (action == "EmitsReadingsUpdate")
+    {
+        return "RedfishEvent";
+    }
+    if (action == "LogToMetricReportsCollection")
+    {
+        return "LogToMetricReportsCollection";
+    }
+    return "";
+}
+
+std::string toDbusReportAction(std::string_view action)
+{
+    if (action == "RedfishEvent")
+    {
+        return "EmitsReadingsUpdate";
+    }
+    if (action == "LogToMetricReportsCollection")
+    {
+        return "LogToMetricReportsCollection";
+    }
+    return "";
+}
 
 inline void
     fillReportDefinition(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
                          const std::string& id,
-                         const dbus::utility::DBusPropertiesMap& ret)
+                         const dbus::utility::DBusPropertiesMap& properties)
 {
-    asyncResp->res.jsonValue["@odata.type"] =
-        "#MetricReportDefinition.v1_3_0.MetricReportDefinition";
-    asyncResp->res.jsonValue["@odata.id"] =
-        crow::utility::urlFromPieces("redfish", "v1", "TelemetryService",
-                                     "MetricReportDefinitions", id)
-            .string();
-    asyncResp->res.jsonValue["Id"] = id;
-    asyncResp->res.jsonValue["Name"] = id;
-    asyncResp->res.jsonValue["MetricReport"]["@odata.id"] =
-        crow::utility::urlFromPieces("redfish", "v1", "TelemetryService",
-                                     "MetricReports", id)
-            .string();
-    asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
-    asyncResp->res.jsonValue["ReportUpdates"] = "Overwrite";
-
-    const bool* emitsReadingsUpdate = nullptr;
-    const bool* logToMetricReportsCollection = nullptr;
-    const ReadingParameters* readingParameters = nullptr;
-    const std::string* reportingType = nullptr;
-    const uint64_t* interval = nullptr;
+    std::vector<std::string> reportActions;
+    ReadingParameters readingParams;
+    std::string reportingType;
+    std::string reportUpdates;
+    std::string name;
+    uint64_t appendLimit = 0;
+    uint64_t interval = 0;
+    bool enabled = false;
+    std::vector<std::tuple<std::string, std::string>> errorMessages;
 
     const bool success = sdbusplus::unpackPropertiesNoThrow(
-        dbus_utils::UnpackErrorPrinter(), ret, "EmitsReadingsUpdate",
-        emitsReadingsUpdate, "LogToMetricReportsCollection",
-        logToMetricReportsCollection, "ReadingParameters", readingParameters,
-        "ReportingType", reportingType, "Interval", interval);
+        dbus_utils::UnpackErrorPrinter(), properties, "ReportingType",
+        reportingType, "Interval", interval, "ReportActions", reportActions,
+        "ReportUpdates", reportUpdates, "AppendLimit", appendLimit,
+        "ReadingParameters", readingParams, "Name", name, "Enabled", enabled,
+        "ErrorMessages", errorMessages);
 
     if (!success)
     {
@@ -65,78 +82,171 @@ inline void
         return;
     }
 
-    std::vector<std::string> redfishReportActions;
-    redfishReportActions.reserve(2);
-    if (emitsReadingsUpdate != nullptr && *emitsReadingsUpdate)
+    nlohmann::json::array_t redfishReportActions;
+    for (const std::string& action : reportActions)
     {
-        redfishReportActions.emplace_back("RedfishEvent");
-    }
+        std::string redfishAction = toRedfishReportAction(action);
 
-    if (logToMetricReportsCollection != nullptr &&
-        *logToMetricReportsCollection)
-    {
-        redfishReportActions.emplace_back("LogToMetricReportsCollection");
+        if (redfishAction.empty())
+        {
+            BMCWEB_LOG_ERROR << "Unknown ReportActions element: " << action;
+            messages::internalError(asyncResp->res);
+            return;
+        }
+
+        redfishReportActions.emplace_back(std::move(redfishAction));
     }
 
-    nlohmann::json metrics = nlohmann::json::array();
-    if (readingParameters != nullptr)
+    asyncResp->res.jsonValue["ReportActions"] = std::move(redfishReportActions);
+
+    nlohmann::json::array_t metrics = nlohmann::json::array();
+    for (const auto& [sensorData, collectionFunction, metricId,
+                      collectionTimeScope, collectionDuration] : readingParams)
     {
-        for (const auto& [sensorPath, operationType, metricId, metadata] :
-             *readingParameters)
+        nlohmann::json::array_t metricProperties;
+
+        for (const auto& [sensorPath, sensorMetadata] : sensorData)
         {
-            nlohmann::json::object_t metric;
-            metric["MetricId"] = metricId;
-            metric["MetricProperties"] = nlohmann::json::array_t({metadata});
-            metrics.push_back(std::move(metric));
+            metricProperties.emplace_back(sensorMetadata);
         }
+
+        nlohmann::json::object_t metric;
+        metric["MetricId"] = metricId;
+        metric["MetricProperties"] = std::move(metricProperties);
+        metric["CollectionFunction"] = collectionFunction;
+        metric["CollectionDuration"] = time_utils::toDurationString(
+            std::chrono::milliseconds(collectionDuration));
+        metric["CollectionTimeScope"] = collectionTimeScope;
+        metrics.push_back(std::move(metric));
     }
+    asyncResp->res.jsonValue["Metrics"] = std::move(metrics);
 
-    if (reportingType != nullptr)
+    if (enabled)
     {
-        asyncResp->res.jsonValue["MetricReportDefinitionType"] = *reportingType;
+        if (errorMessages.empty())
+        {
+            asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+        }
+        else
+        {
+            asyncResp->res.jsonValue["Status"]["State"] = "UnavailableOffline";
+        }
     }
-
-    if (interval != nullptr)
+    else
     {
-        asyncResp->res.jsonValue["Schedule"]["RecurrenceInterval"] =
-            time_utils::toDurationString(std::chrono::milliseconds(*interval));
+        asyncResp->res.jsonValue["Status"]["State"] = "Disabled";
     }
 
-    asyncResp->res.jsonValue["Metrics"] = metrics;
-    asyncResp->res.jsonValue["ReportActions"] = redfishReportActions;
+    asyncResp->res.jsonValue["MetricReportDefinitionEnabled"] = enabled;
+    asyncResp->res.jsonValue["AppendLimit"] = appendLimit;
+    asyncResp->res.jsonValue["ReportUpdates"] = reportUpdates;
+    asyncResp->res.jsonValue["Name"] = name;
+    asyncResp->res.jsonValue["MetricReportDefinitionType"] = reportingType;
+    asyncResp->res.jsonValue["Schedule"]["RecurrenceInterval"] =
+        time_utils::toDurationString(std::chrono::milliseconds(interval));
+    asyncResp->res.jsonValue["@odata.type"] =
+        "#MetricReportDefinition.v1_3_0.MetricReportDefinition";
+    asyncResp->res.jsonValue["@odata.id"] = crow::utility::urlFromPieces(
+        "redfish", "v1", "TelemetryService", "MetricReportDefinitions", id);
+    asyncResp->res.jsonValue["Id"] = id;
+    asyncResp->res.jsonValue["MetricReport"]["@odata.id"] =
+        crow::utility::urlFromPieces("redfish", "v1", "TelemetryService",
+                                     "MetricReports", id);
 }
 
 struct AddReportArgs
 {
-    std::string name;
-    std::string reportingType;
-    bool emitsReadingsUpdate = false;
-    bool logToMetricReportsCollection = false;
-    uint64_t interval = 0;
-    std::vector<std::pair<std::string, std::vector<std::string>>> metrics;
+    struct MetricArgs
+    {
+        std::string id;
+        std::vector<std::string> uris;
+        std::optional<std::string> collectionFunction;
+        std::optional<std::string> collectionTimeScope;
+        std::optional<uint64_t> collectionDuration;
+    };
+
+    std::optional<std::string> id;
+    std::optional<std::string> name;
+    std::optional<std::string> reportingType;
+    std::optional<std::string> reportUpdates;
+    std::optional<uint64_t> appendLimit;
+    std::optional<std::vector<std::string>> reportActions;
+    std::optional<uint64_t> interval;
+    std::optional<std::vector<MetricArgs>> metrics;
+    std::optional<bool> metricReportDefinitionEnabled;
+
+    std::vector<std::pair<std::string, dbus::utility::DbusVariantType>>
+        getProperties(
+            std::optional<telemetry::ReadingParameters> readingParams) const
+    {
+        std::vector<std::pair<std::string, dbus::utility::DbusVariantType>>
+            properties;
+
+        properties.emplace_back("Id", "TelemetryService/" + id.value_or(""));
+
+        if (name)
+        {
+            properties.emplace_back("Name", *name);
+        }
+
+        if (reportingType)
+        {
+            properties.emplace_back("ReportingType", *reportingType);
+        }
+
+        if (reportUpdates)
+        {
+            properties.emplace_back("ReportUpdates", *reportUpdates);
+        }
+
+        if (appendLimit)
+        {
+            properties.emplace_back("AppendLimit", *appendLimit);
+        }
+
+        if (reportActions)
+        {
+            properties.emplace_back("ReportActions", *reportActions);
+        }
+
+        if (interval)
+        {
+            properties.emplace_back("Interval", *interval);
+        }
+
+        if (readingParams)
+        {
+            properties.emplace_back("MetricParams", std::move(*readingParams));
+        }
+
+        if (metricReportDefinitionEnabled)
+        {
+            properties.emplace_back("Enabled", *metricReportDefinitionEnabled);
+        }
+
+        return properties;
+    }
 };
 
 inline bool toDbusReportActions(crow::Response& res,
-                                std::vector<std::string>& actions,
+                                const std::vector<std::string>& actions,
                                 AddReportArgs& args)
 {
+    args.reportActions.emplace();
+
     size_t index = 0;
-    for (auto& action : actions)
+    for (const auto& action : actions)
     {
-        if (action == "RedfishEvent")
-        {
-            args.emitsReadingsUpdate = true;
-        }
-        else if (action == "LogToMetricReportsCollection")
-        {
-            args.logToMetricReportsCollection = true;
-        }
-        else
+        std::string dbusReportAction = toDbusReportAction(action);
+
+        if (dbusReportAction.empty())
         {
             messages::propertyValueNotInList(
                 res, action, "ReportActions/" + std::to_string(index));
             return false;
         }
+
+        args.reportActions->emplace_back(std::move(dbusReportAction));
         index++;
     }
     return true;
@@ -145,37 +255,29 @@ inline bool toDbusReportActions(crow::Response& res,
 inline bool getUserParameters(crow::Response& res, const crow::Request& req,
                               AddReportArgs& args)
 {
-    std::vector<nlohmann::json> metrics;
-    std::vector<std::string> reportActions;
+    std::optional<std::vector<nlohmann::json>> metrics;
+    std::optional<std::vector<std::string>> reportActions;
     std::optional<nlohmann::json> schedule;
-    if (!json_util::readJsonPatch(req, res, "Id", args.name, "Metrics", metrics,
-                                  "MetricReportDefinitionType",
-                                  args.reportingType, "ReportActions",
-                                  reportActions, "Schedule", schedule))
-    {
-        return false;
-    }
-
-    constexpr const char* allowedCharactersInName =
-        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";
-    if (args.name.empty() || args.name.find_first_not_of(
-                                 allowedCharactersInName) != std::string::npos)
+    if (!json_util::readJsonPatch(
+            req, res, "Id", args.id, "Name", args.name, "Metrics", metrics,
+            "MetricReportDefinitionType", args.reportingType, "ReportUpdates",
+            args.reportUpdates, "AppendLimit", args.appendLimit,
+            "ReportActions", reportActions, "Schedule", schedule,
+            "MetricReportDefinitionEnabled",
+            args.metricReportDefinitionEnabled))
     {
-        BMCWEB_LOG_ERROR << "Failed to match " << args.name
-                         << " with allowed character "
-                         << allowedCharactersInName;
-        messages::propertyValueIncorrect(res, "Id", args.name);
         return false;
     }
 
-    if (args.reportingType != "Periodic" && args.reportingType != "OnRequest")
+    if (args.reportingType != "Periodic" && args.reportingType != "OnRequest" &&
+        args.reportingType != "OnChange")
     {
-        messages::propertyValueNotInList(res, args.reportingType,
+        messages::propertyValueNotInList(res, *args.reportingType,
                                          "MetricReportDefinitionType");
         return false;
     }
 
-    if (!toDbusReportActions(res, reportActions, args))
+    if (reportActions && !toDbusReportActions(res, *reportActions, args))
     {
         return false;
     }
@@ -206,18 +308,42 @@ inline bool getUserParameters(crow::Response& res, const crow::Request& req,
         args.interval = static_cast<uint64_t>(durationNum->count());
     }
 
-    args.metrics.reserve(metrics.size());
-    for (auto& m : metrics)
+    if (metrics)
     {
-        std::string id;
-        std::vector<std::string> uris;
-        if (!json_util::readJson(m, res, "MetricId", id, "MetricProperties",
-                                 uris))
+        args.metrics.emplace();
+        args.metrics->reserve(metrics->size());
+        for (auto& m : *metrics)
         {
-            return false;
-        }
+            std::optional<std::string> collectionDurationStr;
+            AddReportArgs::MetricArgs metricArgs;
+            if (!json_util::readJson(
+                    m, res, "MetricId", metricArgs.id, "MetricProperties",
+                    metricArgs.uris, "CollectionFunction",
+                    metricArgs.collectionFunction, "CollectionTimeScope",
+                    metricArgs.collectionTimeScope, "CollectionDuration",
+                    collectionDurationStr))
+            {
+                return false;
+            }
+
+            if (collectionDurationStr)
+            {
+                std::optional<std::chrono::milliseconds> duration =
+                    time_utils::fromDurationString(*collectionDurationStr);
+
+                if (!duration || duration->count() < 0)
+                {
+                    messages::propertyValueIncorrect(res, "CollectionDuration",
+                                                     *collectionDurationStr);
+                    return false;
+                }
 
-        args.metrics.emplace_back(std::move(id), std::move(uris));
+                metricArgs.collectionDuration =
+                    static_cast<uint64_t>(duration->count());
+            }
+
+            args.metrics->emplace_back(std::move(metricArgs));
+        }
     }
 
     return true;
@@ -225,16 +351,13 @@ inline bool getUserParameters(crow::Response& res, const crow::Request& req,
 
 inline bool getChassisSensorNodeFromMetrics(
     const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
-    const std::vector<std::pair<std::string, std::vector<std::string>>>&
-        metrics,
+    const std::vector<AddReportArgs::MetricArgs>& metrics,
     boost::container::flat_set<std::pair<std::string, std::string>>& matched)
 {
     for (const auto& metric : metrics)
     {
-        const std::vector<std::string>& uris = metric.second;
-
         std::optional<IncorrectMetricUri> error =
-            getChassisSensorNode(uris, matched);
+            getChassisSensorNode(metric.uris, matched);
         if (error)
         {
             messages::propertyValueIncorrect(asyncResp->res, error->uri,
@@ -261,70 +384,98 @@ class AddReport
             return;
         }
 
-        telemetry::ReadingParameters readingParams;
-        readingParams.reserve(args.metrics.size());
-
-        for (const auto& [id, uris] : args.metrics)
+        std::optional<telemetry::ReadingParameters> readingParams;
+        if (args.metrics)
         {
-            for (size_t i = 0; i < uris.size(); i++)
+            readingParams.emplace();
+            readingParams->reserve(args.metrics->size());
+
+            for (auto& metric : *args.metrics)
             {
-                const std::string& uri = uris[i];
-                auto el = uriToDbus.find(uri);
-                if (el == uriToDbus.end())
+                std::vector<
+                    std::tuple<sdbusplus::message::object_path, std::string>>
+                    sensorParams;
+                sensorParams.reserve(metric.uris.size());
+
+                for (size_t i = 0; i < metric.uris.size(); i++)
                 {
-                    BMCWEB_LOG_ERROR
-                        << "Failed to find DBus sensor corresponding to URI "
-                        << uri;
-                    messages::propertyValueNotInList(asyncResp->res, uri,
-                                                     "MetricProperties/" +
-                                                         std::to_string(i));
-                    return;
+                    const std::string& uri = metric.uris[i];
+                    auto el = uriToDbus.find(uri);
+                    if (el == uriToDbus.end())
+                    {
+                        BMCWEB_LOG_ERROR
+                            << "Failed to find DBus sensor corresponding to URI "
+                            << uri;
+                        messages::propertyValueNotInList(asyncResp->res, uri,
+                                                         "MetricProperties/" +
+                                                             std::to_string(i));
+                        return;
+                    }
+
+                    const std::string& dbusPath = el->second;
+                    sensorParams.emplace_back(dbusPath, uri);
                 }
 
-                const std::string& dbusPath = el->second;
-                readingParams.emplace_back(dbusPath, "SINGLE", id, uri);
+                readingParams->emplace_back(
+                    std::move(sensorParams),
+                    metric.collectionFunction.value_or(""),
+                    std::move(metric.id),
+                    metric.collectionTimeScope.value_or(""),
+                    metric.collectionDuration.value_or(0U));
             }
         }
-        const std::shared_ptr<bmcweb::AsyncResp> aResp = asyncResp;
-        crow::connections::systemBus->async_method_call(
-            [aResp, name = args.name, uriToDbus = std::move(uriToDbus)](
-                const boost::system::error_code ec, const std::string&) {
-            if (ec == boost::system::errc::file_exists)
-            {
-                messages::resourceAlreadyExists(
-                    aResp->res, "MetricReportDefinition", "Id", name);
-                return;
-            }
-            if (ec == boost::system::errc::too_many_files_open)
-            {
-                messages::createLimitReachedForResource(aResp->res);
-                return;
-            }
-            if (ec == boost::system::errc::argument_list_too_long)
-            {
-                nlohmann::json metricProperties = nlohmann::json::array();
-                for (const auto& [uri, _] : uriToDbus)
+
+        try
+        {
+            const std::shared_ptr<bmcweb::AsyncResp> aResp = asyncResp;
+            crow::connections::systemBus->async_method_call(
+                [aResp, id = args.id.value_or(""),
+                 uriToDbus = std::move(uriToDbus)](
+                    const boost::system::error_code ec, const std::string&) {
+                if (ec == boost::system::errc::file_exists)
                 {
-                    metricProperties.emplace_back(uri);
+                    messages::resourceAlreadyExists(
+                        aResp->res, "MetricReportDefinition", "Id", id);
+                    return;
+                }
+                if (ec == boost::system::errc::too_many_files_open)
+                {
+                    messages::createLimitReachedForResource(aResp->res);
+                    return;
+                }
+                if (ec == boost::system::errc::argument_list_too_long)
+                {
+                    nlohmann::json metricProperties = nlohmann::json::array();
+                    for (const auto& [uri, _] : uriToDbus)
+                    {
+                        metricProperties.emplace_back(uri);
+                    }
+                    messages::propertyValueIncorrect(aResp->res,
+                                                     metricProperties.dump(),
+                                                     "MetricProperties");
+                    return;
+                }
+                if (ec)
+                {
+                    messages::internalError(aResp->res);
+                    BMCWEB_LOG_ERROR << "respHandler DBus error " << ec;
+                    return;
                 }
-                messages::propertyValueIncorrect(
-                    aResp->res, metricProperties.dump(), "MetricProperties");
-                return;
-            }
-            if (ec)
-            {
-                messages::internalError(aResp->res);
-                BMCWEB_LOG_ERROR << "respHandler DBus error " << ec;
-                return;
-            }
 
-            messages::created(aResp->res);
-            },
-            telemetry::service, "/xyz/openbmc_project/Telemetry/Reports",
-            "xyz.openbmc_project.Telemetry.ReportManager", "AddReport",
-            "TelemetryService/" + args.name, args.reportingType,
-            args.emitsReadingsUpdate, args.logToMetricReportsCollection,
-            args.interval, readingParams);
+                messages::created(aResp->res);
+                },
+                telemetry::service, "/xyz/openbmc_project/Telemetry/Reports",
+                "xyz.openbmc_project.Telemetry.ReportManager", "AddReport",
+                args.getProperties(std::move(readingParams)));
+        }
+        catch (const std::exception& e)
+        {
+            BMCWEB_LOG_ERROR << e.what();
+        }
+        catch (...)
+        {
+            BMCWEB_LOG_ERROR << "AddReport failed!";
+        }
     }
 
     AddReport(const AddReport&) = delete;
@@ -389,8 +540,8 @@ inline void requestRoutesMetricReportDefinitionCollection(App& app)
 
         boost::container::flat_set<std::pair<std::string, std::string>>
             chassisSensors;
-        if (!telemetry::getChassisSensorNodeFromMetrics(asyncResp, args.metrics,
-                                                        chassisSensors))
+        if (!telemetry::getChassisSensorNodeFromMetrics(
+                asyncResp, *args.metrics, chassisSensors))
         {
             return;
         }
@@ -436,8 +587,7 @@ inline void requestRoutesMetricReportDefinition(App& app)
             telemetry::getDbusReportPath(id), telemetry::reportInterface,
             [asyncResp,
              id](const boost::system::error_code ec,
-                 const std::vector<std::pair<
-                     std::string, dbus::utility::DbusVariantType>>& ret) {
+                 const dbus::utility::DBusPropertiesMap& properties) {
             if (ec.value() == EBADR ||
                 ec == boost::system::errc::host_unreachable)
             {
@@ -452,9 +602,10 @@ inline void requestRoutesMetricReportDefinition(App& app)
                 return;
             }
 
-            telemetry::fillReportDefinition(asyncResp, id, ret);
+            telemetry::fillReportDefinition(asyncResp, id, properties);
             });
         });
+
     BMCWEB_ROUTE(app,
                  "/redfish/v1/TelemetryService/MetricReportDefinitions/<str>/")
         .privileges(redfish::privileges::deleteMetricReportDefinitionCollection)
diff --git a/redfish-core/lib/telemetry_service.hpp b/redfish-core/lib/telemetry_service.hpp
index afedbc63..1a6b2ac7 100644
--- a/redfish-core/lib/telemetry_service.hpp
+++ b/redfish-core/lib/telemetry_service.hpp
@@ -56,10 +56,12 @@ inline void handleTelemetryServiceGet(
 
         const size_t* maxReports = nullptr;
         const uint64_t* minInterval = nullptr;
+        const std::vector<std::string>* supportedCollectionFunctions = nullptr;
 
         const bool success = sdbusplus::unpackPropertiesNoThrow(
             dbus_utils::UnpackErrorPrinter(), ret, "MaxReports", maxReports,
-            "MinInterval", minInterval);
+            "MinInterval", minInterval, "SupportedOperationTypes",
+            supportedCollectionFunctions);
 
         if (!success)
         {
@@ -78,6 +80,12 @@ inline void handleTelemetryServiceGet(
                 time_utils::toDurationString(std::chrono::milliseconds(
                     static_cast<time_t>(*minInterval)));
         }
+
+        if (supportedCollectionFunctions != nullptr)
+        {
+            asyncResp->res.jsonValue["SupportedCollectionFunctions"] =
+                *supportedCollectionFunctions;
+        }
         });
 }
 
-- 
2.34.1
