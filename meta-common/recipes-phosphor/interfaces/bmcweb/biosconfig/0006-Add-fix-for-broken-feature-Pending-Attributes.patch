From f9c510a807d02431651a12a28c700c6172adf6fc Mon Sep 17 00:00:00 2001
From: Arun Lal K M <arun.lal@intel.com>
Date: Wed, 3 May 2023 13:11:00 +0000
Subject: [PATCH] Add fix for broken feature 'Pending Attributes'.

Fix is added for the following: 1) GET to
 'redfish/v1/Systems/system/Bios'. 2) PATCH to
 'redfish/v1/Systems/system/Bios/Settings'. 3) GET to
 'redfish/v1/Systems/system/Bios/Settings'. 4) Fix for incremental duplicate
 values in BiosAttributeRegistry. 5) POST to
 '/redfish/v1/Systems/system/Bios/Actions             /Bios.ChangePassword/'.
 6) Add support for Enumeration. 7) Support DMTF standard of displaying
 "Value" in BIOS attribute registries.

Tested:
By giving PATCH to 'redfish/v1/Systems/system/Bios/Settings'
PATCH command raw data:
{
    "data":{
            "AmpPrefetchEnable": "0x1",
            "Ce2LmLoggingEn": "0x1",
            "DfxEadrDebugLogs": "0x2",
            "PsfUrEnable": "0x1",
            "ATS": "0x0"
    }
}

Response:
{
    "@Message.ExtendedInfo": [
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "Successfully Completed Request",
            "MessageArgs": [],
            "MessageId": "Base.1.8.1.Success",
            "MessageSeverity": "OK",
            "Resolution": "None"
        }
    ]
}

By giving GET to 'redfish/v1/Systems/system/Bios'
Response:
{
    "@Redfish.Settings": {
        "@odata.type": "#Settings.v1_3_0.Settings",
        "SettingsObject": {
            "@odata.id":
      "/redfish/v1/Systems/system/Bios/Settings"
        }
    },
    "@odata.id": "/redfish/v1/Systems/system/Bios",
    "@odata.type": "#Bios.v1_1_0.Bios",
    "Actions": {
        "#Bios.ChangePassword": {
            "target":
      "/redfish/v1/Systems/system/Bios/Actions/Bios.ChangePassword"
        },
        "#Bios.ResetBios": {
            "target":
      "/redfish/v1/Systems/system/Bios/Actions/Bios.ResetBios"
        }
    },
    "AttributeRegistry": "BiosAttributeRegistry",
    "Attributes": {
        "AEPErrorInjEn": "0x00",
        "ARIEnable": "0x01",
        "ARIForward": "0x00",
    ...
    ...
    ...
        "txEqCalibration": "0x01",
        "volMemMode": "0x00",
        "wrVrefCenter": "0x01"
    },
    "Description": "BIOS Configuration Service",
    "Id": "BIOS",
    "Links": {
        "ActiveSoftwareImage": {
            "@odata.id":
      "/redfish/v1/UpdateService/FirmwareInventory/bios_active"
        },
        "SoftwareImages": [
            {
                "@odata.id":
        "/redfish/v1/UpdateService/FirmwareInventory/bios_active"
            }
        ],
        "SoftwareImages@odata.count": 1
    },
    "Name": "BIOS Configuration"
}

By giving GET to 'redfish/v1/Systems/system/Bios/Settings'
Response:
{
    "@odata.id": "/redfish/v1/Systems/system/Bios/Settings",
    "@odata.type": "#Bios.v1_1_0.Bios",
    "AttributeRegistry": "BiosAttributeRegistry",
    "Attributes": {
        "ATS": "0x0",
        "AmpPrefetchEnable": "0x1",
        "Ce2LmLoggingEn": "0x1",
        "DfxEadrDebugLogs": "0x2",
        "PsfUrEnable": "0x1"
    },
    "Id": "BiosSettingsV1",
    "Name": "Bios Settings Version 1"
}

By giving POST to '/redfish/v1/Systems/system/Bios/Actions
/Bios.ChangePassword/'
Response: Success

By running Redfish-Service-Validator
Result:
Elapsed time: 0:09:36
invalidPropertyValue: 108
metadataNamespaces: 2185
missingNamespaces: 1
optionalAction: 9
pass: 13772
passAction: 22
passGet: 541
reflink: 1
repeat: 47
serviceNamespaces: 75
skipOptional: 9276
unverifiedComplexAdditional: 1
warnDeprecated: 230
warningPresent: 54
Validation has succeeded.

Signed-off-by: Arun Lal K M <arun.lal@intel.com>
Signed-off-by: Snehalatha Venkatesh <snehalathax.v@intel.com>

Upstream-Status: Pending
---
 redfish-core/lib/bios.hpp | 415 ++++++++++++++++++++++++++------------
 1 file changed, 291 insertions(+), 124 deletions(-)

diff --git a/redfish-core/lib/bios.hpp b/redfish-core/lib/bios.hpp
index 037cb181..cfe8c0ec 100644
--- a/redfish-core/lib/bios.hpp
+++ b/redfish-core/lib/bios.hpp
@@ -5,6 +5,8 @@
 #include "registries/privilege_registry.hpp"
 #include "utils/sw_utils.hpp"
 
+#include <boost/url/format.hpp>
+
 namespace redfish
 {
 
@@ -13,22 +15,32 @@ map{attributeName,struct{attributeType,readonlyStatus,displayname,
               description,menuPath,current,default,
               array{struct{optionstring,optionvalue}}}}
 */
-using BiosBaseTableType = std::vector<std::pair<
+
+using BiosBaseTableType = boost::container::flat_map<
     std::string,
     std::tuple<
         std::string, bool, std::string, std::string, std::string,
         std::variant<int64_t, std::string>, std::variant<int64_t, std::string>,
-        std::vector<
-            std::tuple<std::string, std::variant<int64_t, std::string>>>>>>;
+        std::vector<std::tuple<std::string, std::variant<int64_t, std::string>,
+                               std::string>>>>;
+
 using BiosBaseTableItemType = std::pair<
     std::string,
     std::tuple<
         std::string, bool, std::string, std::string, std::string,
         std::variant<int64_t, std::string>, std::variant<int64_t, std::string>,
-        std::vector<
-            std::tuple<std::string, std::variant<int64_t, std::string>>>>>;
+        std::vector<std::tuple<std::string, std::variant<int64_t, std::string>,
+                               std::string>>>>;
+
 using OptionsItemType =
-    std::tuple<std::string, std::variant<int64_t, std::string>>;
+    std::tuple<std::string, std::variant<int64_t, std::string>, std::string>;
+
+using PendingAttributesType = boost::container::flat_map<
+    std::string, std::tuple<std::string, std::variant<int64_t, std::string>>>;
+
+using PendingAttributesItemType =
+    std::pair<std::string,
+              std::tuple<std::string, std::variant<int64_t, std::string>>>;
 
 enum BiosBaseTableIndex
 {
@@ -44,19 +56,10 @@ enum BiosBaseTableIndex
 enum OptionsItemIndex
 {
     optItemType = 0,
-    optItemValue
+    optItemValue,
+    optItemText
 };
-/*
- The Pending attribute name and new value.
-              ex- { {"QuietBoot",Type.Integer, 0x1},
-                    { "DdrFreqLimit",Type.String,"2933"}
-                  }
-*/
-using PendingAttributesType = std::vector<std::pair<
-    std::string, std::tuple<std::string, std::variant<int64_t, std::string>>>>;
-using PendingAttributesItemType =
-    std::pair<std::string,
-              std::tuple<std::string, std::variant<int64_t, std::string>>>;
+
 enum PendingAttributesIndex
 {
     pendingAttrType = 0,
@@ -65,30 +68,20 @@ enum PendingAttributesIndex
 static std::string mapAttrTypeToRedfish(const std::string_view typeDbus)
 {
     std::string ret;
-    if (typeDbus == "xyz.openbmc_project.BIOSConfig.Manager."
-                    "AttributeType.Enumeration")
-    {
-        ret = "Enumeration";
-    }
-    else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.String")
+    if (typeDbus == "xyz.openbmc_project.BIOSConfig."
+                    "Manager.AttributeType.String")
     {
         ret = "String";
     }
-    else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.Password")
-    {
-        ret = "Password";
-    }
     else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
                          "Manager.AttributeType.Integer")
     {
         ret = "Integer";
     }
     else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.Boolean")
+                         "Manager.AttributeType.Enumeration")
     {
-        ret = "Boolean";
+        ret = "Enumeration";
     }
     else
     {
@@ -97,29 +90,7 @@ static std::string mapAttrTypeToRedfish(const std::string_view typeDbus)
 
     return ret;
 }
-static std::string mapRedfishToAttrType(const std::string_view type)
-{
-    std::string ret;
-    if (type == "string")
-    {
-        ret = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.String";
-    }
-    else if (type == "int")
-    {
-        ret = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Integer";
-    }
-    else if (type == "enum")
-    {
-        ret = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType."
-              "Enumeration";
-    }
-    else
-    {
-        ret = "UNKNOWN";
-    }
 
-    return ret;
-}
 static std::string mapBoundTypeToRedfish(const std::string_view typeDbus)
 {
     std::string ret;
@@ -219,6 +190,15 @@ inline void
 
             return;
         }
+
+        if (getObjectType.empty())
+        {
+            BMCWEB_LOG_ERROR("getObjectType is empty.");
+            messages::internalError(asyncResp->res);
+
+            return;
+        }
+
         const std::string& service = getObjectType.begin()->first;
 
         crow::connections::systemBus->async_method_call(
@@ -236,7 +216,7 @@ inline void
                 asyncResp->res.jsonValue["Attributes"];
             if (baseBiosTable == nullptr)
             {
-                BMCWEB_LOG_ERROR("baseBiosTable == nullptr");
+                BMCWEB_LOG_ERROR("baseBiosTable is empty");
                 messages::internalError(asyncResp->res);
                 return;
             }
@@ -246,7 +226,7 @@ inline void
                 const std::string& itemType =
                     std::get<biosBaseAttrType>(item.second);
                 std::string attrType = mapAttrTypeToRedfish(itemType);
-                if (attrType == "String")
+                if (attrType == "String" || attrType == "Enumeration")
                 {
                     const std::string* currValue = std::get_if<std::string>(
                         &std::get<biosBaseCurrValue>(item.second));
@@ -263,7 +243,6 @@ inline void
                 else
                 {
                     BMCWEB_LOG_ERROR("Unsupported attribute type.");
-                    messages::internalError(asyncResp->res);
                 }
             }
         },
@@ -292,8 +271,9 @@ inline void requestRoutesBiosService(App& app)
  */
 inline void requestRoutesBiosChangePassword(App& app)
 {
-    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/")
-        .privileges({{"ConfigureComponents"}})
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Bios/Actions/Bios.ChangePassword/")
+        .privileges(redfish::privileges::postBios)
         .methods(boost::beast::http::verb::post)(
             [](const crow::Request& req,
                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
@@ -360,13 +340,11 @@ inline void requestRoutesBiosSettings(App& app)
             [](const crow::Request&,
                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
         asyncResp->res.jsonValue["@odata.id"] =
-            asyncResp->res.jsonValue["@odata.id"] =
-                "/redfish/v1/Systems/system/Bios/Settings";
+            "/redfish/v1/Systems/system/Bios/Settings";
         asyncResp->res.jsonValue["@odata.type"] = "#Bios.v1_1_0.Bios";
         asyncResp->res.jsonValue["Name"] = "Bios Settings Version 1";
         asyncResp->res.jsonValue["Id"] = "BiosSettingsV1";
         asyncResp->res.jsonValue["AttributeRegistry"] = "BiosAttributeRegistry";
-        asyncResp->res.jsonValue["Attributes"] = nlohmann::json::array();
 
         crow::connections::systemBus->async_method_call(
             [asyncResp](const boost::system::error_code ec,
@@ -378,6 +356,15 @@ inline void requestRoutesBiosSettings(App& app)
 
                 return;
             }
+
+            if (getObjectType.empty())
+            {
+                BMCWEB_LOG_ERROR("getObjectType is empty.");
+                messages::internalError(asyncResp->res);
+
+                return;
+            }
+
             std::string service = getObjectType.begin()->first;
 
             crow::connections::systemBus->async_method_call(
@@ -391,40 +378,64 @@ inline void requestRoutesBiosSettings(App& app)
                         asyncResp->res, "Systems/system/Bios", "Settings");
                     return;
                 }
+
                 const PendingAttributesType* pendingAttributes =
                     std::get_if<PendingAttributesType>(&retPendingAttributes);
                 nlohmann::json& attributesJson =
                     asyncResp->res.jsonValue["Attributes"];
                 if (pendingAttributes == nullptr)
                 {
-                    BMCWEB_LOG_ERROR("pendingAttributes == nullptr");
+                    BMCWEB_LOG_ERROR("pendingAttributes is empty");
                     messages::internalError(asyncResp->res);
                     return;
                 }
-                for (const PendingAttributesItemType& item : *pendingAttributes)
+
+                for (const PendingAttributesItemType& pendingAttributesItem :
+                     *pendingAttributes)
                 {
-                    const std::string& key = item.first;
-                    const std::string& itemType =
-                        std::get<pendingAttrType>(item.second);
-                    std::string attrType = mapAttrTypeToRedfish(itemType);
-                    if (attrType == "String")
+                    const std::string& biosAttrType =
+                        std::get<pendingAttrType>(pendingAttributesItem.second);
+
+                    std::string itemType = mapAttrTypeToRedfish(biosAttrType);
+
+                    if (itemType == "String" || itemType == "Enumeration")
                     {
                         const std::string* currValue = std::get_if<std::string>(
-                            &std::get<pendingAttrValue>(item.second));
-                        attributesJson.emplace(
-                            key, currValue != nullptr ? *currValue : "");
+                            &std::get<pendingAttrValue>(
+                                pendingAttributesItem.second));
+
+                        if (!currValue)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "No string data in pending attributes item data");
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+                        attributesJson.emplace(pendingAttributesItem.first,
+                                               *currValue);
                     }
-                    else if (attrType == "Integer")
+                    else if (itemType == "Integer")
                     {
-                        const int64_t* currValue = std::get_if<int64_t>(
-                            &std::get<pendingAttrValue>(item.second));
-                        attributesJson.emplace(
-                            key, currValue != nullptr ? *currValue : 0);
+                        const int64_t* currValue =
+                            std::get_if<int64_t>(&std::get<pendingAttrValue>(
+                                pendingAttributesItem.second));
+
+                        if (!currValue)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "No int64_t data in pending attributes item data");
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+
+                        attributesJson.emplace(pendingAttributesItem.first,
+                                               *currValue);
                     }
                     else
                     {
                         BMCWEB_LOG_ERROR("Unsupported attribute type.");
                         messages::internalError(asyncResp->res);
+                        return;
                     }
                 }
             },
@@ -440,7 +451,7 @@ inline void requestRoutesBiosSettings(App& app)
     });
 
     BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/Settings")
-        .privileges({{"ConfigureComponents"}})
+        .privileges(redfish::privileges::patchBios)
         .methods(boost::beast::http::verb::patch)(
             [](const crow::Request& req,
                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
@@ -449,58 +460,149 @@ inline void requestRoutesBiosSettings(App& app)
         if (!redfish::json_util::readJsonPatch(req, asyncResp->res, "data",
                                                inpJson))
         {
+            BMCWEB_LOG_ERROR("No 'data' in req!");
             return;
         }
 
-        for (auto& attrInfo : inpJson)
+        if (inpJson.empty())
         {
-            std::string attrName;
-            std::string attrType;
-            std::string attrValue;
-            if (!json_util::readJson(attrInfo, asyncResp->res, "AttributeName",
-                                     attrName))
-            {
-                return;
-            }
-            if (!json_util::readJson(attrInfo, asyncResp->res, "AttributeType",
-                                     attrType))
-            {
-                return;
-            }
-            if (!json_util::readJson(attrInfo, asyncResp->res, "AttributeValue",
-                                     attrValue))
+            messages::invalidObject(asyncResp->res,
+                                    boost::urls::format("data"));
+            BMCWEB_LOG_ERROR("No input in req!");
+            return;
+        }
+
+        crow::connections::systemBus->async_method_call(
+            [asyncResp,
+             inpJson](const boost::system::error_code ec,
+                      const dbus::utility::MapperGetObject& getObjectType) {
+            if (ec)
             {
+                BMCWEB_LOG_ERROR("ObjectMapper::GetObject call failed: {}", ec);
+                messages::internalError(asyncResp->res);
+
                 return;
             }
-            std::string biosAttrType = mapRedfishToAttrType(attrType);
 
-            if (biosAttrType == "UNKNOWN")
+            if (getObjectType.empty())
             {
-                BMCWEB_LOG_ERROR("Invalid attribute type");
-                messages::propertyValueNotInList(asyncResp->res,
-                                                 "AttributeType", attrType);
+                BMCWEB_LOG_ERROR("getObjectType is empty.");
+                messages::internalError(asyncResp->res);
+
                 return;
             }
 
-            PendingAttributesType pendingAttributes;
-            pendingAttributes.emplace_back(std::make_pair(
-                attrName, std::make_tuple(biosAttrType, attrValue)));
+            std::string service = getObjectType.begin()->first;
 
             crow::connections::systemBus->async_method_call(
-                [asyncResp](const boost::system::error_code ec) {
-                if (ec)
+                [asyncResp,
+                 inpJson](const boost::system::error_code ec2,
+                          const std::variant<BiosBaseTableType>& retBiosTable) {
+                if (ec2)
+                {
+                    BMCWEB_LOG_ERROR("getBiosAttributes DBUS error: {}", ec2);
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+
+                const BiosBaseTableType* baseBiosTable =
+                    std::get_if<BiosBaseTableType>(&retBiosTable);
+
+                if (baseBiosTable == nullptr)
                 {
-                    BMCWEB_LOG_ERROR("doPatch resp_handler got error {}", ec);
+                    BMCWEB_LOG_ERROR("baseBiosTable is empty.");
                     messages::internalError(asyncResp->res);
                     return;
                 }
+
+                PendingAttributesType pendingAttributes{};
+
+                for (const nlohmann::detail::iteration_proxy_value<
+                         nlohmann::detail::iter_impl<
+                             const nlohmann::basic_json<>>>& attributes :
+                     inpJson.items())
+                {
+                    BiosBaseTableType::const_iterator knobIter =
+                        baseBiosTable->find(attributes.key());
+                    if (knobIter == baseBiosTable->end())
+                    {
+                        BMCWEB_LOG_ERROR("Cannot find {} in baseBiosTable",
+                                         attributes.key());
+                        messages::propertyValueNotInList(
+                            asyncResp->res, attributes.key(), "data");
+                        return;
+                    }
+
+                    const std::string& itemType =
+                        std::get<biosBaseAttrType>(knobIter->second);
+                    std::string attrType = mapAttrTypeToRedfish(itemType);
+
+                    if (attrType == "String" || attrType == "Enumeration")
+                    {
+                        std::string val = attributes.value();
+
+                        pendingAttributes.emplace(
+                            attributes.key(), std::make_tuple(itemType, val));
+                    }
+                    else if (attrType == "Integer")
+                    {
+                        pendingAttributes.emplace(
+                            attributes.key(),
+                            std::make_tuple(itemType, static_cast<int64_t>(
+                                                          attributes.value())));
+                    }
+                    else
+                    {
+                        BMCWEB_LOG_ERROR("UNKNOWN attrType == {}", itemType);
+                        messages::internalError(asyncResp->res);
+
+                        return;
+                    }
+                }
+
+                if (pendingAttributes.empty())
+                {
+                    BMCWEB_LOG_ERROR("pendingAttributes is empty.");
+                    messages::invalidObject(asyncResp->res,
+                                            boost::urls::format("data"));
+                }
+
+                crow::connections::systemBus->async_method_call(
+                    [asyncResp](const boost::system::error_code ec3) {
+                    if (ec3 == boost::system::errc::io_error)
+                    {
+                        BMCWEB_LOG_ERROR(
+                            "Invalid input data passed while patching Bios/Setting");
+                        messages::invalidObject(asyncResp->res,
+                                                boost::urls::format("data"));
+                        return;
+                    }
+                    if (ec3)
+                    {
+                        BMCWEB_LOG_ERROR("doPatch resp_handler got error {}",
+                                         ec3);
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+
+                    messages::success(asyncResp->res);
+                },
+                    "xyz.openbmc_project.BIOSConfigManager",
+                    "/xyz/openbmc_project/bios_config/manager",
+                    "org.freedesktop.DBus.Properties", "Set",
+                    "xyz.openbmc_project.BIOSConfig.Manager",
+                    "PendingAttributes",
+                    std::variant<PendingAttributesType>(pendingAttributes));
             },
-                "xyz.openbmc_project.BIOSConfigManager",
-                "/xyz/openbmc_project/bios_config/manager",
-                "org.freedesktop.DBus.Properties", "Set",
-                "xyz.openbmc_project.BIOSConfig.Manager", "PendingAttributes",
-                std::variant<PendingAttributesType>(pendingAttributes));
-        }
+                service, "/xyz/openbmc_project/bios_config/manager",
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.BIOSConfig.Manager", "BaseBIOSTable");
+        },
+            "xyz.openbmc_project.ObjectMapper",
+            "/xyz/openbmc_project/object_mapper",
+            "xyz.openbmc_project.ObjectMapper", "GetObject",
+            "/xyz/openbmc_project/bios_config/manager",
+            std::array<const char*, 0>());
     });
 }
 /**
@@ -539,6 +641,15 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
 
                 return;
             }
+
+            if (getObjectType.empty())
+            {
+                BMCWEB_LOG_ERROR("getObjectType is empty.");
+                messages::internalError(asyncResp->res);
+
+                return;
+            }
+
             std::string service = getObjectType.begin()->first;
 
             crow::connections::systemBus->async_method_call(
@@ -557,7 +668,6 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                     std::get_if<BiosBaseTableType>(&retBiosTable);
                 nlohmann::json& attributeArray =
                     asyncResp->res.jsonValue["RegistryEntries"]["Attributes"];
-                nlohmann::json optionsArray = nlohmann::json::array();
                 if (baseBiosTable == nullptr)
                 {
                     BMCWEB_LOG_ERROR("baseBiosTable == nullptr");
@@ -571,9 +681,8 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                     std::string attrType = mapAttrTypeToRedfish(itemType);
                     if (attrType == "UNKNOWN")
                     {
-                        BMCWEB_LOG_ERROR("attrType == UNKNOWN");
-                        messages::internalError(asyncResp->res);
-                        return;
+                        BMCWEB_LOG_ERROR("UNKNOWN attrType == {}", itemType);
+                        continue;
                     }
                     nlohmann::json attributeItem;
                     attributeItem["AttributeName"] = item.first;
@@ -587,12 +696,28 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                     attributeItem["MenuPath"] =
                         std::get<biosBaseMenuPath>(item.second);
 
-                    if (attrType == "String")
+                    if (attrType == "String" || attrType == "Enumeration")
                     {
                         const std::string* currValue = std::get_if<std::string>(
                             &std::get<biosBaseCurrValue>(item.second));
+
+                        if (!currValue)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Unable to get currValue, no std::string data in BIOS attributes item data");
+                            continue;
+                        }
+
                         const std::string* defValue = std::get_if<std::string>(
                             &std::get<biosBaseDefaultValue>(item.second));
+
+                        if (!defValue)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Unable to get defValue, no std::string data in BIOS attributes item data");
+                            continue;
+                        }
+
                         attributeItem["CurrentValue"] =
                             currValue != nullptr ? *currValue : "";
                         attributeItem["DefaultValue"] =
@@ -602,8 +727,24 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                     {
                         const int64_t* currValue = std::get_if<int64_t>(
                             &std::get<biosBaseCurrValue>(item.second));
+
+                        if (!currValue)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Unable to get currValue, no int64_t data in BIOS attributes item data");
+                            continue;
+                        }
+
                         const int64_t* defValue = std::get_if<int64_t>(
                             &std::get<biosBaseDefaultValue>(item.second));
+
+                        if (!defValue)
+                        {
+                            BMCWEB_LOG_ERROR(
+                                "Unable to get defValue, no int64_t data in BIOS attributes item data");
+                            continue;
+                        }
+
                         attributeItem["CurrentValue"] =
                             currValue != nullptr ? *currValue : 0;
                         attributeItem["DefaultValue"] =
@@ -611,11 +752,11 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                     }
                     else
                     {
-                        BMCWEB_LOG_ERROR("Unsupported attribute type.");
-                        messages::internalError(asyncResp->res);
-                        return;
+                        BMCWEB_LOG_ERROR("UNKNOWN attrType == {}", itemType);
+                        continue;
                     }
 
+                    nlohmann::json optionsArray = nlohmann::json::array();
                     const std::vector<OptionsItemType>& optionsVector =
                         std::get<biosBaseOptions>(item.second);
                     for (const OptionsItemType& optItem : optionsVector)
@@ -627,27 +768,53 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                             mapBoundTypeToRedfish(strOptItemType);
                         if (optItemTypeRedfish == "UNKNOWN")
                         {
-                            BMCWEB_LOG_ERROR("optItemTypeRedfish == UNKNOWN");
-                            messages::internalError(asyncResp->res);
-                            return;
+                            BMCWEB_LOG_ERROR("UNKNOWN optItemTypeRedfish == {}",
+                                             strOptItemType);
+                            continue;
                         }
                         if (optItemTypeRedfish == "OneOf")
                         {
                             const std::string* currValue =
                                 std::get_if<std::string>(
                                     &std::get<optItemValue>(optItem));
-                            optItemJson[optItemTypeRedfish] =
+
+                            if (!currValue)
+                            {
+                                BMCWEB_LOG_ERROR(
+                                    "Unable to get currValue, no std::string data in option item value");
+                                continue;
+                            }
+
+                            optItemJson["ValueDisplayName"] =
+                                std::get<optItemText>(optItem);
+                            optItemJson["ValueName"] =
                                 currValue != nullptr ? *currValue : "";
                         }
                         else
                         {
                             const int64_t* currValue = std::get_if<int64_t>(
                                 &std::get<optItemValue>(optItem));
-                            optItemJson[optItemTypeRedfish] =
+
+                            if (!currValue)
+                            {
+                                BMCWEB_LOG_ERROR(
+                                    "Unable to get currValue, no int64_t data in option item value");
+                                continue;
+                            }
+
+                            optItemJson["ValueDisplayName"] =
+                                currValue != nullptr ? *currValue : 0;
+                            optItemJson["ValueName"] =
                                 currValue != nullptr ? *currValue : 0;
                         }
 
                         optionsArray.push_back(optItemJson);
+
+                        if (optionsArray.empty())
+                        {
+                            BMCWEB_LOG_ERROR("optionsArray is empty");
+                            continue;
+                        }
                     }
 
                     attributeItem["Value"] = optionsArray;
-- 
2.25.1

