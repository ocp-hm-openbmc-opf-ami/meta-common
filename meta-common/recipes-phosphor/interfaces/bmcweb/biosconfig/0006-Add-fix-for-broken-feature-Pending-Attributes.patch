From 11cec1ee966eb2bb523f0486c2d094dae80b880c Mon Sep 17 00:00:00 2001
From: Arun Lal K M <arun.lal@intel.com>
Date: Mon, 30 May 2022 20:34:46 +0000
Subject: [PATCH] Add fix for broken feature 'Pending Attributes'.

Fix is added for the following:
1) GET to 'redfish/v1/Systems/system/Bios'.
2) PATCH to 'redfish/v1/Systems/system/Bios/Settings'.
3) GET to 'redfish/v1/Systems/system/Bios/Settings'.
4) Fix for incremental duplicate values in BiosAttributeRegistry.
5) POST to '/redfish/v1/Systems/system/Bios/Actions
            /Bios.ChangePassword/'.
6) Add support for Enumeration.
7) Support DMTF standard of displaying "Value" in BIOS attribute registries.

Tested:
By giving PATCH to 'redfish/v1/Systems/system/Bios/Settings'
PATCH command raw data:
{
    "data":{
            "AmpPrefetchEnable": "0x1",
            "Ce2LmLoggingEn": "0x1",
            "DfxEadrDebugLogs": "0x2",
            "PsfUrEnable": "0x1",
            "ATS": "0x0"
    }
}

Response:
{
    "@Message.ExtendedInfo": [
        {
            "@odata.type": "#Message.v1_1_1.Message",
            "Message": "Successfully Completed Request",
            "MessageArgs": [],
            "MessageId": "Base.1.8.1.Success",
            "MessageSeverity": "OK",
            "Resolution": "None"
        }
    ]
}

By giving GET to 'redfish/v1/Systems/system/Bios'
Response:
{
    "@Redfish.Settings": {
        "@odata.type": "#Settings.v1_3_0.Settings",
        "SettingsObject": {
            "@odata.id":
      "/redfish/v1/Systems/system/Bios/Settings"
        }
    },
    "@odata.id": "/redfish/v1/Systems/system/Bios",
    "@odata.type": "#Bios.v1_1_0.Bios",
    "Actions": {
        "#Bios.ChangePassword": {
            "target":
      "/redfish/v1/Systems/system/Bios/Actions/Bios.ChangePassword"
        },
        "#Bios.ResetBios": {
            "target":
      "/redfish/v1/Systems/system/Bios/Actions/Bios.ResetBios"
        }
    },
    "AttributeRegistry": "BiosAttributeRegistry",
    "Attributes": {
        "AEPErrorInjEn": "0x00",
        "ARIEnable": "0x01",
        "ARIForward": "0x00",
    ...
    ...
    ...
        "txEqCalibration": "0x01",
        "volMemMode": "0x00",
        "wrVrefCenter": "0x01"
    },
    "Description": "BIOS Configuration Service",
    "Id": "BIOS",
    "Links": {
        "ActiveSoftwareImage": {
            "@odata.id":
      "/redfish/v1/UpdateService/FirmwareInventory/bios_active"
        },
        "SoftwareImages": [
            {
                "@odata.id":
        "/redfish/v1/UpdateService/FirmwareInventory/bios_active"
            }
        ],
        "SoftwareImages@odata.count": 1
    },
    "Name": "BIOS Configuration"
}

By giving GET to 'redfish/v1/Systems/system/Bios/Settings'
Response:
{
    "@odata.id": "/redfish/v1/Systems/system/Bios/Settings",
    "@odata.type": "#Bios.v1_1_0.Bios",
    "AttributeRegistry": "BiosAttributeRegistry",
    "Attributes": {
        "ATS": "0x0",
        "AmpPrefetchEnable": "0x1",
        "Ce2LmLoggingEn": "0x1",
        "DfxEadrDebugLogs": "0x2",
        "PsfUrEnable": "0x1"
    },
    "Id": "BiosSettingsV1",
    "Name": "Bios Settings Version 1"
}

By giving POST to '/redfish/v1/Systems/system/Bios/Actions
/Bios.ChangePassword/'
Response: Success

By running Redfish-Service-Validator
Result:
Elapsed time: 0:09:36
invalidPropertyValue: 108
metadataNamespaces: 2185
missingNamespaces: 1
optionalAction: 9
pass: 13772
passAction: 22
passGet: 541
reflink: 1
repeat: 47
serviceNamespaces: 75
skipOptional: 9276
unverifiedComplexAdditional: 1
warnDeprecated: 230
warningPresent: 54
Validation has succeeded.

Signed-off-by: Arun Lal K M <arun.lal@intel.com>
Signed-off-by: Snehalatha Venkatesh <snehalathax.v@intel.com>
---
 redfish-core/lib/bios.hpp | 403 +++++++++++++++++++++++++++-----------
 1 file changed, 285 insertions(+), 118 deletions(-)

diff --git a/redfish-core/lib/bios.hpp b/redfish-core/lib/bios.hpp
index 4c5b8a37a..fedbcef3c 100644
--- a/redfish-core/lib/bios.hpp
+++ b/redfish-core/lib/bios.hpp
@@ -13,13 +13,15 @@ map{attributeName,struct{attributeType,readonlyStatus,displayname,
               description,menuPath,current,default,
               array{struct{optionstring,optionvalue}}}}
 */
-using BiosBaseTableType = std::vector<std::pair<
+
+using BiosBaseTableType = boost::container::flat_map<
     std::string,
     std::tuple<
         std::string, bool, std::string, std::string, std::string,
         std::variant<int64_t, std::string>, std::variant<int64_t, std::string>,
         std::vector<
-            std::tuple<std::string, std::variant<int64_t, std::string>>>>>>;
+            std::tuple<std::string, std::variant<int64_t, std::string>>>>>;
+
 using BiosBaseTableItemType = std::pair<
     std::string,
     std::tuple<
@@ -30,6 +32,13 @@ using BiosBaseTableItemType = std::pair<
 using OptionsItemType =
     std::tuple<std::string, std::variant<int64_t, std::string>>;
 
+using PendingAttributesType = boost::container::flat_map<
+    std::string, std::tuple<std::string, std::variant<int64_t, std::string>>>;
+
+using PendingAttributesItemType =
+    std::pair<std::string,
+              std::tuple<std::string, std::variant<int64_t, std::string>>>;
+
 enum BiosBaseTableIndex
 {
     biosBaseAttrType = 0,
@@ -46,17 +55,7 @@ enum OptionsItemIndex
     optItemType = 0,
     optItemValue
 };
-/*
- The Pending attribute name and new value.
-              ex- { {"QuietBoot",Type.Integer, 0x1},
-                    { "DdrFreqLimit",Type.String,"2933"}
-                  }
-*/
-using PendingAttributesType = std::vector<std::pair<
-    std::string, std::tuple<std::string, std::variant<int64_t, std::string>>>>;
-using PendingAttributesItemType =
-    std::pair<std::string,
-              std::tuple<std::string, std::variant<int64_t, std::string>>>;
+
 enum PendingAttributesIndex
 {
     pendingAttrType = 0,
@@ -65,30 +64,20 @@ enum PendingAttributesIndex
 static std::string mapAttrTypeToRedfish(const std::string_view typeDbus)
 {
     std::string ret;
-    if (typeDbus == "xyz.openbmc_project.BIOSConfig.Manager."
-                    "AttributeType.Enumeration")
-    {
-        ret = "Enumeration";
-    }
-    else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.String")
+    if (typeDbus == "xyz.openbmc_project.BIOSConfig."
+                    "Manager.AttributeType.String")
     {
         ret = "String";
     }
-    else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.Password")
-    {
-        ret = "Password";
-    }
     else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
                          "Manager.AttributeType.Integer")
     {
         ret = "Integer";
     }
     else if (typeDbus == "xyz.openbmc_project.BIOSConfig."
-                         "Manager.AttributeType.Boolean")
+                         "Manager.AttributeType.Enumeration")
     {
-        ret = "Boolean";
+        ret = "Enumeration";
     }
     else
     {
@@ -97,29 +86,7 @@ static std::string mapAttrTypeToRedfish(const std::string_view typeDbus)
 
     return ret;
 }
-static std::string mapRedfishToAttrType(const std::string_view type)
-{
-    std::string ret;
-    if (type == "string")
-    {
-        ret = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.String";
-    }
-    else if (type == "int")
-    {
-        ret = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType.Integer";
-    }
-    else if (type == "enum")
-    {
-        ret = "xyz.openbmc_project.BIOSConfig.Manager.AttributeType."
-              "Enumeration";
-    }
-    else
-    {
-        ret = "UNKNOWN";
-    }
 
-    return ret;
-}
 static std::string mapBoundTypeToRedfish(const std::string_view typeDbus)
 {
     std::string ret;
@@ -205,6 +172,15 @@ inline void
 
             return;
         }
+
+        if (getObjectType.empty())
+        {
+            BMCWEB_LOG_ERROR << "getObjectType is empty.";
+            messages::internalError(asyncResp->res);
+
+            return;
+        }
+
         const std::string& service = getObjectType.begin()->first;
 
         crow::connections::systemBus->async_method_call(
@@ -222,7 +198,7 @@ inline void
                 asyncResp->res.jsonValue["Attributes"];
             if (baseBiosTable == nullptr)
             {
-                BMCWEB_LOG_ERROR << "baseBiosTable == nullptr ";
+                BMCWEB_LOG_ERROR << "baseBiosTable is empty";
                 messages::internalError(asyncResp->res);
                 return;
             }
@@ -232,7 +208,7 @@ inline void
                 const std::string& itemType =
                     std::get<biosBaseAttrType>(item.second);
                 std::string attrType = mapAttrTypeToRedfish(itemType);
-                if (attrType == "String")
+                if (attrType == "String" || attrType == "Enumeration")
                 {
                     const std::string* currValue = std::get_if<std::string>(
                         &std::get<biosBaseCurrValue>(item.second));
@@ -249,7 +225,6 @@ inline void
                 else
                 {
                     BMCWEB_LOG_ERROR << "Unsupported attribute type.";
-                    messages::internalError(asyncResp->res);
                 }
             }
             },
@@ -278,8 +253,9 @@ inline void requestRoutesBiosService(App& app)
  */
 inline void requestRoutesBiosChangePassword(App& app)
 {
-    BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/")
-        .privileges({{"ConfigureComponents"}})
+    BMCWEB_ROUTE(app,
+                 "/redfish/v1/Systems/system/Bios/Actions/Bios.ChangePassword/")
+        .privileges(redfish::privileges::postBios)
         .methods(boost::beast::http::verb::post)(
             [](const crow::Request& req,
                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
@@ -346,8 +322,7 @@ inline void requestRoutesBiosSettings(App& app)
             [](const crow::Request&,
                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
         asyncResp->res.jsonValue["@odata.id"] =
-            asyncResp->res.jsonValue["@odata.id"] =
-                "/redfish/v1/Systems/system/Bios/Settings";
+            "/redfish/v1/Systems/system/Bios/Settings";
         asyncResp->res.jsonValue["@odata.type"] = "#Bios.v1_1_0.Bios";
         asyncResp->res.jsonValue["Name"] = "Bios Settings Version 1";
         asyncResp->res.jsonValue["Id"] = "BiosSettingsV1";
@@ -365,6 +340,15 @@ inline void requestRoutesBiosSettings(App& app)
 
                 return;
             }
+
+            if (getObjectType.empty())
+            {
+                BMCWEB_LOG_ERROR << "getObjectType is empty.";
+                messages::internalError(asyncResp->res);
+
+                return;
+            }
+
             std::string service = getObjectType.begin()->first;
 
             crow::connections::systemBus->async_method_call(
@@ -378,40 +362,65 @@ inline void requestRoutesBiosSettings(App& app)
                         asyncResp->res, "Systems/system/Bios", "Settings");
                     return;
                 }
+
                 const PendingAttributesType* pendingAttributes =
                     std::get_if<PendingAttributesType>(&retPendingAttributes);
                 nlohmann::json& attributesJson =
                     asyncResp->res.jsonValue["Attributes"];
                 if (pendingAttributes == nullptr)
                 {
-                    BMCWEB_LOG_ERROR << "pendingAttributes == nullptr ";
+                    BMCWEB_LOG_ERROR << "pendingAttributes is empty";
                     messages::internalError(asyncResp->res);
                     return;
                 }
-                for (const PendingAttributesItemType& item : *pendingAttributes)
+
+                for (const PendingAttributesItemType& pendingAttributesItem :
+                     *pendingAttributes)
                 {
-                    const std::string& key = item.first;
-                    const std::string& itemType =
-                        std::get<pendingAttrType>(item.second);
-                    std::string attrType = mapAttrTypeToRedfish(itemType);
-                    if (attrType == "String")
+                    const std::string& biosAttrType =
+                        std::get<pendingAttrType>(pendingAttributesItem.second);
+
+                    std::string itemType = mapAttrTypeToRedfish(biosAttrType);
+
+                    if (itemType == "String" || itemType == "Enumeration")
                     {
                         const std::string* currValue = std::get_if<std::string>(
-                            &std::get<pendingAttrValue>(item.second));
-                        attributesJson.emplace(
-                            key, currValue != nullptr ? *currValue : "");
+                            &std::get<pendingAttrValue>(
+                                pendingAttributesItem.second));
+
+                        if (!currValue)
+                        {
+                            BMCWEB_LOG_ERROR << "No string data in pending "
+                                                "attributes item data";
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+
+                        attributesJson.emplace(pendingAttributesItem.first,
+                                               *currValue);
                     }
-                    else if (attrType == "Integer")
+                    else if (itemType == "Integer")
                     {
-                        const int64_t* currValue = std::get_if<int64_t>(
-                            &std::get<pendingAttrValue>(item.second));
-                        attributesJson.emplace(
-                            key, currValue != nullptr ? *currValue : 0);
+                        const int64_t* currValue =
+                            std::get_if<int64_t>(&std::get<pendingAttrValue>(
+                                pendingAttributesItem.second));
+
+                        if (!currValue)
+                        {
+                            BMCWEB_LOG_ERROR << "No int64_t data in pending "
+                                                "attributes item data";
+                            messages::internalError(asyncResp->res);
+                            return;
+                        }
+
+                        attributesJson.emplace(pendingAttributesItem.first,
+                                               *currValue);
                     }
                     else
                     {
                         BMCWEB_LOG_ERROR << "Unsupported attribute type.";
                         messages::internalError(asyncResp->res);
+                        return;
                     }
                 }
                 },
@@ -427,7 +436,7 @@ inline void requestRoutesBiosSettings(App& app)
         });
 
     BMCWEB_ROUTE(app, "/redfish/v1/Systems/system/Bios/Settings")
-        .privileges({{"ConfigureComponents"}})
+        .privileges(redfish::privileges::patchBios)
         .methods(boost::beast::http::verb::patch)(
             [](const crow::Request& req,
                const std::shared_ptr<bmcweb::AsyncResp>& asyncResp) {
@@ -436,58 +445,142 @@ inline void requestRoutesBiosSettings(App& app)
         if (!redfish::json_util::readJsonPatch(req, asyncResp->res, "data",
                                                inpJson))
         {
+            BMCWEB_LOG_ERROR << "No 'data' in req!";
             return;
         }
 
-        for (auto& attrInfo : inpJson)
+        if (inpJson.empty())
         {
-            std::string attrName;
-            std::string attrType;
-            std::string attrValue;
-            if (!json_util::readJson(attrInfo, asyncResp->res, "AttributeName",
-                                     attrName))
-            {
-                return;
-            }
-            if (!json_util::readJson(attrInfo, asyncResp->res, "AttributeType",
-                                     attrType))
-            {
-                return;
-            }
-            if (!json_util::readJson(attrInfo, asyncResp->res, "AttributeValue",
-                                     attrValue))
+            messages::invalidObject(asyncResp->res,
+                                    crow::utility::urlFromPieces("data"));
+            BMCWEB_LOG_ERROR << "No input in req!";
+            return;
+        }
+
+        crow::connections::systemBus->async_method_call(
+            [asyncResp,
+             inpJson](const boost::system::error_code ec,
+                      const dbus::utility::MapperGetObject& getObjectType) {
+            if (ec)
             {
+                BMCWEB_LOG_ERROR << "ObjectMapper::GetObject call failed: "
+                                 << ec;
+                messages::internalError(asyncResp->res);
+
                 return;
             }
-            std::string biosAttrType = mapRedfishToAttrType(attrType);
 
-            if (biosAttrType == "UNKNOWN")
+            if (getObjectType.empty())
             {
-                BMCWEB_LOG_ERROR << "Invalid attribute type";
-                messages::propertyValueNotInList(asyncResp->res,
-                                                 "AttributeType", attrType);
+                BMCWEB_LOG_ERROR << "getObjectType is empty.";
+                messages::internalError(asyncResp->res);
+
                 return;
             }
 
-            PendingAttributesType pendingAttributes;
-            pendingAttributes.emplace_back(std::make_pair(
-                attrName, std::make_tuple(biosAttrType, attrValue)));
+            std::string service = getObjectType.begin()->first;
 
             crow::connections::systemBus->async_method_call(
-                [asyncResp](const boost::system::error_code ec) {
-                if (ec)
+                [asyncResp,
+                 inpJson](const boost::system::error_code ec2,
+                          const std::variant<BiosBaseTableType>& retBiosTable) {
+                if (ec2)
+                {
+                    BMCWEB_LOG_ERROR << "getBiosAttributes DBUS error: " << ec2;
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+
+                const BiosBaseTableType* baseBiosTable =
+                    std::get_if<BiosBaseTableType>(&retBiosTable);
+
+                if (baseBiosTable == nullptr)
                 {
-                    BMCWEB_LOG_ERROR << "doPatch resp_handler got error " << ec;
+                    BMCWEB_LOG_ERROR << "baseBiosTable is empty.";
                     messages::internalError(asyncResp->res);
                     return;
                 }
+
+                PendingAttributesType pendingAttributes{};
+
+                for (const nlohmann::detail::iteration_proxy_value<
+                         nlohmann::detail::iter_impl<
+                             const nlohmann::basic_json<>>>& attributes :
+                     inpJson.items())
+                {
+                    BiosBaseTableType::const_iterator knobIter =
+                        baseBiosTable->find(attributes.key());
+                    if (knobIter == baseBiosTable->end())
+                    {
+                        BMCWEB_LOG_ERROR << "Cannot find " << attributes.key()
+                                         << " in baseBiosTable";
+                        messages::propertyValueNotInList(
+                            asyncResp->res, attributes.key(), "data");
+                        return;
+                    }
+
+                    const std::string& itemType =
+                        std::get<biosBaseAttrType>(knobIter->second);
+                    std::string attrType = mapAttrTypeToRedfish(itemType);
+
+                    if (attrType == "String" || attrType == "Enumeration")
+                    {
+                        std::string val = attributes.value();
+
+                        pendingAttributes.emplace(
+                            attributes.key(), std::make_tuple(itemType, val));
+                    }
+                    else if (attrType == "Integer")
+                    {
+                        pendingAttributes.emplace(
+                            attributes.key(),
+                            std::make_tuple(itemType, static_cast<int64_t>(
+                                                          attributes.value())));
+                    }
+                    else
+                    {
+                        BMCWEB_LOG_ERROR << "UNKNOWN attrType == " << itemType;
+                        messages::internalError(asyncResp->res);
+
+                        return;
+                    }
+                }
+
+                if (pendingAttributes.empty())
+                {
+                    BMCWEB_LOG_ERROR << "pendingAttributes is empty.";
+                    messages::invalidObject(
+                        asyncResp->res, crow::utility::urlFromPieces("data"));
+                }
+
+                crow::connections::systemBus->async_method_call(
+                    [asyncResp](const boost::system::error_code ec3) {
+                    if (ec3)
+                    {
+                        BMCWEB_LOG_ERROR << "doPatch resp_handler got error "
+                                         << ec3 << "\n";
+                        messages::internalError(asyncResp->res);
+                        return;
+                    }
+
+                    messages::success(asyncResp->res);
+                    },
+                    "xyz.openbmc_project.BIOSConfigManager",
+                    "/xyz/openbmc_project/bios_config/manager",
+                    "org.freedesktop.DBus.Properties", "Set",
+                    "xyz.openbmc_project.BIOSConfig.Manager",
+                    "PendingAttributes",
+                    std::variant<PendingAttributesType>(pendingAttributes));
                 },
-                "xyz.openbmc_project.BIOSConfigManager",
-                "/xyz/openbmc_project/bios_config/manager",
-                "org.freedesktop.DBus.Properties", "Set",
-                "xyz.openbmc_project.BIOSConfig.Manager", "PendingAttributes",
-                std::variant<PendingAttributesType>(pendingAttributes));
-        }
+                service, "/xyz/openbmc_project/bios_config/manager",
+                "org.freedesktop.DBus.Properties", "Get",
+                "xyz.openbmc_project.BIOSConfig.Manager", "BaseBIOSTable");
+            },
+            "xyz.openbmc_project.ObjectMapper",
+            "/xyz/openbmc_project/object_mapper",
+            "xyz.openbmc_project.ObjectMapper", "GetObject",
+            "/xyz/openbmc_project/bios_config/manager",
+            std::array<const char*, 0>());
         });
 }
 /**
@@ -527,6 +620,15 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
 
                 return;
             }
+
+            if (getObjectType.empty())
+            {
+                BMCWEB_LOG_ERROR << "getObjectType is empty.";
+                messages::internalError(asyncResp->res);
+
+                return;
+            }
+
             std::string service = getObjectType.begin()->first;
 
             crow::connections::systemBus->async_method_call(
@@ -545,7 +647,6 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                     std::get_if<BiosBaseTableType>(&retBiosTable);
                 nlohmann::json& attributeArray =
                     asyncResp->res.jsonValue["RegistryEntries"]["Attributes"];
-                nlohmann::json optionsArray = nlohmann::json::array();
                 if (baseBiosTable == nullptr)
                 {
                     BMCWEB_LOG_ERROR << "baseBiosTable == nullptr ";
@@ -559,9 +660,8 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                     std::string attrType = mapAttrTypeToRedfish(itemType);
                     if (attrType == "UNKNOWN")
                     {
-                        BMCWEB_LOG_ERROR << "attrType == UNKNOWN";
-                        messages::internalError(asyncResp->res);
-                        return;
+                        BMCWEB_LOG_ERROR << "UNKNOWN attrType == " << itemType;
+                        continue;
                     }
                     nlohmann::json attributeItem;
                     attributeItem["AttributeName"] = item.first;
@@ -575,12 +675,30 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                     attributeItem["MenuPath"] =
                         std::get<biosBaseMenuPath>(item.second);
 
-                    if (attrType == "String")
+                    if (attrType == "String" || attrType == "Enumeration")
                     {
                         const std::string* currValue = std::get_if<std::string>(
                             &std::get<biosBaseCurrValue>(item.second));
+
+                        if (!currValue)
+                        {
+                            BMCWEB_LOG_ERROR << "Unable to get currValue, no "
+                                                "std::string data in BIOS "
+                                                "attributes item data";
+                            continue;
+                        }
+
                         const std::string* defValue = std::get_if<std::string>(
                             &std::get<biosBaseDefaultValue>(item.second));
+
+                        if (!defValue)
+                        {
+                            BMCWEB_LOG_ERROR << "Unable to get defValue, no "
+                                                "std::string data in BIOS "
+                                                "attributes item data";
+                            continue;
+                        }
+
                         attributeItem["CurrentValue"] =
                             currValue != nullptr ? *currValue : "";
                         attributeItem["DefaultValue"] =
@@ -590,8 +708,26 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                     {
                         const int64_t* currValue = std::get_if<int64_t>(
                             &std::get<biosBaseCurrValue>(item.second));
+
+                        if (!currValue)
+                        {
+                            BMCWEB_LOG_ERROR << "Unable to get currValue, no "
+                                                "int64_t data in BIOS "
+                                                "attributes item data";
+                            continue;
+                        }
+
                         const int64_t* defValue = std::get_if<int64_t>(
                             &std::get<biosBaseDefaultValue>(item.second));
+
+                        if (!defValue)
+                        {
+                            BMCWEB_LOG_ERROR << "Unable to get defValue, no "
+                                                "int64_t data in BIOS "
+                                                "attributes item data";
+                            continue;
+                        }
+
                         attributeItem["CurrentValue"] =
                             currValue != nullptr ? *currValue : 0;
                         attributeItem["DefaultValue"] =
@@ -599,11 +735,11 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                     }
                     else
                     {
-                        BMCWEB_LOG_ERROR << "Unsupported attribute type.";
-                        messages::internalError(asyncResp->res);
-                        return;
+                        BMCWEB_LOG_ERROR << "UNKNOWN attrType == " << itemType;
+                        continue;
                     }
 
+                    nlohmann::json optionsArray = nlohmann::json::array();
                     const std::vector<OptionsItemType>& optionsVector =
                         std::get<biosBaseOptions>(item.second);
                     for (const OptionsItemType& optItem : optionsVector)
@@ -615,27 +751,58 @@ inline void requestRoutesBiosAttributeRegistry(App& app)
                             mapBoundTypeToRedfish(strOptItemType);
                         if (optItemTypeRedfish == "UNKNOWN")
                         {
-                            BMCWEB_LOG_ERROR << "optItemTypeRedfish == UNKNOWN";
-                            messages::internalError(asyncResp->res);
-                            return;
+                            BMCWEB_LOG_ERROR << "UNKNOWN optItemTypeRedfish == "
+                                             << strOptItemType;
+                            continue;
                         }
                         if (optItemTypeRedfish == "OneOf")
                         {
                             const std::string* currValue =
                                 std::get_if<std::string>(
                                     &std::get<optItemValue>(optItem));
-                            optItemJson[optItemTypeRedfish] =
+
+                            if (!currValue)
+                            {
+                                BMCWEB_LOG_ERROR
+                                    << "Unable to get currValue, "
+                                       "no "
+                                       "std::string data in option "
+                                       "item value";
+                                continue;
+                            }
+
+                            optItemJson["ValueDisplayName"] =
+                                currValue != nullptr ? *currValue : "";
+                            optItemJson["ValueName"] =
                                 currValue != nullptr ? *currValue : "";
                         }
                         else
                         {
                             const int64_t* currValue = std::get_if<int64_t>(
                                 &std::get<optItemValue>(optItem));
-                            optItemJson[optItemTypeRedfish] =
+
+                            if (!currValue)
+                            {
+                                BMCWEB_LOG_ERROR << "Unable to get currValue, "
+                                                    "no "
+                                                    "int64_t data in option "
+                                                    "item value";
+                                continue;
+                            }
+
+                            optItemJson["ValueDisplayName"] =
+                                currValue != nullptr ? *currValue : 0;
+                            optItemJson["ValueName"] =
                                 currValue != nullptr ? *currValue : 0;
                         }
 
                         optionsArray.push_back(optItemJson);
+
+                        if (optionsArray.empty())
+                        {
+                            BMCWEB_LOG_ERROR << "optionsArray is empty";
+                            continue;
+                        }
                     }
 
                     attributeItem["Value"] = optionsArray;
-- 
2.25.1

