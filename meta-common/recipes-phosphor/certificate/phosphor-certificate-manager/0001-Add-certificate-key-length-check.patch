From cb2f3829b3d62a3b761ce97eaf50a23730e0056a Mon Sep 17 00:00:00 2001
From: AppaRao Puli <apparao.puli@intel.com>
Date: Tue, 16 May 2023 16:55:40 +0000
Subject: [PATCH] Add certificate key length check

Current implementation of certificate manager doesn't
have check for minimum and maximum supported key length
certificate upload. This leads to security issues.

NIST recommends the use of keys with a minimum strength of 112 bits
of security to protect data until 2030, and 128 bits of security
thereafter. A 2048-bit RSA key provides 112-bit of security.

When more 8192-bit RSA key size certificates are uploaded as HTTPS
its crashing the bmcweb and not allowing https communication. So
currently max key length is set to 4096-bit RAS key to avoid the
bmcweb.

Tested:
Tried uploading 8K+ key length certificate and its failed to
upload as expected and bmcweb crash is avoided.

Tried uploading 2k & 4K key length certificate and it worked
as expected.

Change-Id: I81d29a43997f3f042b08896b5519f360fee8c5a7
Signed-off-by: AppaRao Puli <apparao.puli@intel.com>
---
 certificate.cpp |  1 +
 x509_utils.cpp  | 31 +++++++++++++++++++++++++++++++
 x509_utils.hpp  |  8 ++++++++
 3 files changed, 40 insertions(+)

diff --git a/certificate.cpp b/certificate.cpp
index 52c3c2a..79a5b02 100644
--- a/certificate.cpp
+++ b/certificate.cpp
@@ -355,6 +355,7 @@ void Certificate::install(const std::string& certSrcFilePath, bool restore)
     // Perform validation
     validateCertificateAgainstStore(*x509Store, *cert);
     validateCertificateStartDate(*cert);
+    validateCertificateKeyLength(*cert);
     validateCertificateInSSLContext(*cert);
 
     // Invoke type specific append private key function.
diff --git a/x509_utils.cpp b/x509_utils.cpp
index 7978771..5c6675e 100644
--- a/x509_utils.cpp
+++ b/x509_utils.cpp
@@ -44,6 +44,15 @@ using X509Ptr = std::unique_ptr<X509, decltype(&::X509_free)>;
 using BIOMemPtr = std::unique_ptr<BIO, decltype(&::BIO_free)>;
 using ASN1TimePtr = std::unique_ptr<ASN1_TIME, decltype(&ASN1_STRING_free)>;
 using SSLCtxPtr = std::unique_ptr<SSL_CTX, decltype(&::SSL_CTX_free)>;
+using EVPPkeyPtr = std::unique_ptr<EVP_PKEY, decltype(&::EVP_PKEY_free)>;
+
+// Max supported cryptographi certificate key length.
+// Todo: Min key length also need validation but currently default
+// certificate(bmcweb) is using 384 key size. So it will be limited
+// after discussion with bmcweb maintainers
+// These can be moved to meson config depending on OEM needs.
+constexpr int minKeyBitLength = 1024;
+constexpr int maxKeyBitLength = 4096;
 
 // Trust chain related errors.`
 constexpr bool isTrustChainError(int error)
@@ -142,6 +151,28 @@ void validateCertificateStartDate(X509& cert)
     }
 }
 
+void validateCertificateKeyLength(X509& cert)
+{
+    EVPPkeyPtr pubKey(X509_get_pubkey(&cert), ::EVP_PKEY_free);
+    if (!pubKey)
+    {
+        log<level::ERR>("X509_get_pubkey() failed",
+                        entry("ERRCODE=%lu", ERR_get_error()));
+        elog<InvalidCertificate>(Reason("Failed to get public key info"));
+    }
+
+    int keyLen = EVP_PKEY_bits(pubKey.get());
+    log<level::INFO>("Certificate cryptographic length",
+                     entry("KEYLENGTH=%d", keyLen));
+
+    if (keyLen > maxKeyBitLength)
+    {
+        log<level::ERR>("Invalid cryptographic length certificate uploaded",
+                        entry("KEYLENGTH=%d", keyLen));
+        elog<InvalidCertificate>(Reason("Invalid key length certificate"));
+    }
+}
+
 void validateCertificateAgainstStore(X509_STORE& x509Store, X509& cert)
 {
     int errCode = X509_V_OK;
diff --git a/x509_utils.hpp b/x509_utils.hpp
index 6e193fc..4947b45 100644
--- a/x509_utils.hpp
+++ b/x509_utils.hpp
@@ -32,6 +32,14 @@ std::unique_ptr<X509, decltype(&::X509_free)>
  */
 void validateCertificateStartDate(X509& cert);
 
+/**
+ * @brief Parses the certificate and throws error if certificate key length
+ * is in not supported range
+ * @param[in] cert Reference to certificate object uploaded
+ * @return void
+ */
+void validateCertificateKeyLength(X509& cert);
+
 /**
  * @brief Validates the certificate against the trusted certificates store and
  * throws error if certificate is not valid
-- 
2.17.1

