From f680046086c776a56de66e6c484d8512d0cedbed Mon Sep 17 00:00:00 2001
From: Jae Hyun Yoo <jae.hyun.yoo@intel.com>
Date: Wed, 27 Jan 2021 15:52:16 -0800
Subject: [PATCH] Fix PECI client creation flow

Use variable delays when detecting CPUs sensors.
This change avoid flood the journal with error messages as CPU powers
on and before peci is fully functioning.

Signed-off-by: Zhikui Ren <zhikui.ren@intel.com>
---
 src/IntelCPUSensorMain.cpp | 32 ++++++++++++++++++++++++--------
 1 file changed, 24 insertions(+), 8 deletions(-)

diff --git a/src/IntelCPUSensorMain.cpp b/src/IntelCPUSensorMain.cpp
index 011f2fb..190a47d 100644
--- a/src/IntelCPUSensorMain.cpp
+++ b/src/IntelCPUSensorMain.cpp
@@ -51,6 +51,9 @@
 // clang-format on
 
 static constexpr bool debug = false;
+static constexpr size_t fastPingSeconds = 1;
+static constexpr size_t slowPingSeconds = 5;
+static constexpr size_t failPingSeconds = 15;
 
 boost::container::flat_map<std::string, std::shared_ptr<IntelCPUSensor>>
     gCpuSensors;
@@ -95,7 +98,7 @@ static constexpr auto hiddenProps{std::to_array<const char*>(
     {IntelCPUSensor::labelTcontrol, "Tthrottle", "Tjmax"})};
 
 void detectCpuAsync(
-    boost::asio::steady_timer& pingTimer,
+    boost::asio::steady_timer& pingTimer, const size_t pingSeconds,
     boost::asio::steady_timer& creationTimer, boost::asio::io_context& io,
     sdbusplus::asio::object_server& objectServer,
     std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
@@ -479,6 +482,7 @@ void detectCpu(boost::asio::steady_timer& pingTimer,
                ManagedObjectType& sensorConfigs)
 {
     size_t rescanDelaySeconds = 0;
+    size_t pingSeconds = fastPingSeconds;
     static bool keepPinging = false;
 
     for (CPUConfig& config : cpuConfigs)
@@ -496,7 +500,7 @@ void detectCpu(boost::asio::steady_timer& pingTimer,
         {
             std::cerr << "unable to open " << peciDevPath << " "
                       << std::strerror(errno) << "\n";
-            detectCpuAsync(pingTimer, creationTimer, io, objectServer,
+            detectCpuAsync(pingTimer, slowPingSeconds, creationTimer, io, objectServer,
                            dbusConnection, cpuConfigs, sensorConfigs);
             return;
         }
@@ -527,6 +531,8 @@ void detectCpu(boost::asio::steady_timer& pingTimer,
                 }
                 else
                 {
+                    /* ping passed, read dimm temp failed*/
+                    pingSeconds = slowPingSeconds;
                     break;
                 }
             }
@@ -557,11 +563,14 @@ void detectCpu(boost::asio::steady_timer& pingTimer,
                         std::cout << config.name << " is detected\n";
                         if (!exportDevice(config))
                         {
+                            pingSeconds = failPingSeconds;
                             newState = State::OFF;
                         }
                     }
                     else
                     {
+                        /*ping passed, get CPUID failed*/
+                        pingSeconds = slowPingSeconds;
                         newState = State::OFF;
                     }
                 }
@@ -586,6 +595,8 @@ void detectCpu(boost::asio::steady_timer& pingTimer,
             keepPinging = true;
         }
 
+        close(file);
+
         if (debug)
         {
             std::cout << config.name << ", state: " << config.state << "\n";
@@ -605,27 +616,27 @@ void detectCpu(boost::asio::steady_timer& pingTimer,
                                sensorConfigs) ||
                 keepPinging)
             {
-                detectCpuAsync(pingTimer, creationTimer, io, objectServer,
+                detectCpuAsync(pingTimer, slowPingSeconds, creationTimer, io, objectServer,
                                dbusConnection, cpuConfigs, sensorConfigs);
             }
         });
     }
     else if (keepPinging)
     {
-        detectCpuAsync(pingTimer, creationTimer, io, objectServer,
+        detectCpuAsync(pingTimer, pingSeconds, creationTimer, io, objectServer,
                        dbusConnection, cpuConfigs, sensorConfigs);
     }
 }
 
 void detectCpuAsync(
-    boost::asio::steady_timer& pingTimer,
+    boost::asio::steady_timer& pingTimer, const size_t pingSeconds,
     boost::asio::steady_timer& creationTimer, boost::asio::io_context& io,
     sdbusplus::asio::object_server& objectServer,
     std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
     boost::container::flat_set<CPUConfig>& cpuConfigs,
     ManagedObjectType& sensorConfigs)
 {
-    pingTimer.expires_after(std::chrono::seconds(1));
+    pingTimer.expires_after(std::chrono::seconds(pingSeconds));
     pingTimer.async_wait([&](const boost::system::error_code& ec) {
         if (ec == boost::asio::error::operation_aborted)
         {
@@ -635,6 +646,11 @@ void detectCpuAsync(
         detectCpu(pingTimer, creationTimer, io, objectServer, dbusConnection,
                   cpuConfigs, sensorConfigs);
     });
+
+    if (debug)
+    {
+        std::cerr << "detectCpu in " << pingSeconds << " seconds.\n";
+    }
 }
 
 bool getCpuConfig(const std::shared_ptr<sdbusplus::asio::connection>& systemBus,
@@ -764,7 +780,7 @@ int main()
 
         if (getCpuConfig(systemBus, cpuConfigs, sensorConfigs, objectServer))
         {
-            detectCpuAsync(pingTimer, creationTimer, io, objectServer,
+            detectCpuAsync(pingTimer, fastPingSeconds, creationTimer, io, objectServer,
                            systemBus, cpuConfigs, sensorConfigs);
         }
     });
@@ -793,7 +809,7 @@ int main()
             if (getCpuConfig(systemBus, cpuConfigs, sensorConfigs,
                              objectServer))
             {
-                detectCpuAsync(pingTimer, creationTimer, io, objectServer,
+                detectCpuAsync(pingTimer, fastPingSeconds, creationTimer, io, objectServer,
                                systemBus, cpuConfigs, sensorConfigs);
             }
         });
-- 
2.25.1

