From 5d2da8af55c6d855a6dbccd7e11097989f1d44b2 Mon Sep 17 00:00:00 2001
From: Jitendra Tripathy <jitendra.kumarx.tripathy@intel.com>
Date: Wed, 30 Nov 2022 06:34:06 +0000
Subject: [PATCH] Implement OPTEE Security Feature

As part of POC, OPTEE security feature has been implemented
to ipmid which causes issues in redfish. When user is created
using the redfish/EWS, user is not accessible through RMCPP.

Add the security feature to the pam-ipmi, so all the user passwords
can be stored in the secure storage.

Tested:
Verified the functionality by creating users from IPMI Tool,
Redfish/EWS.

root@bmc-maca4bf018cc482:~# ipmitool user list 3
ID  Name             Callin  Link Auth  IPMI Msg   Channel Priv Limit
1   root             false   true       true       ADMINISTRATOR
2   debuguser        false   true       true       ADMINISTRATOR
3   user3            false   true       true       OPERATOR
4   debuguser1       true    false      true       ADMINISTRATOR
5   user12           false   true       true       OPERATOR

1. Verified using IPMITool User
Command: ipmitool -I lanplus -H <BMC-IP> -U debuguser -P <PW> -C 17
         -L ADMINISTRATOR raw 6 1
Response: 23 00 00 16 02 bf 57 01 00 29 00 04 16 df 07

2. Verified using EWS user
Command: ipmitool -I lanplus -H <BMC-IP> -U user3 -P <PW> -C 17 -L
         OPERATOR raw 6 1
Response:  23 00 00 16 02 bf 57 01 00 29 00 04 16 df 07

3. Verified using Redfish user
Command: ipmitool -I lanplus -H <BMC-IP> -U user12 -P <PW> -C 17 -L
         OPERATOR raw 6 1
Response: 23 00 00 16 02 bf 57 01 00 29 00 04 16 df 07

Signed-off-by: Jitendra Tripathy <jitendra.kumarx.tripathy@intel.com>
---
 Makefile.am                          |  5 ++
 configure.ac                         |  2 +
 src/pam_ipmisave/pam_ipmisave.c      | 22 ++++++++
 src/pam_ipmisave/passwd_mgr_secure.c | 76 ++++++++++++++++++++++++++++
 src/pam_ipmisave/passwd_mgr_secure.h | 27 ++++++++++
 5 files changed, 132 insertions(+)
 create mode 100644 src/pam_ipmisave/passwd_mgr_secure.c
 create mode 100644 src/pam_ipmisave/passwd_mgr_secure.h

diff --git a/Makefile.am b/Makefile.am
index ef21831..5f95aa8 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -18,6 +18,11 @@ pam_ipmicheck_la_LDFLAGS = \
 	$(LIBS)
 
 pam_ipmisave_la_SOURCES = src/pam_ipmisave/pam_ipmisave.c
+
+if IS_OPTEE
+pam_ipmisave_la_SOURCES += src/pam_ipmisave/passwd_mgr_secure.c
+endif
+
 pam_ipmisave_la_LDFLAGS = \
 	-module \
 	-avoid-version \
diff --git a/configure.ac b/configure.ac
index 24bb490..5c0cfe8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -6,6 +6,8 @@ AC_CONFIG_MACRO_DIRS([m4])
 AC_CONFIG_AUX_DIR([build-aux])
 AM_INIT_AUTOMAKE([subdir-objects -Wall foreign dist-xz])
 AM_SILENT_RULES([yes])
+AC_CHECK_HEADER([ipmi_pass_ta.h],
+       [AM_CONDITIONAL([IS_OPTEE], [true])])
 
 AC_SUBST(PACKAGE)
 AC_SUBST(VERSION)
diff --git a/src/pam_ipmisave/pam_ipmisave.c b/src/pam_ipmisave/pam_ipmisave.c
index c105ba6..294e7df 100644
--- a/src/pam_ipmisave/pam_ipmisave.c
+++ b/src/pam_ipmisave/pam_ipmisave.c
@@ -30,6 +30,7 @@
 #include <openssl/evp.h>
 #include <openssl/hmac.h>
 #include <openssl/rand.h>
+#include "passwd_mgr_secure.h"
 
 /*
  * This module is intended to save password of  special group user
@@ -628,6 +629,7 @@ int pam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, const char **argv)
 	const char *spec_pass_file =
 		get_option(pamh, "spec_pass_file", argc, argv);
 	const char *key_file = get_option(pamh, "key_file", argc, argv);
+	static bool teeLoaded = false;
 
 
 	if (spec_grp_name == NULL || key_file == NULL) {
@@ -669,6 +671,9 @@ int pam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, const char **argv)
 
 	pam_syslog(pamh, LOG_DEBUG, "User belongs to special grp: %x",
 		   spec_grp_usr);
+	if (!teeLoaded) {
+		teeLoaded = secPasswdMgrInit(pamh);
+	}
 
 	if (spec_grp_usr) {
 		// verify the new password is acceptable.
@@ -690,6 +695,22 @@ int pam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, const char **argv)
 				"Using default special password file name :%s",
 				spec_pass_file);
 		}
+#ifdef HAS_OPTEE
+		if (teeLoaded) {
+			bool secSuccess = secUpdatePasswd(pamh, user, user_len,
+							  pass_new, pass_len);
+			if (!secSuccess) {
+				pam_syslog(pamh, LOG_ERR,
+					   "Failed to add passwd to OPTEE");
+				return PAM_AUTHTOK_ERR;
+			}
+		} else {
+			pam_syslog(
+				pamh, LOG_ERR,
+				"Failed to Connect to OPTEE during Password change");
+			return PAM_AUTHTOK_ERR;
+		}
+#else
 		if (retval = lock_pwdf()) {
 			pam_syslog(pamh, LOG_ERR,
 				   "Failed to lock the passwd file");
@@ -699,6 +720,7 @@ int pam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, const char **argv)
 			pamh, key_file, spec_pass_file, user, pass_new);
 		unlock_pwdf();
 		return retval;
+#endif
 	}
 
 	return PAM_SUCCESS;
diff --git a/src/pam_ipmisave/passwd_mgr_secure.c b/src/pam_ipmisave/passwd_mgr_secure.c
new file mode 100644
index 0000000..0b2cc1a
--- /dev/null
+++ b/src/pam_ipmisave/passwd_mgr_secure.c
@@ -0,0 +1,76 @@
+#include "passwd_mgr_secure.h"
+
+#ifdef HAS_OPTEE
+TEEC_Result prepare_tee_session(const pam_handle_t *pamh, struct uta_ctx *ctx)
+{
+	TEEC_UUID uuid = TA_IPMI_PASS_UUID;
+	uint32_t origin;
+	TEEC_Result res;
+
+	/* Initialize a context connecting us to the TEE */
+	res = TEEC_InitializeContext(NULL, &ctx->ctx);
+	if (res != TEEC_SUCCESS) {
+		pam_syslog(pamh, LOG_ERR,
+			   "TEEC_InitializeContext failed with code %d", res);
+		return res;
+	}
+	/* Open a session with the TA */
+	res = TEEC_OpenSession(&ctx->ctx, &ctx->sess, &uuid, TEEC_LOGIN_PUBLIC,
+			       NULL, NULL, &origin);
+	if (res != TEEC_SUCCESS) {
+		pam_syslog(pamh, LOG_ERR,
+			   "TEEC_Opensession failed with code %d, %d", res,
+			   origin);
+	}
+	return res;
+}
+
+void terminate_tee_session(struct uta_ctx *ctx)
+{
+	TEEC_CloseSession(&ctx->sess);
+	TEEC_FinalizeContext(&ctx->ctx);
+}
+
+bool secUpdatePasswd(const pam_handle_t *pamh, const char *username,
+		     const size_t usernameSz, const char *password,
+		     const size_t passwordSz)
+{
+	struct uta_ctx ctx;
+	TEEC_Result res = prepare_tee_session(pamh, &ctx);
+	if (res != TEEC_SUCCESS) {
+		return false;
+	}
+
+	/*
+	 * Create object, read it, delete it.
+	 */
+	TEEC_Operation op = {};
+	uint32_t origin;
+
+	op.paramTypes =
+		TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT, TEEC_MEMREF_TEMP_INPUT,
+				 TEEC_NONE, TEEC_NONE);
+
+	op.params[0].tmpref.buffer = (char *)(username);
+	op.params[0].tmpref.size = usernameSz;
+
+	op.params[1].tmpref.buffer = (char *)(password);
+	op.params[1].tmpref.size = passwordSz;
+
+	res = TEEC_InvokeCommand(&ctx.sess, TA_INSTALL_KEY, &op, &origin);
+
+	terminate_tee_session(&ctx);
+
+	return res == TEEC_SUCCESS;
+}
+#endif
+
+bool secPasswdMgrInit(const pam_handle_t *pamh)
+{
+	if (access("/dev/teepriv0", F_OK) == 0) {
+		pam_syslog(pamh, LOG_INFO, "OPTEE is loaded");
+		return true;
+	} else {
+		return false;
+	}
+}
diff --git a/src/pam_ipmisave/passwd_mgr_secure.h b/src/pam_ipmisave/passwd_mgr_secure.h
new file mode 100644
index 0000000..d209bb8
--- /dev/null
+++ b/src/pam_ipmisave/passwd_mgr_secure.h
@@ -0,0 +1,27 @@
+#include <unistd.h>
+#include <security/pam_modules.h>
+#include <security/pam_ext.h>
+#include <security/pam_modutil.h>
+#include <syslog.h>
+#include <stdbool.h>
+
+#ifdef HAS_OPTEE
+/* OP-TEE TEE client API (built by optee_client) */
+#include <tee_client_api.h>
+
+/* TA API: UUID and command IDs */
+#include <ipmi_pass_ta.h>
+/* TEE resources */
+struct uta_ctx {
+	TEEC_Context ctx;
+	TEEC_Session sess;
+};
+TEEC_Result prepare_tee_session(const pam_handle_t *pamh, struct uta_ctx *ctx);
+void terminate_tee_session(struct uta_ctx *ctx);
+
+bool secPasswdMgrInit(const pam_handle_t *pamh);
+
+bool secUpdatePasswd(const pam_handle_t *pamh, const char *username,
+		     const size_t usernameSz, const char *password,
+		     const size_t passwordSz);
+#endif
-- 
2.17.1

